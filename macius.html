<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maciuś Marshall - Obrońca Puszczy</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            background: #0a0a0a;
            overflow: hidden;
            font-family: 'Georgia', serif;
        }

        #gameCanvas {
            display: block;
            cursor: none;
        }

        /* CUTSCENE STYLES */
        #cutsceneContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #cutsceneCanvas {
            border: 4px solid #2a1a0a;
            box-shadow: 0 0 50px rgba(139, 69, 19, 0.5);
        }

        #cutsceneTextBox {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 900px;
            background: linear-gradient(180deg, rgba(20, 10, 5, 0.95), rgba(10, 5, 2, 0.98));
            border: 3px solid #3d2817;
            border-radius: 5px;
            padding: 25px 35px;
            box-shadow: inset 0 0 30px rgba(0,0,0,0.8), 0 0 20px rgba(0,0,0,0.9);
        }

        #cutsceneText {
            color: #c9b896;
            font-size: 20px;
            line-height: 1.7;
            text-shadow: 1px 1px 2px #000;
            min-height: 80px;
        }

        #cutsceneHint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #5a4a3a;
            font-size: 14px;
            letter-spacing: 2px;
        }

        #cutsceneTitle {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #8b7355;
            font-size: 16px;
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        /* GAME UI */
        #gameUI {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
            z-index: 100;
        }

 /* NOWY STYL HUD */
#healthPanel {
    position: absolute;
    bottom: 25px;
    left: 0%;
    transform: translateX(-50%);
    display: flex;
    align-items: flex-end;
    gap: 30px;
    background: none;
    border: none;
    box-shadow: none;
    padding: 0;
    transform: scale(0.8);
}

.stat-icon {
    position: relative;
    filter: drop-shadow(0 3px 10px rgba(0, 0, 0, 0.8));
}

/* ==================== SERCE ==================== */
#playerHeartBox {
    position: relative;
    width: 135px;
    height: 135px;
    opacity: 0.75;
}

/* Tło serca - ciemne, lekko przezroczyste */
#playerHeartBox .bg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
background: linear-gradient(180deg, 
    rgba(20, 8, 8, 0.5) 0%, 
    rgba(10, 4, 4, 0.6) 100%
);
    clip-path: path('M67.5 127.5 C11.25 78.75 0 56.25 0 40.5 C0 18 18 0 40.5 0 C54 0 63 11.25 67.5 20.25 C72 11.25 81 0 94.5 0 C117 0 135 18 135 40.5 C135 56.25 123.75 78.75 67.5 127.5 Z');
}

/* Wypełnienie - ciecz */
#playerHeartBox .fill-container {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    clip-path: path('M67.5 127.5 C11.25 78.75 0 56.25 0 40.5 C0 18 18 0 40.5 0 C54 0 63 11.25 67.5 20.25 C72 11.25 81 0 94.5 0 C117 0 135 18 135 40.5 C135 56.25 123.75 78.75 67.5 127.5 Z');
}

#playerHeartBox .fill {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(180deg, 
        rgba(160, 20, 20, 0.5) 0%, 
        rgba(120, 10, 10, 0.55) 40%, 
        rgba(80, 5, 5, 0.6) 70%, 
        rgba(50, 0, 0, 0.65) 100%
    );
    transition: transform 0.3s ease-out;
    transform-origin: top center;
}

/* Efekt cieczy - odbicie światła na powierzchni */
#playerHeartBox .fill::before {
    content: '';
    position: absolute;
    top: 0;
    left: 10%;
    width: 80%;
    height: 8px;
    background: linear-gradient(180deg,
        rgba(255, 100, 100, 0.4) 0%,
        rgba(255, 50, 50, 0.2) 50%,
        transparent 100%
    );
    border-radius: 50%;
}

#playerHeartBox .fill-container::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: 
        radial-gradient(circle at 45% 85%, rgba(255, 160, 160, 0.2) 0%, transparent 5%),
        radial-gradient(circle at 80% 65%, rgba(255, 130, 130, 0.18) 0%, transparent 4%),
        radial-gradient(circle at 15% 55%, rgba(255, 140, 140, 0.22) 0%, transparent 6%),
        radial-gradient(circle at 60% 40%, rgba(255, 120, 120, 0.15) 0%, transparent 3%);
    pointer-events: none;
    z-index: 2;
    animation: bubblesFloat2 5s ease-in-out infinite;
}

@keyframes bubblesFloat2 {
    0%, 100% {
        transform: translateY(0) translateX(0);
    }
    33% {
        transform: translateY(-10px) translateX(-4px);
    }
    66% {
        transform: translateY(-5px) translateX(5px);
    }
}

/* Bąbelki w cieczy */
#playerHeartBox .fill::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: 
        radial-gradient(circle at 20% 80%, rgba(255, 150, 150, 0.25) 0%, transparent 6%),
        radial-gradient(circle at 65% 70%, rgba(255, 120, 120, 0.2) 0%, transparent 5%),
        radial-gradient(circle at 35% 60%, rgba(255, 100, 100, 0.22) 0%, transparent 4%),
        radial-gradient(circle at 75% 50%, rgba(255, 130, 130, 0.18) 0%, transparent 5%),
        radial-gradient(circle at 25% 40%, rgba(255, 140, 140, 0.2) 0%, transparent 4%),
        radial-gradient(circle at 55% 30%, rgba(255, 110, 110, 0.15) 0%, transparent 3%);
    pointer-events: none;
    animation: bubblesFloat 4s ease-in-out infinite;
}

@keyframes bubblesFloat {
    0%, 100% {
        transform: translateY(0);
    }
    25% {
        transform: translateY(-8px) translateX(3px);
    }
    50% {
        transform: translateY(-12px) translateX(-2px);
    }
    75% {
        transform: translateY(-6px) translateX(4px);
    }
}

/* Szklana powłoka - odbicie */
#playerHeartBox::before {
    content: '';
    position: absolute;
    top: 8px;
    left: 18px;
    width: 35px;
    height: 25px;
    background: linear-gradient(160deg,
        rgba(255, 255, 255, 0.15) 0%,
        rgba(255, 255, 255, 0.05) 50%,
        transparent 100%
    );
    border-radius: 50%;
    z-index: 5;
    pointer-events: none;
}

/* Ciemna krawędź - głębia */
#playerHeartBox::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    box-shadow: 
        inset 0 0 20px rgba(0, 0, 0, 0.5),
        inset 0 5px 15px rgba(0, 0, 0, 0.3);
    clip-path: path('M67.5 127.5 C11.25 78.75 0 56.25 0 40.5 C0 18 18 0 40.5 0 C54 0 63 11.25 67.5 20.25 C72 11.25 81 0 94.5 0 C117 0 135 18 135 40.5 C135 56.25 123.75 78.75 67.5 127.5 Z');
    z-index: 6;
    pointer-events: none;
}

/* ==================== TEKST ==================== */
#playerHeartBox .text {
    position: absolute;
    top: 45%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #ffffff;
    font-weight: 700;
    font-size: 24px;
    font-family: 'Georgia', serif;
    text-shadow: 
        0 0 10px rgba(0, 0, 0, 0.9),
        0 2px 4px rgba(0, 0, 0, 0.8);
    z-index: 10;
    letter-spacing: 1px;
}

/* ==================== ANIMACJE ==================== */
#playerHeartBox {
    animation: heartBeat 3s ease-in-out infinite;
    transform-origin: center center;
}

#playerHeartBox .fill.sloshing {
    animation: slosh 0.6s ease-out;
}

@keyframes slosh {
    0% {
        transform: translateY(var(--hp-offset)) rotate(0deg);
    }
    20% {
        transform: translateY(var(--hp-offset)) rotate(3deg) skewX(2deg);
    }
    40% {
        transform: translateY(var(--hp-offset)) rotate(-2deg) skewX(-1.5deg);
    }
    60% {
        transform: translateY(var(--hp-offset)) rotate(1.5deg) skewX(1deg);
    }
    80% {
        transform: translateY(var(--hp-offset)) rotate(-0.5deg) skewX(-0.5deg);
    }
    100% {
        transform: translateY(var(--hp-offset)) rotate(0deg);
    }
}

@keyframes heartBeat {
    0%, 100% { 
        transform: scale(1); 
    }
    10% { 
        transform: scale(1.04); 
    }
    20% { 
        transform: scale(1); 
    }
    30% { 
        transform: scale(1.02); 
    }
    40% {
        transform: scale(1);
    }
}

#playerHeartBox.critical {
    animation: heartBeatCritical 0.7s ease-in-out infinite;
}

@keyframes heartBeatCritical {
    0%, 100% { 
        transform: scale(1);
        filter: drop-shadow(0 3px 10px rgba(0, 0, 0, 0.8));
    }
    50% { 
        transform: scale(1.08);
        filter: drop-shadow(0 3px 10px rgba(0, 0, 0, 0.8)) drop-shadow(0 0 20px rgba(100, 0, 0, 0.6));
    }
}

/* ==================== VAPE ==================== */
.vape-icon {
    position: relative;
    width: 100px;
    height: 210px;
    opacity: 0.75;
}

/* Ustnik */
.vape-icon .vape-mouthpiece {
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 40px;
    height: 40px;
    background: linear-gradient(90deg,
        #1a1a1a 0%,
        #3a3a3a 20%,
        #4a4a4a 50%,
        #3a3a3a 80%,
        #1a1a1a 100%
    );
    border-radius: 6px 6px 0 0;
    box-shadow: 
        inset 0 5px 10px rgba(80, 80, 80, 0.2),
        inset 0 -3px 8px rgba(0, 0, 0, 0.5);
}

/* Górna krawędź ustnika */
.vape-icon .vape-mouthpiece::before {
    content: '';
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 34px;
    height: 4px;
    background: linear-gradient(90deg,
        #2a2a2a 0%,
        #5a5a5a 50%,
        #2a2a2a 100%
    );
    border-radius: 2px 2px 0 0;
}

/* Wgłębienie ustnika */
.vape-icon .vape-mouthpiece::after {
    content: '';
    position: absolute;
    top: 8px;
    left: 50%;
    transform: translateX(-50%);
    width: 26px;
    height: 12px;
    background: linear-gradient(180deg,
        #0a0a0a 0%,
        #1a1a1a 100%
    );
    border-radius: 4px 4px 8px 8px;
    box-shadow: 
        inset 0 3px 6px rgba(0, 0, 0, 0.9),
        inset 0 -2px 4px rgba(50, 50, 50, 0.3);
}

/* Główny korpus vape */
.vape-icon .vape-body {
    position: absolute;
    top: 35px;
    left: 0;
    width: 100%;
    height: 175px;
    background: linear-gradient(90deg,
        #1a1a1a 0%,
        #3a3a3a 15%,
        #4a4a4a 50%,
        #3a3a3a 85%,
        #1a1a1a 100%
    );
    border-radius: 10px;
    box-shadow: 
        inset 3px 0 10px rgba(0, 0, 0, 0.5),
        inset -3px 0 10px rgba(0, 0, 0, 0.5),
        0 5px 20px rgba(0, 0, 0, 0.6);
}

/* Zbiornik z cieczą */
.vape-icon .vape-tank {
    position: absolute;
    top: 50px;
    left: 50%;
    transform: translateX(-50%);
    width: 70px;
    height: 80px;
    background: rgba(20, 15, 25, 0.6);
    border-radius: 6px;
    overflow: hidden;
    box-shadow: 
        inset 0 0 15px rgba(0, 0, 0, 0.5),
        inset 0 0 5px rgba(120, 80, 200, 0.2);
    border: 2px solid #2a2a2a;
}

/* Wypełnienie zbiornika - ciecz */
.vape-icon .vape-liquid {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(180deg,
        rgba(140, 80, 220, 0.5) 0%,
        rgba(100, 50, 180, 0.55) 40%,
        rgba(70, 30, 140, 0.6) 70%,
        rgba(50, 20, 100, 0.65) 100%
    );
    transition: transform 0.3s ease-out;
    transform-origin: top center;
}

/* Bąbelki w cieczy */
.vape-icon .vape-liquid::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: 
        radial-gradient(circle at 20% 80%, rgba(180, 140, 255, 0.25) 0%, transparent 8%),
        radial-gradient(circle at 75% 70%, rgba(160, 120, 240, 0.2) 0%, transparent 6%),
        radial-gradient(circle at 35% 55%, rgba(170, 130, 250, 0.22) 0%, transparent 5%),
        radial-gradient(circle at 70% 40%, rgba(150, 110, 230, 0.18) 0%, transparent 7%),
        radial-gradient(circle at 25% 30%, rgba(165, 125, 245, 0.2) 0%, transparent 5%);
    pointer-events: none;
    animation: vapeBubblesFloat 4s ease-in-out infinite;
}

/* Sekcja wyświetlacza */
.vape-icon .vape-screen-area {
    position: absolute;
    top: 140px;
    left: 50%;
    transform: translateX(-50%);
    width: 75px;
    height: 50px;
    background: linear-gradient(180deg,
        #0a0a0a 0%,
        #151515 50%,
        #0a0a0a 100%
    );
    border-radius: 5px;
    border: 2px solid #333;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.8);
}

/* Wyświetlacz LCD */
.vape-icon .vape-screen {
    width: 65px;
    height: 40px;
    background: #050508;
    border-radius: 3px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 
        inset 0 0 8px rgba(0, 0, 0, 0.9),
        0 0 3px rgba(120, 80, 200, 0.1);
}

/* Tekst na wyświetlaczu */
.vape-icon .vape-text {
    color: #8855cc;
    font-family: 'Courier New', monospace;
    font-size: 18px;
    font-weight: 700;
    text-shadow: 0 0 8px rgba(136, 85, 204, 0.5);
    letter-spacing: 2px;
}

/* Przycisk */
.vape-icon .vape-button {
    position: absolute;
    top: 110px;
    right: 3px;
    width: 12px;
    height: 24px;
    background: linear-gradient(90deg,
        #2a2a2a 0%,
        #4a4a4a 50%,
        #2a2a2a 100%
    );
    border-radius: 3px;
    box-shadow: 
        inset 0 2px 3px rgba(80, 80, 80, 0.3),
        0 2px 4px rgba(0, 0, 0, 0.5);
}

/* Detale metalowe */
.vape-icon .vape-ring-top {
    position: absolute;
    top: 43px;
    left: 50%;
    transform: translateX(-50%);
    width: 85px;
    height: 7px;
    background: linear-gradient(180deg,
        #5a5a5a 0%,
        #3a3a3a 50%,
        #4a4a4a 100%
    );
    border-radius: 2px;
}

.vape-icon .vape-ring-bottom {
    position: absolute;
    top: 132px;
    left: 50%;
    transform: translateX(-50%);
    width: 85px;
    height: 6px;
    background: linear-gradient(180deg,
        #5a5a5a 0%,
        #3a3a3a 50%,
        #4a4a4a 100%
    );
    border-radius: 2px;
}

/* Otwory wentylacyjne */
.vape-icon .vape-vents {
    position: absolute;
    bottom: 12px;
    left: 50%;
    transform: translateX(-50%);
    width: 50px;
    height: 12px;
    display: flex;
    gap: 6px;
    justify-content: center;
    align-items: center;
}

.vape-icon .vape-vents::before,
.vape-icon .vape-vents::after {
    content: '';
    width: 14px;
    height: 3px;
    background: #1a1a1a;
    border-radius: 1px;
    box-shadow: 
        0 5px 0 #1a1a1a,
        inset 0 0 3px rgba(0, 0, 0, 0.8);
}

/* ==================== TABLET TAKTYCZNY ==================== */
.house-icon {
    position: relative;
    width: 120px;
    height: 160px;
    opacity: 0.85;
}

/* Obudowa tabletu */
.house-icon .tablet-body {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(180deg,
        #2a2a2a 0%,
        #1a1a1a 10%,
        #252525 50%,
        #1a1a1a 90%,
        #2a2a2a 100%
    );
    border-radius: 10px;
    box-shadow: 
        inset 2px 2px 5px rgba(60, 60, 60, 0.3),
        inset -2px -2px 5px rgba(0, 0, 0, 0.5),
        0 5px 20px rgba(0, 0, 0, 0.7);
    border: 1px solid #3a3a3a;
}

/* Ramka ekranu */
.house-icon .tablet-bezel {
    position: absolute;
    top: 8px;
    left: 8px;
    right: 8px;
    bottom: 25px;
    background: #050505;
    border-radius: 5px;
    border: 2px solid #1a1a1a;
    overflow: hidden;
}

/* Ekran - siatka taktyczna */
.house-icon .tablet-screen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: 
        linear-gradient(rgba(0, 40, 0, 0.15) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0, 40, 0, 0.15) 1px, transparent 1px);
    background-size: 10px 10px;
}

/* Scanline effect */
.house-icon .tablet-screen::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: repeating-linear-gradient(
        0deg,
        transparent 0px,
        transparent 2px,
        rgba(0, 0, 0, 0.15) 2px,
        rgba(0, 0, 0, 0.15) 4px
    );
    pointer-events: none;
}

/* ==================== OBRYS DOMU ==================== */
.house-icon .house-outline {
    position: absolute;
    top: 12px;
    left: 50%;
    transform: translateX(-50%);
    width: 70px;
    height: 70px;
}

/* Dach */
.house-icon .house-roof {
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 35px solid transparent;
    border-right: 35px solid transparent;
    border-bottom: 22px solid #00cc00;
    background: transparent;
}

.house-icon .house-roof::after {
    content: '';
    position: absolute;
    top: 5px;
    left: -30px;
    width: 0;
    height: 0;
    border-left: 30px solid transparent;
    border-right: 30px solid transparent;
    border-bottom: 17px solid #050505;
}

/* Ściany */
.house-icon .house-walls {
    position: absolute;
    top: 22px;
    left: 50%;
    transform: translateX(-50%);
    width: 56px;
    height: 42px;
    border: 2px solid #00cc00;
    background: transparent;
}

/* Drzwi */
.house-icon .house-door {
    position: absolute;
    bottom: -2px;
    left: 50%;
    transform: translateX(-50%);
    width: 12px;
    height: 20px;
    border: 2px solid #00cc00;
    border-bottom: none;
    background: transparent;
}

/* Okna */
.house-icon .house-window {
    position: absolute;
    top: 6px;
    width: 10px;
    height: 10px;
    border: 2px solid #00cc00;
    background: transparent;
}

.house-icon .house-window-left {
    left: 5px;
}

.house-icon .house-window-right {
    right: 5px;
}

/* ==================== TEKST STATUS ==================== */
.house-icon .tablet-status {
    position: absolute;
    bottom: 8px;
    left: 50%;
    transform: translateX(-50%);
}

.house-icon .status-value {
    color: #00ff00;
    font-family: 'Courier New', monospace;
    font-size: 18px;
    font-weight: 700;
    letter-spacing: 2px;
    text-shadow: 0 0 8px rgba(0, 255, 0, 0.6);
}

/* ==================== DOLNY PANEL TABLETU ==================== */
.house-icon .tablet-bottom {
    position: absolute;
    bottom: 6px;
    left: 50%;
    transform: translateX(-50%);
    width: 50px;
    height: 12px;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
}

/* Diody LED */
.house-icon .tablet-led {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: #003300;
    box-shadow: inset 0 0 2px rgba(0, 0, 0, 0.5);
}

.house-icon .tablet-led.active {
    background: #00ff00;
    box-shadow: 
        0 0 6px rgba(0, 255, 0, 0.8),
        0 0 12px rgba(0, 255, 0, 0.4);
}

/* ==================== STANY HP ==================== */

/* Normalny stan - zielony */
.house-icon.status-good .house-roof {
    border-bottom-color: #00cc00;
}

.house-icon.status-good .house-roof::after {
    border-bottom-color: #050505;
}

.house-icon.status-good .house-walls,
.house-icon.status-good .house-door,
.house-icon.status-good .house-window {
    border-color: #00cc00;
}

.house-icon.status-good .status-value {
    color: #00ff00;
    text-shadow: 0 0 8px rgba(0, 255, 0, 0.6);
}

/* Średni stan - żółty */
.house-icon.status-warning .house-roof {
    border-bottom-color: #ccaa00;
}

.house-icon.status-warning .house-roof::after {
    border-bottom-color: #050505;
}

.house-icon.status-warning .house-walls,
.house-icon.status-warning .house-door,
.house-icon.status-warning .house-window {
    border-color: #ccaa00;
}

.house-icon.status-warning .status-value {
    color: #ffcc00;
    text-shadow: 0 0 8px rgba(255, 200, 0, 0.6);
}

.house-icon.status-warning .tablet-screen {
    background: 
        linear-gradient(rgba(40, 30, 0, 0.15) 1px, transparent 1px),
        linear-gradient(90deg, rgba(40, 30, 0, 0.15) 1px, transparent 1px);
    background-size: 10px 10px;
}

.house-icon.status-warning .tablet-led.active {
    background: #ffcc00;
    box-shadow: 
        0 0 6px rgba(255, 200, 0, 0.8),
        0 0 12px rgba(255, 200, 0, 0.4);
}

/* Krytyczny stan - czerwony */
.house-icon.status-critical .house-roof {
    border-bottom-color: #cc0000;
    animation: criticalFlicker 0.5s ease-in-out infinite;
}

.house-icon.status-critical .house-roof::after {
    border-bottom-color: #050505;
}

.house-icon.status-critical .house-walls,
.house-icon.status-critical .house-door,
.house-icon.status-critical .house-window {
    border-color: #cc0000;
    animation: criticalFlicker 0.5s ease-in-out infinite;
}

.house-icon.status-critical .status-value {
    color: #ff0000;
    text-shadow: 0 0 8px rgba(255, 0, 0, 0.6);
    animation: criticalFlicker 0.5s ease-in-out infinite;
}

.house-icon.status-critical .tablet-screen {
    background: 
        linear-gradient(rgba(40, 0, 0, 0.15) 1px, transparent 1px),
        linear-gradient(90deg, rgba(40, 0, 0, 0.15) 1px, transparent 1px);
    background-size: 10px 10px;
}

.house-icon.status-critical .tablet-led.active {
    background: #ff0000;
    box-shadow: 
        0 0 6px rgba(255, 0, 0, 0.8),
        0 0 12px rgba(255, 0, 0, 0.4);
}

@keyframes criticalFlicker {
    0%, 100% {
        opacity: 1;
    }
    50% {
        opacity: 0.6;
    }
}

/* ==================== GLITCH EFFECT ==================== */
.house-icon.damage-flash .house-outline {
    animation: glitchEffect 0.3s ease-out;
}

@keyframes glitchEffect {
    0% {
        transform: translateX(-50%);
    }
    20% {
        transform: translateX(-50%) translateX(-3px) skewX(-2deg);
    }
    40% {
        transform: translateX(-50%) translateX(3px) skewX(2deg);
    }
    60% {
        transform: translateX(-50%) translateX(-2px);
    }
    80% {
        transform: translateX(-50%) translateX(1px);
    }
    100% {
        transform: translateX(-50%);
    }
}

/* ==================== ANIMACJE ==================== */

/* Bicie serca - wolne */
#playerHeartBox {
    animation: heartBeatSlow 2.5s ease-in-out infinite;
    transform-origin: center center;
}

@keyframes heartBeatSlow {
    0%, 100% { 
        transform: scale(1); 
    }
    15% { 
        transform: scale(1.08); 
    }
    30% { 
        transform: scale(1); 
    }
    45% { 
        transform: scale(1.05); 
    }
    60% {
        transform: scale(1);
    }
}

/* Bicie serca - krytyczne */
#playerHeartBox.critical {
    animation: heartBeatCritical 0.6s ease-in-out infinite;
}

@keyframes heartBeatCritical {
    0%, 100% { 
        transform: scale(1);
        filter: drop-shadow(0 4px 15px rgba(0, 0, 0, 0.7)) drop-shadow(0 0 20px rgba(255, 0, 0, 0.5));
    }
    50% { 
        transform: scale(1.12);
        filter: drop-shadow(0 4px 15px rgba(0, 0, 0, 0.7)) drop-shadow(0 0 40px rgba(255, 0, 0, 0.8));
    }
}

/* Domek - subtelne świecenie przy niskim HP */
.house-icon.warning {
    animation: houseWarning 1.5s ease-in-out infinite;
}

@keyframes houseWarning {
    0%, 100% {
        filter: drop-shadow(0 4px 15px rgba(0, 0, 0, 0.7));
    }
    50% {
        filter: drop-shadow(0 4px 15px rgba(0, 0, 0, 0.7)) drop-shadow(0 0 25px rgba(255, 150, 0, 0.6));
    }
}

/* Vape - świecenie podczas używania */
.vape-icon.active {
    animation: vapeActive 0.3s ease-in-out infinite;
}

@keyframes vapeActive {
    0%, 100% {
        filter: drop-shadow(0 4px 15px rgba(0, 0, 0, 0.7)) drop-shadow(0 0 30px rgba(160, 100, 255, 0.7));
    }
    50% {
        filter: drop-shadow(0 4px 15px rgba(0, 0, 0, 0.7)) drop-shadow(0 0 50px rgba(180, 120, 255, 0.9));
    }
}

        @keyframes beat-slow {
            0%, 100% { transform: scale(1); } 10% { transform: scale(1.1); }
        }
        @keyframes beat-fast {
            0%, 100% { transform: scale(1); } 25% { transform: scale(1.15); }
        }
        #weaponPanel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(15, 10, 5, 0.9), rgba(25, 15, 8, 0.85));
            border: 2px solid #3d2817;
            padding: 15px 20px;
            border-radius: 3px;
            box-shadow: 0 0 20px rgba(0,0,0,0.7);
            text-align: right;
        }

        #weaponName {
            color: #c9b896;
            font-size: 18px;
            margin-bottom: 5px;
        }

        #ammoCount {
            color: #7a6a5a;
            font-size: 14px;
        }

        #sniperAmmo {
            color: #c9a227;
            font-size: 13px;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #3d2817;
        }

        #statsPanel {
            position: absolute;
            top: 70px;
            left: 20px;
            /* Brak tła i ramki */
            text-align: left;
            z-index: 100;
            pointer-events: none;
        }

        #waveCount {
            color: #8b0000; /* Ciemna czerwień */
            font-family: 'Georgia', serif;
            font-size: 32px; /* Duże, ale mniejsze niż intro */
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 2px 2px 0px #000; /* Twardy cień */
            margin-bottom: 5px;
        }

        #killCount {
            color: #8b0000; /* Ciemna czerwień */
            font-family: 'Georgia', serif;
            font-size: 18px; /* Duże, ale mniejsze niż intro */
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 2px 2px 0px #000; /* Twardy cień */
            margin-bottom: 5px;
        }

        .sub-stat {
            color: #c9b896; /* Beżowy */
            font-family: 'Courier New', monospace; /* Techniczny */
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
            margin-bottom: 2px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .sub-stat .icon {
            color: #a0a0a0; /* Szara zębatka */
            font-size: 18px;
        }

        #waveAnnouncement {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #8b0000;
            font-size: 48px;
            text-shadow: 0 0 30px rgba(139, 0, 0, 0.8), 2px 2px 4px #000;
            letter-spacing: 8px;
            text-transform: uppercase;
            opacity: 0;
            transition: opacity 0.5s;
        }

        #controlsHint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #4a3a2a;
            font-size: 12px;
            letter-spacing: 1px;
        }

        /* GAME OVER */
        #gameOverScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 500;
        }

        #gameOverTitle {
            color: #8b0000;
            font-size: 72px;
            text-shadow: 0 0 50px rgba(139, 0, 0, 0.8);
            letter-spacing: 10px;
            margin-bottom: 20px;
        }

        #gameOverReason {
            color: #7a6a5a;
            font-size: 24px;
            margin-bottom: 40px;
        }

        #gameOverStats {
            color: #c9b896;
            font-size: 20px;
            margin-bottom: 40px;
        }

        #restartBtn {
            background: linear-gradient(135deg, #2a1a0a, #3d2817);
            border: 2px solid #5a4030;
            color: #c9b896;
            padding: 15px 50px;
            font-size: 18px;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.3s;
            font-family: 'Georgia', serif;
            letter-spacing: 3px;
        }

        #restartBtn:hover {
            background: linear-gradient(135deg, #3d2817, #5a4030);
            box-shadow: 0 0 30px rgba(139, 105, 20, 0.5);
        }

        /* PICKUP NOTIFICATION */
        #pickupNotification {
            position: absolute;
            top: 150px;
            left: 50%;
            transform: translateX(-50%);
            color: #c9a227;
            font-size: 18px;
            opacity: 0;
            transition: opacity 0.3s;
            text-shadow: 0 0 10px rgba(201, 162, 39, 0.8);
        }
		
		    #inventoryPanel {
            position: absolute;
            top: 100px; /* Trochę niżej niż statystyki */
            left: 20px;
            background: linear-gradient(135deg, rgba(15, 10, 5, 0.9), rgba(25, 15, 8, 0.85));
            border: 2px solid #3d2817;
            padding: 15px 25px;
            border-radius: 3px;
            box-shadow: 0 0 20px rgba(0,0,0,0.7);
            text-align: left;
        }

        .inv-item {
            color: #c9b896;
            font-size: 16px;
            margin: 5px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .inv-icon {
            font-weight: bold;
            font-size: 18px;
        }
		
		        #waveTimerPanel {
            position: absolute;
            top: 80px; /* Poniżej tytułu */
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            display: none; /* Domyślnie ukryty */
            z-index: 101;
        }

        #timerText {
            color: #ff3333;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            letter-spacing: 2px;
        }

        #skipHint {
            color: #c9b896;
            font-size: 14px;
            margin-top: 5px;
            opacity: 0.8;
            animation: pulseText 1.5s infinite;
        }

                #bossContainer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            display: none; /* Ukryty domyślnie */
            z-index: 102;
            
            /* Animacja pojawiania się */
            animation: bossBarFadeIn 2s ease-out;
        }

        @keyframes bossBarFadeIn {
            0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
            100% { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        #bossNameTitle {
            color: #8b0000; font-size: 24px; text-align: center;
            text-transform: uppercase; letter-spacing: 5px; 
            text-shadow: 0 0 10px #000; margin-bottom: 5px; font-weight: bold;
        }
        #bossHealthBorder {
            width: 100%; height: 30px; background: #1a0a05;
            border: 3px solid #3d2817; position: relative;
        }
        #bossHealthFill {
            height: 100%; width: 100%;
            background: linear-gradient(90deg, #8b0000, #ff0000, #8b0000);
            transition: width 0.2s;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
        }
        #bossNameMain {
            color: #b71c1c; /* Krwisty */
            font-size: 32px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 8px;
            font-weight: 900;
            text-shadow: 2px 2px 0px #000;
            margin-bottom: 0px; /* Blisko tytułu */
            font-family: 'Georgia', serif;
        }

        #bossNameTitle {
            color: #757575; /* Szary/Srebrny */
            font-size: 16px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 4px;
            text-shadow: 1px 1px 2px #000;
            margin-bottom: 8px; /* Odstęp od paska */
            font-style: italic;
        }

        @keyframes pulseText {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        #healthPanel, 
        #inventoryPanel, 
        #weaponPanel, 
        #statsPanel, 
        #bossContainer,
        #waveTimerPanel {
            pointer-events: none;
        }

        body, canvas, div {
    cursor: none;
}
        /* Wyjątek dla przycisku restartu (żebyś mógł w niego kliknąć) */
        #restartBtn {
            cursor: pointer !important;
            pointer-events: auto;
        }

 /* STOS APTECZEK */
#medkitStack {
    display: flex;
    flex-direction: column-reverse;
    margin-right: 15px;
    justify-content: flex-end;
    gap: 4px;
    height: 180px;
    position: relative;
}

.med-slot {
    width: 48px;
    height: 32px;
    background: linear-gradient(180deg,
        rgba(30, 15, 10, 0.7) 0%,
        rgba(15, 8, 5, 0.8) 100%
    );
    border: 2px solid #2a1a15;
    border-radius: 4px;
    position: relative;
    transition: all 0.3s ease;
    box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.5);
}

.med-slot:first-child {
    margin-top: 0;
}

/* Pełna apteczka */
.med-slot.filled {
    background: linear-gradient(180deg,
        #f5f5f5 0%,
        #e0e0e0 20%,
        #d5d5d5 50%,
        #c8c8c8 80%,
        #b0b0b0 100%
    );
    border: 2px solid #888888;
    box-shadow: 
        0 3px 6px rgba(0, 0, 0, 0.4),
        inset 0 2px 4px rgba(255, 255, 255, 0.5),
        inset 0 -2px 4px rgba(0, 0, 0, 0.15);
}

/* Górna krawędź apteczki - metalowa */
.med-slot.filled::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 6px;
    background: linear-gradient(180deg,
        #aaaaaa 0%,
        #888888 50%,
        #999999 100%
    );
    border-radius: 2px 2px 0 0;
    border-bottom: 1px solid #777777;
}

/* Uchwyt apteczki */
.med-slot.filled::after {
    content: '';
    position: absolute;
    top: -4px;
    left: 50%;
    transform: translateX(-50%);
    width: 20px;
    height: 6px;
    background: linear-gradient(180deg,
        #999999 0%,
        #777777 50%,
        #888888 100%
    );
    border-radius: 3px 3px 0 0;
    border: 1px solid #666666;
    border-bottom: none;
}

/* Czerwony krzyż - kontener */
.med-cross {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 20px;
    height: 20px;
    margin-top: 2px;
}

/* Krzyż - pionowa część */
.med-cross::before {
    content: '';
    position: absolute;
    top: 2px;
    left: 50%;
    transform: translateX(-50%);
    width: 6px;
    height: 16px;
    background: linear-gradient(90deg,
        #cc0000 0%,
        #ff0000 30%,
        #dd0000 70%,
        #bb0000 100%
    );
    border-radius: 1px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}

/* Krzyż - pozioma część */
.med-cross::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 2px;
    transform: translateY(-50%);
    width: 16px;
    height: 6px;
    background: linear-gradient(180deg,
        #cc0000 0%,
        #ff0000 30%,
        #dd0000 70%,
        #bb0000 100%
    );
    border-radius: 1px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}

/* Zatrzaski apteczki */
.med-slot.filled .med-latch-left,
.med-slot.filled .med-latch-right {
    position: absolute;
    bottom: 4px;
    width: 6px;
    height: 4px;
    background: linear-gradient(180deg,
        #888888 0%,
        #666666 100%
    );
    border-radius: 1px;
    box-shadow: inset 0 1px 1px rgba(255, 255, 255, 0.3);
}

.med-slot.filled .med-latch-left {
    left: 6px;
}

.med-slot.filled .med-latch-right {
    right: 6px;
}

/* Cień pod każdą apteczką dla efektu 3D */
.med-slot.filled + .med-slot.filled::before {
    box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.2);
}

/* Hover - lekkie uniesienie */
.med-slot.filled:hover {
    transform: translateY(-2px);
    box-shadow: 
        0 5px 10px rgba(0, 0, 0, 0.5),
        inset 0 2px 4px rgba(255, 255, 255, 0.5),
        inset 0 -2px 4px rgba(0, 0, 0, 0.15);
}

/* Animacja dodawania apteczki */
@keyframes medkitAdd {
    0% {
        transform: translateY(-20px) scale(1.1);
        opacity: 0;
    }
    50% {
        transform: translateY(5px) scale(1);
    }
    100% {
        transform: translateY(0) scale(1);
        opacity: 1;
    }
}

.med-slot.filled.new {
    animation: medkitAdd 0.4s ease-out;
}
/* KONTENER MAGAZYNKÓW */
#ammoContainer {
    display: flex;
    flex-direction: row;
    gap: 0;
    margin-left: 15px;
    align-items: flex-end;
    height: 220px;
}

/* Pojedynczy magazynek */
.ammo-mag {
    width: 110px;
    height: 200px;
    background: linear-gradient(90deg,
        rgba(26, 26, 26, 0.85) 0%,
        rgba(45, 45, 45, 0.85) 8%,
        rgba(58, 58, 58, 0.85) 50%,
        rgba(45, 45, 45, 0.85) 92%,
        rgba(26, 26, 26, 0.85) 100%
    );
    border: 3px solid rgba(74, 74, 74, 0.9);
    border-radius: 6px 6px 8px 8px;
    display: flex;
    flex-direction: column;
    padding: 8px 8px 12px 8px;
    gap: 4px;
    position: relative;
    box-shadow:
        inset 3px 0 6px rgba(0, 0, 0, 0.5),
        inset -3px 0 6px rgba(0, 0, 0, 0.5),
        0 5px 15px rgba(0, 0, 0, 0.6);
    opacity: 0.9;
    margin-left: -55px;
    transition: 
        transform 0.5s ease-out,
        opacity 0.5s ease-out;
}

.ammo-mag:first-child {
    margin-left: 0;
}

.ammo-mag#mag1 {
    z-index: 3;
}

.ammo-mag#mag2 {
    z-index: 2;
}

.ammo-mag#mag3 {
    z-index: 1;
}
/* Górna krawędź magazynka - otwór podawania */
.ammo-mag::before {
    content: '';
    position: absolute;
    top: -3px;
    left: 50%;
    transform: translateX(-50%);
    width: 70px;
    height: 6px;
    background: linear-gradient(180deg,
        #2a2a2a 0%,
        #1a1a1a 100%
    );
    border-radius: 3px 3px 0 0;
    border: 2px solid #4a4a4a;
    border-bottom: none;
}

/* Zablokowany magazynek - niewidoczny */
.ammo-mag.locked {
    transform: translateY(300px);
    opacity: 0;
    pointer-events: none;
}

@keyframes magSlideIn {
    0% {
        transform: translateY(300px);
        opacity: 0;
    }
    70% {
        transform: translateY(-10px);
        opacity: 0.9;
    }
    100% {
        transform: translateY(0);
        opacity: 0.9;
    }
}

.ammo-mag.appearing {
    animation: magSlideIn 0.5s ease-out forwards;
}

@keyframes magAppear {
    0% {
        transform: translateY(250px);
        opacity: 0;
    }
    60% {
        transform: translateY(-10px);
        opacity: 0.9;
    }
    100% {
        transform: translateY(0);
        opacity: 0.9;
    }
}

/* Sprężyna - dynamiczna wysokość */
.ammo-mag .mag-spring {
    position: absolute;
    bottom: 12px;
    left: 10px;
    right: 10px;
    height: var(--spring-height, 0px);
    background: repeating-linear-gradient(
        180deg,
        #555555 0px,
        #555555 4px,
        #3a3a3a 4px,
        #3a3a3a 8px
    );
    border-radius: 3px;
    box-shadow: 
        inset 0 2px 4px rgba(80, 80, 80, 0.3),
        inset 0 -2px 4px rgba(0, 0, 0, 0.4);
    transition: height 0.3s ease-out;
    z-index: 1;
}

/* Górna część sprężyny - dociskacz */
.ammo-mag .mag-spring::before {
    content: '';
    position: absolute;
    top: -6px;
    left: 50%;
    transform: translateX(-50%);
    width: 80px;
    height: 8px;
    background: linear-gradient(180deg,
        #5a5a5a 0%,
        #4a4a4a 50%,
        #3a3a3a 100%
    );
    border-radius: 3px;
    border: 1px solid #666666;
    box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.3);
}

/* Kontener na naboje */
.ammo-mag .bullets-container {
    display: flex;
    flex-direction: column;
    gap: 4px;
    position: relative;
    z-index: 2;
}

.ammo-mag.shifting-left {
    animation: shiftLeft 0.4s ease-out;
}

@keyframes shiftLeft {
    0% {
        transform: translateX(0);
    }
    50% {
        transform: translateX(-15px);
    }
    100% {
        transform: translateX(0);
    }
}

/* Slot na nabój */
.bullet-slot {
    width: 100%;
    height: 30px;
    position: relative;
    z-index: 2;
    opacity: 0;
    transform: translateY(20px);
    transition: 
        opacity 0.3s ease-out,
        transform 0.3s ease-out;
}

/* Pełny nabój - widoczny */
.bullet-slot.filled {
    opacity: 1;
    transform: translateY(0);
}

/* Animacja usuwania naboju */
.bullet-slot.removing {
    opacity: 0;
    transform: translateY(-30px) scale(0.8);
    transition: 
        opacity 0.2s ease-in,
        transform 0.2s ease-in;
}

/* Animacja przesuwania naboju w górę */
.bullet-slot.shifting {
    animation: shiftUp 0.3s ease-out;
}

@keyframes shiftUp {
    0% {
        transform: translateY(34px);
    }
    100% {
        transform: translateY(0);
    }
}

/* Animacja dodawania naboju */
.bullet-slot.adding {
    animation: addBullet 0.4s ease-out;
}

@keyframes addBullet {
    0% {
        opacity: 0;
        transform: translateY(40px) scale(0.8);
    }
    60% {
        opacity: 1;
        transform: translateY(-5px) scale(1.02);
    }
    100% {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

/* Łuska naboju - duża, mosiężna */
.bullet-slot.filled::before {
    content: '';
    position: absolute;
    top: 3px;
    left: 6px;
    width: 55px;
    height: 24px;
    background: linear-gradient(180deg,
        #e8c252 0%,
        #d4a84b 15%,
        #c9952a 40%,
        #b8860b 60%,
        #a67c00 85%,
        #8b6914 100%
    );
    border-radius: 3px;
    box-shadow:
        inset 0 3px 5px rgba(255, 230, 150, 0.5),
        inset 0 -3px 5px rgba(100, 70, 0, 0.5),
        0 2px 3px rgba(0, 0, 0, 0.4);
}

/* Pocisk - duży, miedziany, ostry */
.bullet-slot.filled::after {
    content: '';
    position: absolute;
    top: 5px;
    left: 61px;
    width: 30px;
    height: 20px;
    background: linear-gradient(180deg,
        #d4703a 0%,
        #c45e28 20%,
        #b04818 50%,
        #983810 80%,
        #7a2808 100%
    );
    border-radius: 0 12px 12px 0;
    clip-path: polygon(0% 0%, 70% 0%, 100% 50%, 70% 100%, 0% 100%);
    box-shadow:
        inset 0 3px 4px rgba(255, 160, 100, 0.4),
        inset 0 -3px 4px rgba(80, 30, 0, 0.5),
        2px 0 3px rgba(0, 0, 0, 0.4);
}

/* Rowek na łusce */
.bullet-slot.filled .casing-groove {
    position: absolute;
    top: 21px;
    left: 6px;
    width: 55px;
    height: 4px;
    background: linear-gradient(180deg,
        #7a5a10 0%,
        #a67c00 50%,
        #7a5a10 100%
    );
    border-radius: 0 0 3px 3px;
}

/* Spłonka na spodzie łuski */
.bullet-slot.filled .primer {
    position: absolute;
    top: 9px;
    left: 0px;
    width: 10px;
    height: 10px;
    background: radial-gradient(circle,
        #999999 0%,
        #777777 50%,
        #555555 100%
    );
    border-radius: 50%;
    border: 2px solid #444444;
    box-shadow: inset 0 1px 2px rgba(200, 200, 200, 0.3);
}

/* Tekstura metalowa magazynka */
.ammo-mag .mag-texture {
    position: absolute;
    top: 10px;
    left: 5px;
    right: 5px;
    bottom: 15px;
    background: repeating-linear-gradient(
        90deg,
        transparent 0px,
        transparent 8px,
        rgba(255, 255, 255, 0.02) 8px,
        rgba(255, 255, 255, 0.02) 10px
    );
    pointer-events: none;
    z-index: 0;
    border-radius: 3px;
}

/* Wzmocnienia boczne magazynka */
.ammo-mag .mag-reinforcement-left,
.ammo-mag .mag-reinforcement-right {
    position: absolute;
    top: 20px;
    bottom: 20px;
    width: 6px;
    background: linear-gradient(90deg,
        #3a3a3a 0%,
        #4a4a4a 50%,
        #3a3a3a 100%
    );
    z-index: 3;
    border-radius: 2px;
}

.ammo-mag .mag-reinforcement-left {
    left: 0;
    border-right: 1px solid #555555;
}

.ammo-mag .mag-reinforcement-right {
    right: 0;
    border-left: 1px solid #555555;
}

/* Dolna podstawa magazynka */
.ammo-mag .mag-baseplate {
    position: absolute;
    bottom: -3px;
    left: -3px;
    right: -3px;
    height: 12px;
    background: linear-gradient(180deg,
        #3a3a3a 0%,
        #2a2a2a 50%,
        #1a1a1a 100%
    );
    border: 3px solid #4a4a4a;
    border-top: 2px solid #555555;
    border-radius: 0 0 8px 8px;
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.5);
}
    </style>
</head>
<body>
    <div id="cutsceneContainer">
        <div id="cutsceneTitle">PROLOG</div>
        <canvas id="cutsceneCanvas" width="900" height="500"></canvas>
        <div id="cutsceneTextBox">
            <div id="cutsceneText"></div>
        </div>
        <div id="cutsceneHint">[ SPACJA ] aby kontynuować</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="gameUI">
        <div id="bossContainer">
            <!-- Imię -->
            <div id="bossNameMain">PABLOBITOS</div>
            <!-- Tytuł -->
            <div id="bossNameTitle">TUCZNIK ZAGŁADY</div>
            <!-- Pasek -->
            <div id="bossHealthBorder">
                <div id="bossHealthFill"></div>
            </div>
        </div>
        </div>
<!-- NOWY HUD ZDROWIA -->
<div id="healthPanel">
<!-- STOS APTECZEK (5 slotów) -->
<div id="medkitStack">
    <div class="med-slot">
        <div class="med-cross"></div>
        <div class="med-latch-left"></div>
        <div class="med-latch-right"></div>
    </div>
    <div class="med-slot">
        <div class="med-cross"></div>
        <div class="med-latch-left"></div>
        <div class="med-latch-right"></div>
    </div>
    <div class="med-slot">
        <div class="med-cross"></div>
        <div class="med-latch-left"></div>
        <div class="med-latch-right"></div>
    </div>
    <div class="med-slot">
        <div class="med-cross"></div>
        <div class="med-latch-left"></div>
        <div class="med-latch-right"></div>
    </div>
    <div class="med-slot">
        <div class="med-cross"></div>
        <div class="med-latch-left"></div>
        <div class="med-latch-right"></div>
    </div>
</div>
    <!-- ZDROWIE GRACZA -->
    <div class="stat-icon" id="playerHeartBox">
        <div class="bg"></div>
        <div class="fill-container">
            <div id="playerHpFill" class="fill"></div>
        </div>
        <div class="text" id="hpText">100</div>
    </div>

    <!-- VAPE -->
    <div class="stat-icon vape-icon" id="vapeBox">
        <div class="vape-mouthpiece"></div>
        <div class="vape-body"></div>
        <div class="vape-ring-top"></div>
        <div class="vape-tank">
            <div id="vapeLiquid" class="vape-liquid"></div>
        </div>
        <div class="vape-ring-bottom"></div>
        <div class="vape-button"></div>
        <div class="vape-screen-area">
            <div class="vape-screen">
                <span class="vape-text" id="vapeText">0</span>
            </div>
        </div>
        <div class="vape-vents"></div>
    </div>

<!-- DOMEK - TABLET TAKTYCZNY -->
<div class="stat-icon house-icon status-good" id="houseBox">
    <div class="tablet-body"></div>
    <div class="tablet-bezel">
        <div class="tablet-screen"></div>
        <div class="house-outline">
            <div class="house-roof"></div>
            <div class="house-walls">
                <div class="house-door"></div>
                <div class="house-window house-window-left"></div>
                <div class="house-window house-window-right"></div>
            </div>
        </div>
        <div class="tablet-status">
            <span class="status-value" id="houseText">100%</span>
        </div>
    </div>
    <div class="tablet-bottom">
        <div class="tablet-led active"></div>
        <div class="tablet-led active"></div>
        <div class="tablet-led active"></div>
    </div>
</div>
<!-- AMUNICJA SNAJPERKI (3 Magazynki po 5 naboi) -->
<div id="ammoContainer">
    <!-- Magazynek 1 (Dostępny od startu) -->
    <div class="ammo-mag" id="mag1">
        <div class="mag-texture"></div>
        <div class="mag-reinforcement-left"></div>
        <div class="mag-reinforcement-right"></div>
        <div class="mag-spring"></div>
        <div class="bullets-container">
            <div class="bullet-slot"><span class="casing-groove"></span><span class="primer"></span></div>
            <div class="bullet-slot"><span class="casing-groove"></span><span class="primer"></span></div>
            <div class="bullet-slot"><span class="casing-groove"></span><span class="primer"></span></div>
            <div class="bullet-slot"><span class="casing-groove"></span><span class="primer"></span></div>
            <div class="bullet-slot"><span class="casing-groove"></span><span class="primer"></span></div>
        </div>
        <div class="mag-baseplate"></div>
    </div>
    <!-- Magazynek 2 (Tier 1) -->
    <div class="ammo-mag locked" id="mag2">
        <div class="mag-texture"></div>
        <div class="mag-reinforcement-left"></div>
        <div class="mag-reinforcement-right"></div>
        <div class="mag-spring"></div>
        <div class="bullets-container">
            <div class="bullet-slot"><span class="casing-groove"></span><span class="primer"></span></div>
            <div class="bullet-slot"><span class="casing-groove"></span><span class="primer"></span></div>
            <div class="bullet-slot"><span class="casing-groove"></span><span class="primer"></span></div>
            <div class="bullet-slot"><span class="casing-groove"></span><span class="primer"></span></div>
            <div class="bullet-slot"><span class="casing-groove"></span><span class="primer"></span></div>
        </div>
        <div class="mag-baseplate"></div>
    </div>
    <!-- Magazynek 3 (Tier 2) -->
    <div class="ammo-mag locked" id="mag3">
        <div class="mag-texture"></div>
        <div class="mag-reinforcement-left"></div>
        <div class="mag-reinforcement-right"></div>
        <div class="mag-spring"></div>
        <div class="bullets-container">
            <div class="bullet-slot"><span class="casing-groove"></span><span class="primer"></span></div>
            <div class="bullet-slot"><span class="casing-groove"></span><span class="primer"></span></div>
            <div class="bullet-slot"><span class="casing-groove"></span><span class="primer"></span></div>
            <div class="bullet-slot"><span class="casing-groove"></span><span class="primer"></span></div>
            <div class="bullet-slot"><span class="casing-groove"></span><span class="primer"></span></div>
        </div>
        <div class="mag-baseplate"></div>
    </div>
</div>

</div>
        <div id="statsPanel">
            <div id="waveCount">FALA I</div>
            <div class="sub-stat" id="killCount">ELIMINACJE: 0</div>
            <div class="sub-stat">
                <span class="icon">⚙</span> <span id="scrapCount">0</span>
            </div>
        </div>

		<div id="waveTimerPanel">
            <div id="timerText">KOLEJNA FALA ZA: 40s</div>
            <div id="skipHint">[ SPACJA ] ABY ROZPOCZĄĆ</div>
        </div>
        <div id="waveAnnouncement"></div>
        <div id="pickupNotification"></div>
        <div id="controlsHint">WASD - ruch | LPM - strzał | Q - zmień broń | E - mgła bojowa | R - Naprawa/Interakcje | F - Leczenie</div>
    </div>

    <div id="gameOverScreen">
        <div id="gameOverTitle">KONIEC</div>
        <div id="gameOverReason">Puszcza pochłonęła kolejną ofiarę...</div>
        <div id="gameOverStats">Eliminacje: 0 | Fala: I</div>
        <button id="restartBtn">SPRÓBUJ PONOWNIE</button>
    </div>

    <script>
        // ==================== CUTSCENE SYSTEM ====================
        const cutsceneCanvas = document.getElementById('cutsceneCanvas');
        const cutsceneCtx = cutsceneCanvas.getContext('2d');
        const cutsceneContainer = document.getElementById('cutsceneContainer');
        const cutsceneTextEl = document.getElementById('cutsceneText');
        const cutsceneTitleEl = document.getElementById('cutsceneTitle');

        const cutscenes = [
            {
                title: "PROLOG",
                text: "Rok 1987. Głęboko w Puszczy Karpackiej, gdzie światło słoneczne z trudem przebija się przez gęste korony drzew, stoi samotna leśniczówka. To dom Macieja Marshalla - człowieka, który od dwudziestu lat strzeże tych ziem.",
                scene: "forest_cabin"
            },
            {
                title: "PROLOG",
                text: "Maciej nie jest zwykłym leśniczym. Weteran, były żołnierz, człowiek który widział więcej śmierci niż ktokolwiek powinien. Przybył tutaj szukając spokoju. Znalazł coś zupełnie innego.",
                scene: "maciej_portrait"
            },
            {
                title: "KARELUS",
                text: "W najgłębszej części puszczy, gdzie nawet zwierzęta boją się wchodzić, spoczywa KARELUS. Pradawna kula z nieznanego materiału, czczona przez dziki od zarania dziejów. Mówią, że to serce lasu. Mówią, że ma świadomość.",
                scene: "karelus"
            },
            {
                title: "ZBEZCZESZCZENIE",
                text: "Tydzień temu Maciej podczas patrolu natknął się na polanę z Karelusem. Nie wierząc w zabobony, podszedł do kuli i... zostawił na niej swój znak. Akt prostackiej bezmyślności, który obudził coś, co powinno spać wiecznie.",
                scene: "desecration"
            },
            {
                title: "PRZEBUDZENIE",
                text: "Tej nocy las zadrżał. Karelus zapłonął krwistym światłem, a jego psychiczny krzyk dotarł do umysłu każdego dzika w promieniu stu kilometrów. Jedno słowo, powtarzane w nieskończoność: ZEMSTA.",
                scene: "awakening"
            },
            {
                title: "OBLĘŻENIE",
                text: "Teraz hordy nadciągają. Setki dzików, ogarnięte pradawną furią, zmierzają ku żółtej leśniczówce. Maciej chwyta za broń. Wie, że tej nocy albo on zginie, albo las spłynie krwią.",
                scene: "siege_coming"
            },
            {
                title: "OSTATNIA NOC",
                text: "Ma przy sobie stary rewolwer ojca - niezawodny towarzysz wielu potyczek. Gdzieś w lesie ukryte są naboje do snajperki - broni zdolnej przeszyć kilku wrogów naraz. I jeszcze jedno... tajemniczy inhalator, który daje mu nadludzkie zdolności.",
                scene: "weapons"
            }
        ];

        let currentCutscene = 0;
        let cutsceneAnimationFrame = 0;

        function drawCutscene(scene) {
            cutsceneCtx.fillStyle = '#0a0805';
            cutsceneCtx.fillRect(0, 0, 900, 500);
            cutsceneAnimationFrame++;

            switch(scene) {
                case "forest_cabin":
                    drawForestCabinScene();
                    break;
                case "maciej_portrait":
                    drawMaciejPortrait();
                    break;
                case "karelus":
                    drawKarelusScene();
                    break;
                case "desecration":
                    drawDesecrationScene();
                    break;
                case "awakening":
                    drawAwakeningScene();
                    break;
                case "siege_coming":
                    drawSiegeScene();
                    break;
                case "weapons":
                    drawWeaponsScene();
                    break;
            }

            // Vignette
            const vignette = cutsceneCtx.createRadialGradient(450, 250, 100, 450, 250, 500);
            vignette.addColorStop(0, 'rgba(0,0,0,0)');
            vignette.addColorStop(1, 'rgba(0,0,0,0.7)');
            cutsceneCtx.fillStyle = vignette;
            cutsceneCtx.fillRect(0, 0, 900, 500);

            // Film grain
            cutsceneCtx.fillStyle = `rgba(0,0,0,${Math.random() * 0.1})`;
            for (let i = 0; i < 1000; i++) {
                cutsceneCtx.fillRect(Math.random() * 900, Math.random() * 500, 1, 1);
            }
        }

        function drawForestCabinScene() {
            // Sky
            const skyGrad = cutsceneCtx.createLinearGradient(0, 0, 0, 200);
            skyGrad.addColorStop(0, '#1a1520');
            skyGrad.addColorStop(1, '#2d2035');
            cutsceneCtx.fillStyle = skyGrad;
            cutsceneCtx.fillRect(0, 0, 900, 200);

            // Moon
            cutsceneCtx.fillStyle = '#c9c9b0';
            cutsceneCtx.beginPath();
            cutsceneCtx.arc(750, 80, 40, 0, Math.PI * 2);
            cutsceneCtx.fill();
            cutsceneCtx.fillStyle = '#1a1520';
            cutsceneCtx.beginPath();
            cutsceneCtx.arc(735, 75, 35, 0, Math.PI * 2);
            cutsceneCtx.fill();

            // Background trees
            for (let i = 0; i < 20; i++) {
                drawDetailedTree(cutsceneCtx, 50 + i * 50, 180, 0.6, '#0a0f05');
            }

            // Ground
            const groundGrad = cutsceneCtx.createLinearGradient(0, 200, 0, 500);
            groundGrad.addColorStop(0, '#1a2010');
            groundGrad.addColorStop(1, '#0a0f05');
            cutsceneCtx.fillStyle = groundGrad;
            cutsceneCtx.fillRect(0, 200, 900, 300);

            // Middle trees
            for (let i = 0; i < 10; i++) {
                drawDetailedTree(cutsceneCtx, 30 + i * 100, 250, 1, '#152010');
            }

            // Cabin
            drawDetailedCabin(cutsceneCtx, 350, 280, 1.5);

            // Foreground trees
            drawDetailedTree(cutsceneCtx, 80, 450, 1.8, '#0a1505');
            drawDetailedTree(cutsceneCtx, 800, 480, 2, '#0a1505');

            // Fog
            cutsceneCtx.fillStyle = 'rgba(150, 140, 120, 0.1)';
            for (let i = 0; i < 5; i++) {
                cutsceneCtx.beginPath();
                cutsceneCtx.ellipse(450 + Math.sin(cutsceneAnimationFrame / 50 + i) * 100, 350 + i * 30, 400, 30, 0, 0, Math.PI * 2);
                cutsceneCtx.fill();
            }
        }

        function drawMaciejPortrait() {
            // Dark background
            const bgGrad = cutsceneCtx.createRadialGradient(450, 250, 0, 450, 250, 400);
            bgGrad.addColorStop(0, '#1a1510');
            bgGrad.addColorStop(1, '#0a0805');
            cutsceneCtx.fillStyle = bgGrad;
            cutsceneCtx.fillRect(0, 0, 900, 500);

            // Draw Maciej large portrait
            cutsceneCtx.save();
            cutsceneCtx.translate(450, 280);
            cutsceneCtx.scale(3, 3);

            // Body/shoulders
            cutsceneCtx.fillStyle = '#2d3d2d';
            cutsceneCtx.beginPath();
            cutsceneCtx.moveTo(-60, 30);
            cutsceneCtx.quadraticCurveTo(-50, 0, -30, -10);
            cutsceneCtx.lineTo(30, -10);
            cutsceneCtx.quadraticCurveTo(50, 0, 60, 30);
            cutsceneCtx.lineTo(60, 80);
            cutsceneCtx.lineTo(-60, 80);
            cutsceneCtx.closePath();
            cutsceneCtx.fill();

            // Neck
            cutsceneCtx.fillStyle = '#c9a882';
            cutsceneCtx.fillRect(-12, -15, 24, 20);

            // Head
            cutsceneCtx.fillStyle = '#c9a882';
            cutsceneCtx.beginPath();
            cutsceneCtx.ellipse(0, -40, 28, 35, 0, 0, Math.PI * 2);
            cutsceneCtx.fill();

            // Hair
            cutsceneCtx.fillStyle = '#2a2520';
            cutsceneCtx.beginPath();
            cutsceneCtx.ellipse(0, -65, 25, 15, 0, Math.PI, 0);
            cutsceneCtx.fill();
            cutsceneCtx.fillRect(-25, -70, 50, 10);

            // Forester hat
            cutsceneCtx.fillStyle = '#3d4d3d';
            cutsceneCtx.beginPath();
            cutsceneCtx.ellipse(0, -70, 35, 8, 0, 0, Math.PI * 2);
            cutsceneCtx.fill();
            cutsceneCtx.fillStyle = '#2d3d2d';
            cutsceneCtx.beginPath();
            cutsceneCtx.moveTo(-20, -70);
            cutsceneCtx.quadraticCurveTo(0, -95, 20, -70);
            cutsceneCtx.fill();
            cutsceneCtx.fillStyle = '#5a3d2a';
            cutsceneCtx.fillRect(-18, -72, 36, 5);

            // Face details
            // Eyes
            cutsceneCtx.fillStyle = '#1a1510';
            cutsceneCtx.fillRect(-15, -45, 10, 4);
            cutsceneCtx.fillRect(5, -45, 10, 4);
            // Eyebrows
            cutsceneCtx.fillStyle = '#2a2520';
            cutsceneCtx.fillRect(-17, -52, 14, 3);
            cutsceneCtx.fillRect(3, -52, 14, 3);
            // Nose
            cutsceneCtx.fillStyle = '#b89872';
            cutsceneCtx.beginPath();
            cutsceneCtx.moveTo(0, -40);
            cutsceneCtx.lineTo(4, -28);
            cutsceneCtx.lineTo(-4, -28);
            cutsceneCtx.closePath();
            cutsceneCtx.fill();
            // Mustache
            cutsceneCtx.fillStyle = '#2a2520';
            cutsceneCtx.beginPath();
            cutsceneCtx.ellipse(0, -22, 15, 5, 0, 0, Math.PI);
            cutsceneCtx.fill();
            // Mouth/jaw
            cutsceneCtx.strokeStyle = '#8a7862';
            cutsceneCtx.lineWidth = 1;
            cutsceneCtx.beginPath();
            cutsceneCtx.moveTo(-8, -15);
            cutsceneCtx.lineTo(8, -15);
            cutsceneCtx.stroke();

            // Scars
            cutsceneCtx.strokeStyle = '#9a8872';
            cutsceneCtx.lineWidth = 1.5;
            cutsceneCtx.beginPath();
            cutsceneCtx.moveTo(18, -50);
            cutsceneCtx.lineTo(22, -35);
            cutsceneCtx.stroke();

            cutsceneCtx.restore();

            // Text overlay at bottom
            cutsceneCtx.fillStyle = 'rgba(10, 8, 5, 0.8)';
            cutsceneCtx.fillRect(0, 420, 900, 80);
            cutsceneCtx.fillStyle = '#5a4a3a';
            cutsceneCtx.font = '14px Georgia';
            cutsceneCtx.textAlign = 'center';
            cutsceneCtx.fillText('MACIEJ "MACIUŚ" MARSHALL', 450, 455);
            cutsceneCtx.fillStyle = '#3a3025';
            cutsceneCtx.font = '11px Georgia';
            cutsceneCtx.fillText('Leśniczy Puszczy Karpackiej | Weteran | Samotnik', 450, 475);
        }

        function drawKarelusScene() {
            // Dark forest background
            cutsceneCtx.fillStyle = '#050808';
            cutsceneCtx.fillRect(0, 0, 900, 500);

            // Ominous trees
            for (let i = 0; i < 15; i++) {
                const x = 60 + i * 60;
                cutsceneCtx.fillStyle = '#0a1210';
                cutsceneCtx.fillRect(x - 8, 100, 16, 400);
                // Twisted branches
                for (let j = 0; j < 5; j++) {
                    cutsceneCtx.save();
                    cutsceneCtx.translate(x, 120 + j * 50);
                    cutsceneCtx.rotate((Math.random() - 0.5) * 0.5);
                    cutsceneCtx.fillRect(0, 0, 40 * (j % 2 ? 1 : -1), 4);
                    cutsceneCtx.restore();
                }
            }

            // Karelus - the orb
            const pulse = Math.sin(cutsceneAnimationFrame / 20) * 0.2 + 0.8;
            
            // Outer glow
            const outerGlow = cutsceneCtx.createRadialGradient(450, 280, 0, 450, 280, 200);
            outerGlow.addColorStop(0, `rgba(100, 20, 20, ${0.3 * pulse})`);
            outerGlow.addColorStop(0.5, `rgba(60, 10, 10, ${0.2 * pulse})`);
            outerGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
            cutsceneCtx.fillStyle = outerGlow;
            cutsceneCtx.fillRect(200, 80, 500, 400);

            // The orb itself
            const orbGrad = cutsceneCtx.createRadialGradient(420, 250, 0, 450, 280, 80);
            orbGrad.addColorStop(0, '#4a3030');
            orbGrad.addColorStop(0.3, '#2a1515');
            orbGrad.addColorStop(0.7, '#1a0a0a');
            orbGrad.addColorStop(1, '#0a0505');
            cutsceneCtx.fillStyle = orbGrad;
            cutsceneCtx.beginPath();
            cutsceneCtx.arc(450, 280, 80, 0, Math.PI * 2);
            cutsceneCtx.fill();

            // Surface details
            cutsceneCtx.strokeStyle = `rgba(80, 30, 30, ${pulse})`;
            cutsceneCtx.lineWidth = 1;
            for (let i = 0; i < 8; i++) {
                cutsceneCtx.beginPath();
                cutsceneCtx.arc(450, 280, 40 + i * 5, 
                    Math.sin(cutsceneAnimationFrame / 30 + i) * 0.5, 
                    Math.PI + Math.sin(cutsceneAnimationFrame / 30 + i) * 0.5);
                cutsceneCtx.stroke();
            }

            // Runes floating around
            cutsceneCtx.fillStyle = `rgba(139, 50, 50, ${pulse * 0.6})`;
            cutsceneCtx.font = '20px serif';
            const runes = ['ᚠ', 'ᚢ', 'ᚦ', 'ᚨ', 'ᚱ', 'ᚲ', 'ᚷ', 'ᚹ'];
            for (let i = 0; i < 8; i++) {
                const angle = (cutsceneAnimationFrame / 100) + (i / 8) * Math.PI * 2;
                const x = 450 + Math.cos(angle) * 130;
                const y = 280 + Math.sin(angle) * 130;
                cutsceneCtx.fillText(runes[i], x, y);
            }

            // Ground with roots
            cutsceneCtx.fillStyle = '#0a0f08';
            cutsceneCtx.fillRect(0, 380, 900, 120);
            
            // Roots reaching toward orb
            cutsceneCtx.strokeStyle = '#1a2515';
            cutsceneCtx.lineWidth = 8;
            for (let i = 0; i < 6; i++) {
                cutsceneCtx.beginPath();
                cutsceneCtx.moveTo(100 + i * 140, 500);
                cutsceneCtx.quadraticCurveTo(100 + i * 140, 350, 450, 360);
                cutsceneCtx.stroke();
            }
        }

        function drawDesecrationScene() {
            // Similar dark forest
            cutsceneCtx.fillStyle = '#080a08';
            cutsceneCtx.fillRect(0, 0, 900, 500);

            // Trees
            for (let i = 0; i < 12; i++) {
                drawDetailedTree(cutsceneCtx, 50 + i * 80, 350, 1.2, '#0a1510');
            }

            // Ground
            cutsceneCtx.fillStyle = '#0a0f08';
            cutsceneCtx.fillRect(0, 350, 900, 150);

            // Karelus smaller in background
            const orbGrad = cutsceneCtx.createRadialGradient(600, 280, 0, 600, 280, 50);
            orbGrad.addColorStop(0, '#3a2525');
            orbGrad.addColorStop(1, '#1a0a0a');
            cutsceneCtx.fillStyle = orbGrad;
            cutsceneCtx.beginPath();
            cutsceneCtx.arc(600, 280, 50, 0, Math.PI * 2);
            cutsceneCtx.fill();

            // Maciej figure
            cutsceneCtx.save();
            cutsceneCtx.translate(400, 380);

            // Body
            cutsceneCtx.fillStyle = '#2d3d2d';
            cutsceneCtx.fillRect(-15, -50, 30, 50);
            
            // Head
            cutsceneCtx.fillStyle = '#c9a882';
            cutsceneCtx.beginPath();
            cutsceneCtx.arc(0, -60, 12, 0, Math.PI * 2);
            cutsceneCtx.fill();
            
            // Hat
            cutsceneCtx.fillStyle = '#3d4d3d';
            cutsceneCtx.fillRect(-15, -75, 30, 8);

            // Arm raised in disrespectful gesture
            cutsceneCtx.strokeStyle = '#2d3d2d';
            cutsceneCtx.lineWidth = 8;
            cutsceneCtx.beginPath();
            cutsceneCtx.moveTo(10, -40);
            cutsceneCtx.lineTo(40, -60);
            cutsceneCtx.stroke();

            cutsceneCtx.restore();

            // "Stream" effect (keeping it subtle)
            cutsceneCtx.strokeStyle = 'rgba(180, 160, 50, 0.4)';
            cutsceneCtx.lineWidth = 3;
            cutsceneCtx.setLineDash([5, 5]);
            cutsceneCtx.beginPath();
            cutsceneCtx.moveTo(420, 350);
            cutsceneCtx.quadraticCurveTo(500, 320, 560, 300);
            cutsceneCtx.stroke();
            cutsceneCtx.setLineDash([]);

            // Shame text
            cutsceneCtx.fillStyle = 'rgba(139, 50, 50, 0.8)';
            cutsceneCtx.font = 'italic 16px Georgia';
            cutsceneCtx.textAlign = 'center';
            cutsceneCtx.fillText('"Trzeba zaznaczyć teren..."', 450, 450);
        }

        function drawAwakeningScene() {
            // Blood red sky
            const skyGrad = cutsceneCtx.createLinearGradient(0, 0, 0, 300);
            skyGrad.addColorStop(0, '#2a0a0a');
            skyGrad.addColorStop(1, '#0a0505');
            cutsceneCtx.fillStyle = skyGrad;
            cutsceneCtx.fillRect(0, 0, 900, 500);

            // Lightning effect
            if (cutsceneAnimationFrame % 60 < 5) {
                cutsceneCtx.fillStyle = 'rgba(139, 50, 50, 0.3)';
                cutsceneCtx.fillRect(0, 0, 900, 500);
            }

            // Karelus awakened - center, large, glowing
            const pulse = Math.sin(cutsceneAnimationFrame / 10) * 0.5 + 0.5;
            
            // Massive glow
            const glow = cutsceneCtx.createRadialGradient(450, 250, 0, 450, 250, 350);
            glow.addColorStop(0, `rgba(139, 30, 30, ${0.8 * pulse})`);
            glow.addColorStop(0.3, `rgba(100, 20, 20, ${0.5 * pulse})`);
            glow.addColorStop(0.6, `rgba(50, 10, 10, ${0.3 * pulse})`);
            glow.addColorStop(1, 'rgba(0, 0, 0, 0)');
            cutsceneCtx.fillStyle = glow;
            cutsceneCtx.fillRect(0, 0, 900, 500);

            // The orb - cracked and glowing
            const orbGrad = cutsceneCtx.createRadialGradient(400, 220, 0, 450, 250, 100);
            orbGrad.addColorStop(0, `rgb(${180 + pulse * 50}, 50, 50)`);
            orbGrad.addColorStop(0.5, '#5a2020');
            orbGrad.addColorStop(1, '#2a0a0a');
            cutsceneCtx.fillStyle = orbGrad;
            cutsceneCtx.beginPath();
            cutsceneCtx.arc(450, 250, 100, 0, Math.PI * 2);
            cutsceneCtx.fill();

            // Cracks with light
            cutsceneCtx.strokeStyle = `rgba(255, 100, 50, ${pulse})`;
            cutsceneCtx.lineWidth = 3;
            const cracks = [
                [[450, 250], [420, 180], [400, 160]],
                [[450, 250], [500, 200], [530, 170]],
                [[450, 250], [380, 250], [350, 230]],
                [[450, 250], [470, 300], [500, 340]],
                [[450, 250], [400, 310], [370, 350]]
            ];
            cracks.forEach(crack => {
                cutsceneCtx.beginPath();
                cutsceneCtx.moveTo(crack[0][0], crack[0][1]);
                crack.slice(1).forEach(p => cutsceneCtx.lineTo(p[0], p[1]));
                cutsceneCtx.stroke();
            });

            // "ZEMSTA" text emanating
            cutsceneCtx.fillStyle = `rgba(139, 0, 0, ${pulse})`;
            cutsceneCtx.font = 'bold 48px Georgia';
            cutsceneCtx.textAlign = 'center';
            cutsceneCtx.fillText('ZEMSTA', 450, 420);

            // Psychic waves
            cutsceneCtx.strokeStyle = `rgba(139, 50, 50, ${0.3 * (1 - (cutsceneAnimationFrame % 60) / 60)})`;
            cutsceneCtx.lineWidth = 2;
            const waveRadius = (cutsceneAnimationFrame % 60) * 8;
            cutsceneCtx.beginPath();
            cutsceneCtx.arc(450, 250, waveRadius, 0, Math.PI * 2);
            cutsceneCtx.stroke();
        }

        function drawSiegeScene() {
            // Dusk sky
            const skyGrad = cutsceneCtx.createLinearGradient(0, 0, 0, 250);
            skyGrad.addColorStop(0, '#1a1015');
            skyGrad.addColorStop(0.5, '#2a1520');
            skyGrad.addColorStop(1, '#1a1510');
            cutsceneCtx.fillStyle = skyGrad;
            cutsceneCtx.fillRect(0, 0, 900, 250);

            // Smoke/fire in distance
            for (let i = 0; i < 5; i++) {
                cutsceneCtx.fillStyle = `rgba(80, 30, 20, ${0.3 - i * 0.05})`;
                cutsceneCtx.beginPath();
                cutsceneCtx.arc(150 + i * 30 + Math.sin(cutsceneAnimationFrame / 20 + i) * 10, 
                    100 - i * 20, 30 + i * 10, 0, Math.PI * 2);
                cutsceneCtx.fill();
            }

            // Forest ground
            cutsceneCtx.fillStyle = '#0f1510';
            cutsceneCtx.fillRect(0, 250, 900, 250);

            // Cabin in center, besieged
            drawDetailedCabin(cutsceneCtx, 380, 280, 1.2);

            // Horde of boar silhouettes approaching
            for (let row = 0; row < 4; row++) {
                for (let i = 0; i < 12; i++) {
                    const x = 50 + i * 75 + (row % 2) * 30;
                    const y = 380 + row * 30;
                    const scale = 0.4 + row * 0.1;
                    
                    // Boar silhouette
                    cutsceneCtx.fillStyle = `rgba(20, 15, 10, ${0.9 - row * 0.15})`;
                    cutsceneCtx.beginPath();
                    cutsceneCtx.ellipse(x, y, 20 * scale, 12 * scale, 0, 0, Math.PI * 2);
                    cutsceneCtx.fill();
                    
                    // Head
                    cutsceneCtx.beginPath();
                    cutsceneCtx.ellipse(x + 15 * scale, y, 10 * scale, 8 * scale, 0, 0, Math.PI * 2);
                    cutsceneCtx.fill();

                    // Red eyes
                    cutsceneCtx.fillStyle = `rgba(139, 0, 0, ${0.8 - row * 0.15})`;
                    cutsceneCtx.beginPath();
                    cutsceneCtx.arc(x + 20 * scale, y - 2 * scale, 2 * scale, 0, Math.PI * 2);
                    cutsceneCtx.arc(x + 20 * scale, y + 2 * scale, 2 * scale, 0, Math.PI * 2);
                    cutsceneCtx.fill();
                }
            }

            // Maciej silhouette on cabin porch
            cutsceneCtx.fillStyle = '#0a0a05';
            cutsceneCtx.fillRect(440, 310, 20, 45);
            cutsceneCtx.beginPath();
            cutsceneCtx.arc(450, 300, 10, 0, Math.PI * 2);
            cutsceneCtx.fill();
        }

        function drawWeaponsScene() {
            // Dark room interior
            const bgGrad = cutsceneCtx.createRadialGradient(450, 250, 0, 450, 250, 500);
            bgGrad.addColorStop(0, '#1a1510');
            bgGrad.addColorStop(1, '#0a0805');
            cutsceneCtx.fillStyle = bgGrad;
            cutsceneCtx.fillRect(0, 0, 900, 500);

            // Wooden wall planks
            cutsceneCtx.strokeStyle = '#2a2015';
            cutsceneCtx.lineWidth = 1;
            for (let i = 0; i < 20; i++) {
                cutsceneCtx.beginPath();
                cutsceneCtx.moveTo(0, i * 30);
                cutsceneCtx.lineTo(900, i * 30);
                cutsceneCtx.stroke();
            }

            // Oil lamp light
            const lampGlow = cutsceneCtx.createRadialGradient(450, 100, 0, 450, 100, 200);
            lampGlow.addColorStop(0, 'rgba(180, 140, 80, 0.3)');
            lampGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
            cutsceneCtx.fillStyle = lampGlow;
            cutsceneCtx.fillRect(250, 0, 400, 300);

            // REVOLVER
            cutsceneCtx.save();
            cutsceneCtx.translate(200, 200);
            drawRevolver(cutsceneCtx, 3);
            cutsceneCtx.restore();

            cutsceneCtx.fillStyle = '#8a7a6a';
            cutsceneCtx.font = '14px Georgia';
            cutsceneCtx.textAlign = 'center';
            cutsceneCtx.fillText('REWOLWER', 200, 280);
            cutsceneCtx.fillStyle = '#5a4a3a';
            cutsceneCtx.font = '11px Georgia';
            cutsceneCtx.fillText('Nieograniczona amunicja', 200, 300);

            // SNIPER
            cutsceneCtx.save();
            cutsceneCtx.translate(500, 200);
            drawSniper(cutsceneCtx, 2.5);
            cutsceneCtx.restore();

            cutsceneCtx.fillStyle = '#8a7a6a';
            cutsceneCtx.font = '14px Georgia';
            cutsceneCtx.fillText('SNAJPERKA', 500, 280);
            cutsceneCtx.fillStyle = '#5a4a3a';
            cutsceneCtx.font = '11px Georgia';
            cutsceneCtx.fillText('Przeszywa wrogów', 500, 300);

            // VAPE / Inhaler
            cutsceneCtx.save();
            cutsceneCtx.translate(750, 200);
            
            // Mysterious inhaler device
            cutsceneCtx.fillStyle = '#3a3a4a';
            cutsceneCtx.fillRect(-15, -30, 30, 60);
            cutsceneCtx.fillStyle = '#4a3a5a';
            cutsceneCtx.fillRect(-12, -35, 24, 10);
            
            // Glowing element
            const vapeGlow = cutsceneCtx.createRadialGradient(0, 0, 0, 0, 0, 30);
            vapeGlow.addColorStop(0, 'rgba(100, 50, 120, 0.8)');
            vapeGlow.addColorStop(1, 'rgba(50, 20, 60, 0)');
            cutsceneCtx.fillStyle = vapeGlow;
            cutsceneCtx.fillRect(-30, -30, 60, 60);

            cutsceneCtx.restore();

            cutsceneCtx.fillStyle = '#8a7a6a';
            cutsceneCtx.font = '14px Georgia';
            cutsceneCtx.fillText('MGŁA BOJOWA', 750, 280);
            cutsceneCtx.fillStyle = '#5a4a3a';
            cutsceneCtx.font = '11px Georgia';
            cutsceneCtx.fillText('Nadludzka siła', 750, 300);

            // Bottom text
            cutsceneCtx.fillStyle = '#5a4a3a';
            cutsceneCtx.font = 'italic 16px Georgia';
            cutsceneCtx.fillText('Tej nocy zdecyduje się wszystko...', 450, 420);
        }

        function drawDetailedTree(ctx, x, y, scale, color) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(scale, scale);

            // Trunk
            ctx.fillStyle = color || '#1a1510';
            ctx.fillRect(-8, -20, 16, 80);

            // Branches
            ctx.fillStyle = color || '#1a1510';
            for (let i = 0; i < 4; i++) {
                ctx.save();
                ctx.translate(0, -10 - i * 15);
                ctx.rotate((i % 2 ? 1 : -1) * 0.4);
                ctx.fillRect(0, 0, 30 - i * 5, 4);
                ctx.restore();
            }

            // Foliage layers
            const foliageColor = color || '#152010';
            ctx.fillStyle = foliageColor;
            ctx.beginPath();
            ctx.moveTo(0, -80);
            ctx.lineTo(-35, -20);
            ctx.lineTo(35, -20);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(0, -60);
            ctx.lineTo(-30, -10);
            ctx.lineTo(30, -10);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(0, -40);
            ctx.lineTo(-25, 0);
            ctx.lineTo(25, 0);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        function drawDetailedCabin(ctx, x, y, scale) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(scale, scale);

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.beginPath();
            ctx.ellipse(50, 85, 70, 15, 0, 0, Math.PI * 2);
            ctx.fill();

            // Main body - yellow/golden wood
            ctx.fillStyle = '#c9a227';
            ctx.fillRect(0, 20, 100, 60);

            // Wood grain
            ctx.strokeStyle = '#a08020';
            ctx.lineWidth = 1;
            for (let i = 0; i < 6; i++) {
                ctx.beginPath();
                ctx.moveTo(0, 25 + i * 10);
                ctx.lineTo(100, 25 + i * 10);
                ctx.stroke();
            }

            // Darker trim
            ctx.fillStyle = '#8a6914';
            ctx.fillRect(0, 20, 100, 5);
            ctx.fillRect(0, 75, 100, 5);
            ctx.fillRect(0, 20, 5, 60);
            ctx.fillRect(95, 20, 5, 60);

            // Roof
            ctx.fillStyle = '#4a3020';
            ctx.beginPath();
            ctx.moveTo(-10, 25);
            ctx.lineTo(50, -15);
            ctx.lineTo(110, 25);
            ctx.closePath();
            ctx.fill();

            // Roof shingles
            ctx.strokeStyle = '#3a2015';
            ctx.lineWidth = 2;
            for (let i = 0; i < 4; i++) {
                const yOffset = 25 - i * 10;
                ctx.beginPath();
                ctx.moveTo(-5 + i * 5, yOffset);
                ctx.lineTo(105 - i * 5, yOffset);
                ctx.stroke();
            }

            // Door
            ctx.fillStyle = '#3a2515';
            ctx.fillRect(40, 40, 25, 40);
            ctx.fillStyle = '#2a1a10';
            ctx.fillRect(42, 42, 21, 36);
            // Door handle
            ctx.fillStyle = '#c9a227';
            ctx.beginPath();
            ctx.arc(58, 60, 3, 0, Math.PI * 2);
            ctx.fill();

            // Windows
            ctx.fillStyle = '#1a3040';
            ctx.fillRect(10, 35, 20, 20);
            ctx.fillRect(75, 35, 20, 20);
            // Window frames
            ctx.strokeStyle = '#5a4030';
            ctx.lineWidth = 2;
            ctx.strokeRect(10, 35, 20, 20);
            ctx.strokeRect(75, 35, 20, 20);
            // Window cross
            ctx.beginPath();
            ctx.moveTo(20, 35);
            ctx.lineTo(20, 55);
            ctx.moveTo(10, 45);
            ctx.lineTo(30, 45);
            ctx.moveTo(85, 35);
            ctx.lineTo(85, 55);
            ctx.moveTo(75, 45);
            ctx.lineTo(95, 45);
            ctx.stroke();

            // Warm light from windows
            ctx.fillStyle = 'rgba(180, 140, 60, 0.4)';
            ctx.fillRect(12, 37, 16, 16);
            ctx.fillRect(77, 37, 16, 16);

            // Chimney
            ctx.fillStyle = '#5a3020';
            ctx.fillRect(75, -10, 15, 25);
            // Smoke
            ctx.fillStyle = 'rgba(100, 90, 80, 0.3)';
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(82 + Math.sin(cutsceneAnimationFrame / 30 + i) * 5, -20 - i * 15, 8 + i * 3, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        function drawRevolver(ctx, scale) {
            ctx.save();
            ctx.scale(scale, scale);

            // Barrel
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0, -3, 35, 6);

            // Cylinder
            ctx.fillStyle = '#3a3a3a';
            ctx.beginPath();
            ctx.arc(-5, 0, 10, 0, Math.PI * 2);
            ctx.fill();
            // Cylinder details
            ctx.fillStyle = '#2a2a2a';
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                ctx.beginPath();
                ctx.arc(-5 + Math.cos(angle) * 6, Math.sin(angle) * 6, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Frame
            ctx.fillStyle = '#3a3a3a';
            ctx.fillRect(-15, -5, 20, 10);

            // Grip
            ctx.fillStyle = '#4a3020';
            ctx.beginPath();
            ctx.moveTo(-15, 5);
            ctx.lineTo(-20, 25);
            ctx.lineTo(-8, 25);
            ctx.lineTo(-5, 5);
            ctx.closePath();
            ctx.fill();

            // Grip texture
            ctx.strokeStyle = '#3a2515';
            ctx.lineWidth = 1;
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.moveTo(-18 + i * 3, 8);
                ctx.lineTo(-16 + i * 3, 22);
                ctx.stroke();
            }

            // Hammer
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(-12, -10, 6, 6);

            // Trigger
            ctx.fillStyle = '#2a2a2a';
            ctx.beginPath();
            ctx.moveTo(-8, 5);
            ctx.lineTo(-10, 15);
            ctx.lineTo(-6, 15);
            ctx.lineTo(-4, 5);
            ctx.closePath();
            ctx.fill();

            // Trigger guard
            ctx.strokeStyle = '#3a3a3a';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(-7, 12, 8, 0.5, Math.PI - 0.5);
            ctx.stroke();

            ctx.restore();
        }

        function drawSniper(ctx, scale) {
            ctx.save();
            ctx.scale(scale, scale);

            // Long barrel
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(-10, -2, 80, 4);

            // Barrel tip
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(65, -4, 15, 8);

            // Body
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(-20, -6, 40, 12);

            // Scope mount
            ctx.fillStyle = '#3a3a3a';
            ctx.fillRect(-5, -12, 25, 6);

            // Scope
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.ellipse(7, -15, 15, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            // Scope lens
            ctx.fillStyle = '#2a4050';
            ctx.beginPath();
            ctx.ellipse(-5, -15, 4, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(19, -15, 3, 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Stock
            ctx.fillStyle = '#3a2515';
            ctx.beginPath();
            ctx.moveTo(-20, -6);
            ctx.lineTo(-50, -4);
            ctx.lineTo(-50, 4);
            ctx.lineTo(-20, 6);
            ctx.closePath();
            ctx.fill();

            // Grip
            ctx.fillStyle = '#3a2515';
            ctx.beginPath();
            ctx.moveTo(-10, 6);
            ctx.lineTo(-15, 22);
            ctx.lineTo(-5, 22);
            ctx.lineTo(0, 6);
            ctx.closePath();
            ctx.fill();

            // Magazine
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(5, 6, 15, 12);

            // Bipod hints
            ctx.strokeStyle = '#2a2a2a';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(40, 2);
            ctx.lineTo(35, 15);
            ctx.moveTo(50, 2);
            ctx.lineTo(55, 15);
            ctx.stroke();

            ctx.restore();
        }

        function updateCutscene() {
            if (currentCutscene < cutscenes.length) {
                cutsceneTitleEl.textContent = cutscenes[currentCutscene].title;
                cutsceneTextEl.textContent = cutscenes[currentCutscene].text;
                drawCutscene(cutscenes[currentCutscene].scene);
            }
        }

        let cutsceneLoop = setInterval(() => {
            if (currentCutscene < cutscenes.length) {
                drawCutscene(cutscenes[currentCutscene].scene);
            }
        }, 1000/60);

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && cutsceneContainer.style.display !== 'none') {
                e.preventDefault();
                currentCutscene++;
                if (currentCutscene >= cutscenes.length) {
                    clearInterval(cutsceneLoop);
                    startGame();
                } else {
                    updateCutscene();
                }
            }
        });

        updateCutscene();

        // ==================== MAIN GAME ====================
        const gameCanvas = document.getElementById('gameCanvas');
        const ctx = gameCanvas.getContext('2d');

        gameCanvas.width = window.innerWidth;
        gameCanvas.height = window.innerHeight;

        let lastTime = performance.now();
        let accumulator = 0;
        const step = 1000 / 60; 

        

        let gameRunning = false;
        let gameOver = false;

        // Player state
        const player = {
            x: 0,
            y: 0,
            width: 40,
            height: 60,
            speed: 5,
            health: 100,
            maxHealth: 100,
            angle: 0,
            weapon: 'revolver',
            sniperAmmo: 0,
            vapeCharge: 100,
            vapeActive: false,
            vapeDuration: 0,
            shootCooldown: 0,
            invincible: 0,
            walkFrame: 0,
            facingRight: true,
			medkits: 0,
            scrap: 0,
			isRepairing: false,
            repairTimer: 0,
            armorTier: 0, // 0=Brak, 1=Kamizelka, 2=Maska
            revolverTier: 0, // 0=Zwykły, 1=Podwójna lufa, 2=Quad Shot
            sniperTier: 0, // 0, 1, 2
            recoilOffset: 0 // NOWE
        };

        let gunStation = {
            x: 0, y: 0, // Ustawimy w startGame
            costs: [30, 50] // Ceny Tier 1 i Tier 2
        };

        let armorStation = {
            x: 0, y: 0, // Ustawimy w startGame
            width: 60, height: 40,
            costs: [30, 50] // Koszt Tier 1, Koszt Tier 2
        };

        let sniperStation = {
            x: 0, y: 0,
            costs: [50, 70] // Drogie ulepszenia
        };

        let foxStation = {
            x: 0, y: 0,
            tier: 0, // 0=Kupka ziemi, 1=1 lis, 2=2 lisy, 3=3 lisy
            costs: [5, 20, 40], // Koszty ulepszeń
            foxes: [] // Obiekty lisów: { angle: 0 }
        };

                // WIEŻYCZKA MACIUSIA
        let turret = {
            x: 0, y: 0,
            tier: 0,
            angle: 0,
            cooldown: 0,
            target: null,
            costs: [10, 40, 70],
            barrelToggle: 1, // <--- DODAJ TO (1 lub -1)
            recoil: 0
        };
		
		let medkitPickups = [];
        let scrapPickups = [];

        // House state
        const house = {
            x: 0,
            y: 0,
            width: 180,
            height: 140,
            health: 100,
            maxHealth: 100
        };

        let bullets = [];
        let shells = []; // Tablica na łuski
        let boars = [];
        let corpses = []; // Tablica na szkielety
        let meatChunks = []; // Kawałki mięsa
        let particles = [];
        let bloodSplatters = [];
        let vapeParticles = [];
        let trees = [];
        let ammoPickups = [];
        let fortifications = []; // Zbudowane kolce
        let fortSlots = [];      // Miejsca, gdzie można budować
        let shockwaves = [];
        let kills = 0;
        let wave = 1;
        let boarsToSpawn = 5;
        let spawnTimer = 0;
        let waveDelay = 0;
        let gameTime = 0;
        let pablobitos = null; // Jeśli null -> nie ma go na mapie
        let bossEncountered = false;
        let bossIntroTimer = 0; // Licznik klatek animacji wejścia
        const bossIntroDuration = 800;

        let isPaused = false;
                // KAMERA
        let camera = { x: 0, y: 0, zoom: 1.0 }; // Domyślna
                let bossProjectiles = []; // Pociski bossa
        let acidPools = [];       // Plamy kwasu po wybuchu
       
        let lastPlayerHealth = 100;
        let lastHouseHealth = 100;
        let lastVapeCharge = 0;
        

        let hawk = {
            x: 0, y: 0,
            state: 'idle', // 'idle', 'searching', 'fetching', 'delivering'
            target: null, // Obiekt dropu
            targetType: '', // 'scrap', 'ammo', 'medkit'
            inventory: { medkits: 0, scrap: 0, ammo: 0 },
            speed: 7, // Szybki lot
            animFrame: 0,
            cost: 5,
            purchased: false // Czy gracz go wykupił
        };

        let hawkNest = { x: 0, y: 0 }; // Pozycja gniazda

        const keys = {};
        let mouseX = 0, mouseY = 0;
        let mouseDown = false;

        function startGame() {
            cutsceneContainer.style.display = 'none';
            document.getElementById('gameUI').style.display = 'block';
            
            // Centrowanie domu
            house.x = gameCanvas.width / 2 - house.width / 2;
            house.y = gameCanvas.height / 2 - house.height / 2;
            
            // Gracz obok domu
            player.x = house.x + house.width / 2;
            player.y = house.y + house.height + 50;
            
            generateEnvironment();
            showWaveAnnouncement();
            gameRunning = true;
            
            const houseCX = house.x + house.width/2;
            const houseCY = house.y + house.height/2;

            // 1. KOLCE (8 sztuk wokół - tak jak było)
            const spikePos = [
                {x: -120, y: -80}, {x: 0, y: -100}, {x: 120, y: -80},
                {x: -140, y: 0},   {x: 140, y: 0},
                {x: -120, y: 80},  {x: 0, y: 100},  {x: 120, y: 80}
            ];
            spikePos.forEach(pos => {
                fortSlots.push({
                    x: houseCX + pos.x,
                    y: houseCY + pos.y,
                    type: 'spikes', // Nowa właściwość
                    cost: 5,
                    built: false
                });
            });

            // 2. DRUT KOLCZASTY (4 sztuki - N, S, E, W)
                      fortSlots.push({x: houseCX, y: houseCY - 300, type: 'wire', cost: 15, isVertical: false, built: false});
            fortSlots.push({x: houseCX, y: houseCY + 300, type: 'wire', cost: 15, isVertical: false, built: false});
            fortSlots.push({x: houseCX - 330, y: houseCY, type: 'wire', cost: 15, isVertical: true, built: false});
            fortSlots.push({x: houseCX + 330, y: houseCY, type: 'wire', cost: 15, isVertical: true, built: false});

                        // Reset Wieżyczki (Pod domem)
            turret.tier = 0;
            turret.cooldown = 0;
            turret.x = house.x + house.width / 2 + 80;
            turret.y = house.y + house.height + 110; // 110px pod domem

                        // Ustawienie stolika z pancerzem (na prawo od domu)
            armorStation.x = house.x + house.width - 220;
            armorStation.y = house.y + 220;
            player.armorTier = 0; // Reset przy nowej grze

                        // Stół z bronią (na lewo od domu)
            gunStation.x = house.x + house.width - 280;
            gunStation.y = house.y + 300;
            player.revolverTier = 0;

                        // Stół snajperski (na dole po lewej)
            sniperStation.x = house.x - house.width + 50;
            sniperStation.y = house.y + house.height + 20;
            player.sniperTier = 0;

                        // Ustawienie gniazda na dachu
            hawkNest.x = house.x + house.width + 110;
            hawkNest.y = house.y + 150;

                        // Nora Lisa (Prawy górny róg)
            foxStation.x = house.x + house.width + 70;
            foxStation.y = house.y - 60;
            foxStation.tier = 0;
            foxStation.foxes = [];
            
            // Reset jastrzębia
            hawk.x = hawkNest.x;
            hawk.y = hawkNest.y;
            hawk.state = 'idle';
            hawk.target = null;
            hawk.inventory = { medkits: 0, scrap: 0, ammo: 0 };
            hawk.purchased = false; // Trzeba kupić od nowa po restarcie

                        // --- POPRAWKA FREEZA TUTAJ ---
            lastTime = performance.now();
            accumulator = 0;
            requestAnimationFrame(gameLoop);
        }

        function generateEnvironment() {
            trees = [];
            let attempts = 0;
            
            // Środek bazy
            const centerX = house.x + house.width / 2;
            const centerY = house.y + house.height / 2;
            
            // Promień bezpiecznej strefy (polana)
            // 550px powinno wystarczyć, żeby odsłonić stoły i większość fortyfikacji
            const safeZoneRadius = 450; 

            while (trees.length < 150 && attempts < 2000) {
                attempts++;
                
                const x = Math.random() * gameCanvas.width;
                const y = Math.random() * gameCanvas.height;

                // Sprawdzamy tylko dystans od środka
                // Jeśli drzewo jest DALEJ niż promień -> sadzimy je
                if (Math.hypot(x - centerX, y - centerY) > safeZoneRadius) {
                    trees.push({
                        x: x,
                        y: y,
                        size: 0.8 + Math.random() * 0.6,
                        type: Math.random() < 0.7 ? 'pine' : 'oak',
                        sway: Math.random() * Math.PI * 2
                    });
                }
            }
            
            // Sortowanie (żeby drzewa niżej zasłaniały te wyżej)
            trees.sort((a, b) => a.y - b.y);
        }

        function showWaveAnnouncement() {
            const announcement = document.getElementById('waveAnnouncement');
            const romanNumerals = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 
                                   'XI', 'XII', 'XIII', 'XIV', 'XV', 'XVI', 'XVII', 'XVIII', 'XIX', 'XX'];
            announcement.textContent = `FALA ${romanNumerals[Math.min(wave - 1, 19)]}`;
            announcement.style.opacity = '1';
            setTimeout(() => announcement.style.opacity = '0', 2500);
        }

        function showPickupNotification(text) {
            const notification = document.getElementById('pickupNotification');
            notification.textContent = text;
            notification.style.opacity = '1';
            setTimeout(() => notification.style.opacity = '0', 1500);
        }

        // Input handling
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;

                        // PAUZA
            if (e.key.toLowerCase() === 'p' || e.key === 'Escape') {
                togglePause();
            }
            
            if (gameRunning && !gameOver) {
                if (e.key.toLowerCase() === 'q') {
                    player.weapon = player.weapon === 'revolver' ? 'sniper' : 'revolver';
                }
                if (e.key.toLowerCase() === 'e') {
                    activateVape();
                }
				if (e.key.toLowerCase() === 'f') {
                    useMedkit();
                }
				if (e.code === 'Space' && waveDelay > 0) {
                    waveDelay = 1; // Ustawiamy na 1, żeby w następnej klatce się odpaliło
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        gameCanvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        gameCanvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            mouseDown = true;
        });
        gameCanvas.addEventListener('mouseup', () => mouseDown = false);
        gameCanvas.addEventListener('contextmenu', (e) => e.preventDefault());

        function activateVape() {
            if (player.vapeCharge >= 100 && !player.vapeActive) {
                player.vapeActive = true;
                player.vapeDuration = 360;
                player.vapeCharge = 0;

                // Massive vape cloud explosion
                for (let i = 0; i < 80; i++) {
                    const angle = (i / 80) * Math.PI * 2;
                    const speed = 3 + Math.random() * 8;
                    vapeParticles.push({
                        x: player.x,
                        y: player.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 80 + Math.random() * 40,
                        maxLife: 120,
                        size: 30 + Math.random() * 40,
                        hue: 260 + Math.random() * 40
                    });
                }

                // Damage and stun nearby boars
                boars.forEach(boar => {
                    const dist = Math.hypot(boar.x - player.x, boar.y - player.y);
                    if (dist < 400) {
                        boar.health -= 50;
                        boar.stunned = 300;
                        createBloodEffect(boar.x, boar.y, 8);
                    }
                });
            }
        }
		
	    function useMedkit() {
            if (player.medkits > 0 && player.health < player.maxHealth) {
                player.medkits--;
                player.health = Math.min(player.maxHealth, player.health + 40); // Leczy 40 HP
                showPickupNotification("Użyto apteczki (+40 HP)");
                
                // Efekt leczenia (zielone krzyżyki/cząsteczki)
                for (let i = 0; i < 20; i++) {
                    particles.push({
                        x: player.x, y: player.y,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4 - 2,
                        life: 40, maxLife: 40,
                        size: 4, color: '#33ff33', gravity: -0.1
                    });
                }
            } else if (player.medkits === 0) {
                // Dźwięk błędu (opcjonalnie) lub info
            }
        }

                    function shoot() {
            if (player.shootCooldown > 0 || player.isRepairing) return;
            if (player.weapon === 'sniper') {
                if (player.sniperAmmo <= 0) return;
                player.sniperAmmo--;
            }

            const stats = player.weapon === 'revolver' ? {spread:0.08, speed:18, damage:20, cd:18, pierce:false} : {spread:0.01, speed:35, damage:120, cd:50, pierce:true};
            
            let currentDmg = stats.damage;
            let sniperCurrentTier = 0;
            if (player.weapon === 'sniper') {
                sniperCurrentTier = player.sniperTier;
                if (player.sniperTier === 1) currentDmg *= 1.5;
                if (player.sniperTier === 2) currentDmg *= 2.0;
            }
            const finalDamage = player.vapeActive ? currentDmg * 1.8 : currentDmg;

            let barrelLen = 60;
            if (player.weapon === 'revolver') {
                if (player.revolverTier === 1) barrelLen = 65;
                if (player.revolverTier === 2) barrelLen = 75;
            } else {
                barrelLen = 90;
            }

            const shotAngle = player.angle + (Math.random() - 0.5) * stats.spread;

            const spawnBullet = (offsetAngle, delay = 0) => {
                setTimeout(() => {
                    const c = Math.cos(shotAngle);
                    const s = Math.sin(shotAngle);
                    
                    const bx = player.x + (c * barrelLen) - (s * offsetAngle);
                    const by = player.y - 15 + (s * barrelLen) + (c * offsetAngle);

                    bullets.push({
                        x: bx, y: by,
                        vx: c * stats.speed, vy: s * stats.speed,
                        rotation: shotAngle,
                        damage: finalDamage, weapon: player.weapon, piercing: stats.pierce,
                        tier: sniperCurrentTier, hitBoars: [], trail: [], life: 100
                    });
                    
                    for(let i=0; i<5; i++) {
                        particles.push({x: bx, y: by, vx: c*8 + (Math.random()-0.5)*2, vy: s*8 + (Math.random()-0.5)*2, life: 8, maxLife: 8, size: 4 + Math.random()*3, color: player.weapon==='sniper' ? '#ffaa00' : '#ffffaa'});
                    }

                    // --- ŁUSKA ---
                    // Wylatuje bliżej ciała (20px od środka), leci w prawo-tył (ok. 90-120 stopni od strzału)
                    const shellAngle = shotAngle + Math.PI / 1.8 + (Math.random() - 0.5) * 0.5;
                    const shellSpeed = 3 + Math.random() * 2;
                    
                    shells.push({
                        x: player.x + c * 20, // Pozycja zamka
                        y: player.y - 15 + s * 20,
                        vx: Math.cos(shellAngle) * shellSpeed,
                        vy: Math.sin(shellAngle) * shellSpeed,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.5, // Łuska wiruje
                        life: 180, // Leży 5 sekund (60 * 5)
                        type: player.weapon // Żeby wiedzieć czy rysować małą czy dużą
                    });

                }, delay);
            };

            if (player.weapon === 'revolver' && player.revolverTier >= 1) {
                spawnBullet(-3); spawnBullet(3);  
                if (player.revolverTier === 2) { spawnBullet(-3, 50); spawnBullet(3, 50); }
            } else {
                spawnBullet(0);
            }

            player.shootCooldown = stats.cd;
            player.recoilOffset = 8;
        }

        function spawnBoar() {
            const side = Math.floor(Math.random() * 4);
            let x, y;

            switch(side) {
                case 0: x = Math.random() * gameCanvas.width; y = -60; break;
                case 1: x = gameCanvas.width + 60; y = Math.random() * gameCanvas.height; break;
                case 2: x = Math.random() * gameCanvas.width; y = gameCanvas.height + 60; break;
                case 3: x = -60; y = Math.random() * gameCanvas.height; break;
            }

            const isBoss = wave >= 3 && Math.random() < 0.08;
            const isCharger = !isBoss && Math.random() < 0.15;

            boars.push({
                x, y,
                width: isBoss ? 90 : (isCharger ? 45 : 55),
                height: isBoss ? 70 : (isCharger ? 35 : 45),
                speed: isBoss ? 1.2 : (isCharger ? 4 : 1.8 + wave * 0.15),
                health: isBoss ? 300 : (isCharger ? 30 : 60 + wave * 8),
                maxHealth: isBoss ? 300 : (isCharger ? 30 : 60 + wave * 8),
                damage: isBoss ? 25 : (isCharger ? 15 : 12),
                isBoss,
                isCharger,
                target: Math.random() < 0.4 ? 'player' : 'house',
                stunned: 0,
                attackCooldown: 0,
                angle: 0,
                walkFrame: Math.random() * Math.PI * 2
            });
        }

                function createBloodEffect(x, y, amount) {
            // 1. Krew (Particles)
            for(let i=0; i<amount; i++) {
                particles.push({
                    x, y, 
                    vx:(Math.random()-0.5)*10, vy:(Math.random()-0.5)*10, 
                    life:25+Math.random()*20, maxLife:45, 
                    size:3, color:'#8b0000', gravity:0.2
                });
            }
            
            // 2. Plama krwi na ziemi (Splatters)
            bloodSplatters.push({
                x: x+(Math.random()-0.5)*20, y: y+(Math.random()-0.5)*20, 
                size: 15+Math.random()*25, opacity: 0.6+Math.random()*0.3
            });
            if(bloodSplatters.length > 150) bloodSplatters.shift();

            // 3. KAWAŁKI MIĘSA (NOWE - Gore)
            // Tylko przy dużej ilości krwi (śmierć)
            if (amount > 20) {
                for(let i=0; i<4; i++) {
                    meatChunks.push({
                        x, y,
                        vx: (Math.random()-0.5)*8, 
                        vy: (Math.random()-0.5)*8,
                        rot: Math.random() * Math.PI * 2,
                        rotSpeed: (Math.random()-0.5) * 0.5,
                        size: 4 + Math.random() * 4,
                        life: 600 // 10 sekund leżenia
                    });
                }
            }
        }

        function update() {
            if (gameOver) return;
                         // ============================================================
            // 5. LOGIKA FORTYFIKACJI (Kolizje, Obrażenia, Spowolnienie)
            // ============================================================
            for (let i = fortifications.length - 1; i >= 0; i--) {
                const fort = fortifications[i];
                
                // Pętla po dzikach (od tyłu dla bezpiecznego usuwania)
                for (let j = boars.length - 1; j >= 0; j--) {
                    const boar = boars[j];
                    let isHit = false;

                    // A. DETEKCJA KOLIZJI
                    if (fort.type === 'wire') {
                        // Drut = Prostokąt
                        const w = fort.isVertical ? 40 : 240; 
                        const h = fort.isVertical ? 240 : 40;
                        if (boar.x > fort.x - w/2 && boar.x < fort.x + w/2 &&
                            boar.y > fort.y - h/2 && boar.y < fort.y + h/2) {
                            isHit = true;
                        }
                    } else {
                        // Kolce = Koło
                        if (Math.hypot(boar.x - fort.x, boar.y - fort.y) < fort.radius + boar.width/3) {
                            isHit = true;
                        }
                    }

                    // B. EFEKT TRAFIENIA
                    if (isHit) {
                        boar.health -= fort.damage;
                        fort.health -= 0.2; // Zużycie fortyfikacji

                        // Ustawiamy flagę spowolnienia (AI dzika to odczyta)
                        // 'wire' ma wyższy priorytet (mocniejsze spowolnienie)
                        if (fort.type === 'wire') {
                            boar.slowedBy = 'wire'; 
                        } else if (boar.slowedBy !== 'wire') {
                            boar.slowedBy = 'spikes';
                        }

                        // Efekt krwi (rzadziej niż przy strzale)
                        if (Math.random() < 0.2) {
                            particles.push({x:boar.x, y:boar.y, vx:(Math.random()-0.5)*3, vy:(Math.random()-0.5)*3, life:15, maxLife:15, size:2, color:'#8b0000'});
                        }

                        // --- ŚMIERĆ DZIKA NA KOLCACH ---
                        if (boar.health <= 0) {
                            handleBoarDeath(boar, j);
                        }
                    }
                }

                // Usunięcie zniszczonej fortyfikacji
                if (fort.health <= 0) {
                    fortSlots[fort.slotIndex].built = false;
                    for(let k=0; k<15; k++) particles.push({x:fort.x, y:fort.y, vx:(Math.random()-0.5)*6, vy:(Math.random()-0.5)*6, life:40, maxLife:40, size:3, color:'#5c4033'});
                    fortifications.splice(i, 1);
                }
            }
                    
			// DEFINICJA GRANIC DOMU (WSPÓLNA DLA WSZYSTKICH)
            // Ustawiamy marginesy tak, żeby pasowały do grafiki 2.5D
            // Top + 60 sprawia, że nie da się wejść na dach od tyłu
            const wallL = house.x + 5;  
            const wallR = house.x + house.width - 5;
            const wallT = house.y + 60; 
            const wallB = house.y + house.height - 5;
            gameTime++;
            if (player.recoilOffset > 0) {
                player.recoilOffset -= 1; // Szybkość powrotu
            }
                        // Player movement (Z KOLIZJĄ DOMU)
            let dx = 0, dy = 0;
            
            // BLOKADA PODCZAS INTRO
            const isBossIntro = (pablobitos && pablobitos.isIntro);
            
            if (!isBossIntro) {
                if (keys['w'] || keys['arrowup']) dy -= 1;
                if (keys['s'] || keys['arrowdown']) dy += 1;
                if (keys['a'] || keys['arrowleft']) dx -= 1;
                if (keys['d'] || keys['arrowright']) dx += 1;
            }

            if (dx !== 0 || dy !== 0) {
                const len = Math.hypot(dx, dy);
                const speed = player.vapeActive ? player.speed * 1.6 : player.speed;
                
                // Obliczamy prędkość na ten moment
                const vx = (dx / len) * speed;
                const vy = (dy / len) * speed;

                // RUCH X
                player.x += vx;
                // Sprawdzenie kolizji X z domem
                if (player.x > wallL - player.width/4 && player.x < wallR + player.width/4 && 
                    player.y > wallT - player.height/4 && player.y < wallB) {
                    // Cofnij
                    player.x -= vx;
                }

                // RUCH Y
                player.y += vy;
                // Sprawdzenie kolizji Y z domem
                if (player.x > wallL - player.width/4 && player.x < wallR + player.width/4 && 
                    player.y > wallT - player.height/4 && player.y < wallB) {
                    // Cofnij
                    player.y -= vy;
                }

                player.walkFrame += 0.2;
                player.facingRight = dx > 0 || (dx === 0 && player.facingRight);
            }

            // Bound player to screen (Krawędzie ekranu)
            player.x = Math.max(30, Math.min(gameCanvas.width - 30, player.x));
            player.y = Math.max(40, Math.min(gameCanvas.height - 40, player.y));

            // Player aim angle (only for weapon)
            player.angle = Math.atan2(mouseY - (player.y - 15), mouseX - player.x);
            if (mouseX > player.x) player.facingRight = true;
            else if (mouseX < player.x) player.facingRight = false;

            // Shooting
            if (!isBossIntro && mouseDown) shoot();
            if (player.shootCooldown > 0) player.shootCooldown--;
            if (player.invincible > 0) player.invincible--;
			
			player.isRepairing = false; 
            
            // Dystans do środka domu
            const houseCenterX = house.x + house.width/2;
            const houseCenterY = house.y + house.height/2;
            const distToHouse = Math.hypot(player.x - houseCenterX, player.y - houseCenterY);
            
                                    // --- SYSTEM BUDOWANIA I NAPRAWY (Klawisz R) ---
            player.isRepairing = false;
            let actionTaken = false; // Flaga, żeby nie robić 2 rzeczy na raz

            // 1. BUDOWANIE NOWYCH (Priorytet, tylko w przerwie)
            if (waveDelay > 0 && keys['r']) {
                for (let i = 0; i < fortSlots.length; i++) {
                    const slot = fortSlots[i];
                    if (!slot.built && Math.hypot(player.x - slot.x, player.y - slot.y) < 60) {
                        if (player.scrap >= slot.cost) {
                            player.isRepairing = true;
                            player.repairTimer++;
                            
                                if (player.repairTimer > 30) { // 0.5 sekundy budowania
                                player.scrap -= slot.cost;
                                slot.built = true;
                                
                                // Ustalanie statystyk w zależności od typu
                                const isWire = slot.type === 'wire';
                                
                                fortifications.push({
                                    x: slot.x, y: slot.y,
                                    slotIndex: i,
                                    type: slot.type, // Ważne!
                                    isVertical: slot.isVertical, // Ważne dla drutu
                                    
                                    // Statystyki: Drut ma 250 HP, Kolce 100 HP
                                    health: isWire ? 250 : 100, 
                                    maxHealth: isWire ? 250 : 100,
                                    
                                    // Drut ma większy zasięg
                                    radius: isWire ? 150 : 35 ,
                                    
                                    // Obrażenia podobne, ale efekt spowolnienia będzie inny w logice kolizji
                                    damage: 0.5 
                                });
                                
                                showPickupNotification(`- ${slot.cost} Złom (Budowa)`);
                                player.repairTimer = 0;
                                
                                // Efekt pyłu
                                for(let k=0; k<10; k++) particles.push({x:slot.x, y:slot.y, vx:(Math.random()-0.5)*5, vy:(Math.random()-0.5)*5, life:30, maxLife:30, size:4, color:'#8b5a2b'});
                            }
                            actionTaken = true;
                            break; 
                        }
                    }
                }
            }

            // 2. NAPRAWA ISTNIEJĄCYCH FORTYFIKACJI (Tylko w przerwie, za 1 złom)
            if (!actionTaken && waveDelay > 0 && keys['r'] && player.scrap > 0) {
                for (let i = 0; i < fortifications.length; i++) {
                    const fort = fortifications[i];
                    // Jeśli blisko I uszkodzone
                    if (Math.hypot(player.x - fort.x, player.y - fort.y) < 60 && fort.health < fort.maxHealth) {
                        player.isRepairing = true;
                        player.repairTimer++;

                        // Co 60 klatek (1 sekunda) zużyj 1 złom
                        if (player.repairTimer % 60 === 0) {
                            player.scrap--;
                            showPickupNotification("-1 Złom (Naprawa kolców)");
                        }

                        // Leczenie kolców (szybciej niż dom, bo mają mniej HP)
                        fort.health = Math.min(fort.maxHealth, fort.health + 1.0);
                        
                        // Iskry
                        if (player.repairTimer % 5 === 0) {
                             particles.push({x: fort.x, y: fort.y-10, vx:(Math.random()-0.5)*3, vy:-2, life:15, maxLife:15, size:2, color:'#ffff00'});
                        }
                        
                        actionTaken = true;
                        break;
                    }
                }
            }

            // 3. NAPRAWA DOMU (Jeśli nic innego nie robimy)
            if (!actionTaken && keys['r'] && player.scrap > 0 && house.health < house.maxHealth) {
                const houseCenterX = house.x + house.width/2;
                const houseCenterY = house.y + house.height/2;
                const distToHouse = Math.hypot(player.x - houseCenterX, player.y - houseCenterY);

                if (distToHouse < 130) {
                    player.isRepairing = true;
                    player.repairTimer++;
                    
                    if (player.repairTimer % 20 === 0) {
                        player.scrap--;
                        showPickupNotification("-1 Złom (Naprawa domu)");
                    }
                    house.health = Math.min(house.maxHealth, house.health + 0.10);
                    
                    if (player.repairTimer % 5 === 0) {
                        for(let i=0; i<3; i++) particles.push({x: player.x, y: player.y-10, vx:(Math.random()-0.5)*5, vy:-2-Math.random()*4, life:20, maxLife:30, size:2, color:'#ffff00', gravity:0.2});
                    }
                    actionTaken = true;
                }
            } 

                       // --- A0. WIEŻYCZKA (BUDOWA / ULEPSZANIE) ---
            // Sprawdź dystans do miejsca na wieżyczkę
            const distToTurret = Math.hypot(player.x - turret.x, player.y - turret.y);
            
            if (waveDelay > 0 && keys['r'] && distToTurret < 60 && turret.tier < 3) {
                const cost = turret.costs[turret.tier]; // Pobierz koszt dla obecnego poziomu
                
                if (player.scrap >= cost) {
                    player.isRepairing = true;
                    player.repairTimer++;
                    
                    // Budowanie trwa (30 klatek)
                    if (player.repairTimer > 30) {
                        player.scrap -= cost;
                        turret.tier++;
                        showPickupNotification(`- ${cost} Złom (Wieżyczka Tier ${turret.tier})`);
                        player.repairTimer = 0;
                        
                        // Efekt sypiących się zębatek
                        for(let k=0; k<15; k++) particles.push({x:turret.x, y:turret.y, vx:(Math.random()-0.5)*5, vy:(Math.random()-0.5)*5, life:40, maxLife:40, size:4, color:'#ffd700'});
                    }
                    actionTaken = true; // Zablokuj inne akcje budowania
                }
            }

                        // ============================================================
            // 8. LOGIKA WIEŻYCZKI (AUTO-AIM & ALTERNATING FIRE)
            // ============================================================
             if (turret.recoil > 0) turret.recoil -= 0.5;

            if (turret.tier > 0 && turret.cooldown > 0) turret.cooldown--;

            if (turret.tier > 0 && turret.cooldown <= 0) {
                let range = 0, dmg = 0, fireRate = 0, bulletSpeed = 0;
                
                // Statystyki
                if (turret.tier === 1) { range = 700; dmg = 15; fireRate = 40; bulletSpeed = 12; }
                else if (turret.tier === 2) { range = 800; dmg = 30; fireRate = 25; bulletSpeed = 18; }
                else if (turret.tier === 3) { 
                    range = 900; 
                    dmg = 30; 
                    fireRate = 10; // BARDZO SZYBKO (strzela na zmianę)
                    bulletSpeed = 25; 
                }

                // Szukanie celu
                let target = null;
                let minDst = range;

                // 1. Priorytet: Zwykłe dziki
                boars.forEach(boar => {
                    const dst = Math.hypot(boar.x - turret.x, boar.y - turret.y);
                    if (dst < minDst) { 
                        minDst = dst; 
                        target = boar; 
                    }
                });

                // 2. Priorytet: Pablobitos (Tylko jeśli brak zwykłych celów)
                if (!target && pablobitos) {
                    const bossDist = Math.hypot(pablobitos.x - turret.x, pablobitos.y - turret.y);
                    // Sprawdzamy czy boss jest w zasięgu (dodajemy margines na jego wielkość)
                    if (bossDist < range + 100) {
                        target = pablobitos;
                    }
                }

                if (target) {
                    turret.angle = Math.atan2(target.y - turret.y, target.x - turret.x);
                    turret.cooldown = fireRate;

                    // Matematyka pozycji lufy
                    const c = Math.cos(turret.angle);
                    const s = Math.sin(turret.angle);

                    const spawnTurretBullet = (offsetX, offsetYSide) => {
                        const spawnX = turret.x + (c * offsetX) - (s * offsetYSide);
                        const spawnY = turret.y + (s * offsetX) + (c * offsetYSide);

                        bullets.push({
                            x: spawnX, y: spawnY,
                            vx: c * bulletSpeed, vy: s * bulletSpeed,
                            damage: dmg, weapon: 'turret',
                            piercing: turret.tier === 3, hitBoars: [], trail: [], life: 80
                        });

                        particles.push({
                            x: spawnX + c * 10, y: spawnY + s * 10,
                            vx: c * 2, vy: s * 2,
                            life: 10, maxLife: 10, size: 4, color: '#ffff00'
                        });

                                                turret.recoil = 6; 

                        // --- ŁUSKA ---
                        // Wylatuje z boku (prostopadle do lufy)
                        const shellAngle = turret.angle + Math.PI / 2 + (Math.random()-0.5)*0.5;
                        const shellSpeed = 4 + Math.random()*2;
                        
                        shells.push({
                            x: turret.x + (c * 20), // Z korpusu
                            y: turret.y + (s * 20),
                            vx: Math.cos(shellAngle) * shellSpeed,
                            vy: Math.sin(shellAngle) * shellSpeed,
                            rotation: Math.random() * Math.PI * 2,
                            rotationSpeed: (Math.random() - 0.5) * 0.5,
                            life: 300,
                            type: 'turret' // Rysuje się jak mała łuska
                        });

                        // Większy Muzzle Flash
                        for(let k=0; k<8; k++) {
                            particles.push({
                                x: spawnX, y: spawnY,
                                vx: c*5 + (Math.random()-0.5)*3,
                                vy: s*5 + (Math.random()-0.5)*3,
                                life: 12, maxLife: 12, size: 5, color: '#ffff00'
                            });
                        }
                    };

                    if (turret.tier === 3) {
                        // TIER 3: Strzał naprzemienny
                        // Używamy turret.barrelToggle (1 lub -1) do wyboru strony
                        spawnTurretBullet(90, 13 * turret.barrelToggle);
                        
                        // Zmień lufę na następny raz
                        turret.barrelToggle *= -1;
                    } else {
                        // TIER 1 & 2: Pojedyncza lufa
                        const barrelLen = turret.tier === 1 ? 60 : 85;
                        spawnTurretBullet(barrelLen, 0);
                    }
                }
            }

                        // --- A-MINUS. SKLEP Z PANCERZEM (PRIORYTET 0) ---
            if (!actionTaken && waveDelay > 0 && keys['r'] && player.armorTier < 2) {
                // Sprawdź dystans do stolika
                const distToShop = Math.hypot(player.x - armorStation.x, player.y - armorStation.y);
                
                if (distToShop < 60) {
                    const cost = armorStation.costs[player.armorTier]; // 0 -> koszt[0], 1 -> koszt[1]
                    
                    if (player.scrap >= cost) {
                        player.isRepairing = true; // Animacja "pracy" przy stole
                        player.repairTimer++;
                        
                        if (player.repairTimer > 45) { // Kupowanie trwa 0.75s
                            player.scrap -= cost;
                            player.armorTier++;
                            const name = player.armorTier === 1 ? "Kamizelka" : "Maska Gazowa";
                            showPickupNotification(`Kupiono: ${name}`);
                            player.repairTimer = 0;
                            
                            // Efekt niebieskich iskierek (spawanie)
                            for(let k=0; k<15; k++) particles.push({x:armorStation.x, y:armorStation.y, vx:(Math.random()-0.5)*4, vy:(Math.random()-0.5)*4, life:40, maxLife:40, size:3, color:'#00ffff'});
                        }
                        actionTaken = true;
                    }
                }
            }

                        // --- A-MINUS. SKLEP Z BRONIĄ (PRIORYTET 0) ---
            if (!actionTaken && waveDelay > 0 && keys['r'] && player.revolverTier < 2) {
                const distToGunShop = Math.hypot(player.x - gunStation.x, player.y - gunStation.y);
                
                if (distToGunShop < 60) {
                    const cost = gunStation.costs[player.revolverTier];
                    
                    if (player.scrap >= cost) {
                        player.isRepairing = true;
                        player.repairTimer++;
                        
                        if (player.repairTimer > 45) {
                            player.scrap -= cost;
                            player.revolverTier++;
                            const name = player.revolverTier === 1 ? "Podwójna Lufa" : "Mechanizm Serii";
                            showPickupNotification(`Ulepszono: ${name}`);
                            player.repairTimer = 0;
                            for(let k=0; k<15; k++) particles.push({x:gunStation.x, y:gunStation.y, vx:(Math.random()-0.5)*4, vy:(Math.random()-0.5)*4, life:40, maxLife:40, size:3, color:'#ffcc33'});
                        }
                        actionTaken = true;
                    }
                }
            }

                        // --- A-MINUS. SKLEP SNAJPERSKI (PRIORYTET 0) ---
            if (!actionTaken && waveDelay > 0 && keys['r'] && player.sniperTier < 2) {
                const dist = Math.hypot(player.x - sniperStation.x, player.y - sniperStation.y);
                if (dist < 60) {
                    const cost = sniperStation.costs[player.sniperTier];
                    if (player.scrap >= cost) {
                        player.isRepairing = true;
                        player.repairTimer++;
                        if (player.repairTimer > 45) {
                            player.scrap -= cost;
                            player.sniperTier++;
                            const name = player.sniperTier === 1 ? "Kaliber .50" : "Działo Gaussa";
                            showPickupNotification(`Ulepszono: ${name}`);
                            player.repairTimer = 0;
                            for(let k=0; k<15; k++) particles.push({x:sniperStation.x, y:sniperStation.y, vx:(Math.random()-0.5)*4, vy:(Math.random()-0.5)*4, life:40, maxLife:40, size:3, color:'#ff0000'});
                        }
                        actionTaken = true;
                    }
                }
            }

            // --- A-MINUS. SKLEP Z LISAMI (PRIORYTET 0) ---
            if (!actionTaken && waveDelay > 0 && keys['r'] && foxStation.tier < 3) {
                const dist = Math.hypot(player.x - foxStation.x, player.y - foxStation.y);
                
                if (dist < 60) {
                    const cost = foxStation.costs[foxStation.tier];
                    
                    if (player.scrap >= cost) {
                        player.isRepairing = true;
                        player.repairTimer++;
                        
                        if (player.repairTimer > 45) {
                            player.scrap -= cost;
                            foxStation.tier++;
                            
                            // NOWE ILOŚCI:
                            foxStation.foxes = []; // Reset tablicy
                            let count = 0;
                            if (foxStation.tier === 1) count = 2; // Tier 1: 2 lisy
                            else if (foxStation.tier === 2) count = 3; // Tier 2: 3 lisy
                            else if (foxStation.tier === 3) count = 5; // Tier 3: 5 lisów

                            // Rozstaw lisy po okręgu
                            for(let k=0; k<count; k++) {
                                foxStation.foxes.push({ angle: (Math.PI * 2 / count) * k });
                            }

                            showPickupNotification(`Ulepszono: ${count} Lisy`);
                            player.repairTimer = 0;
                            for(let k=0; k<15; k++) particles.push({x:foxStation.x, y:foxStation.y, vx:(Math.random()-0.5)*4, vy:(Math.random()-0.5)*4, life:40, maxLife:40, size:3, color:'#e65100'});
                        }
                        actionTaken = true;
                    }
                }
            }
            
            // Reset licznika jeśli nic nie robimy
            if (!actionTaken) {
                player.repairTimer = 0;
            }

            // Vape effects
            if (!isBossIntro && player.vapeActive) {
                player.vapeDuration--;
                if (player.vapeDuration <= 0) {
                    player.vapeActive = false;
                }

                // Continuous vape cloud around player
                if (Math.random() < 0.4) {
                    vapeParticles.push({
                        x: player.x + (Math.random() - 0.5) * 60,
                        y: player.y + (Math.random() - 0.5) * 60,
                        vx: (Math.random() - 0.5) * 2,
                        vy: -1 - Math.random() * 2,
                        life: 40 + Math.random() * 30,
                        maxLife: 70,
                        size: 15 + Math.random() * 25,
                        hue: 260 + Math.random() * 40
                    });
                }
            } else if (player.vapeCharge < 100) {
                player.vapeCharge += 0.15;
            }

             for (let i = bloodSplatters.length - 1; i >= 0; i--) {
                const s = bloodSplatters[i];
                // Zmniejszaj przezroczystość
                s.opacity -= 0.0008; 
                // Jak zniknie całkowicie, usuń z pamięci
                if (s.opacity <= 0) {
                    bloodSplatters.splice(i, 1);
                }
            }

            // Fizyka Flaków
            for (let i = meatChunks.length - 1; i >= 0; i--) {
                const m = meatChunks[i];
                m.x += m.vx; m.y += m.vy;
                m.rot += m.rotSpeed;
                m.vx *= 0.9; m.vy *= 0.9; // Tarcie
                if (Math.abs(m.vx) < 0.1) m.rotSpeed = 0; // Stop obrotu jak leży
                m.life--;
                if (m.life <= 0) meatChunks.splice(i, 1);
            }

            // Zanikanie Zwłok
            for (let i = corpses.length - 1; i >= 0; i--) {
                corpses[i].life--;
                if (corpses[i].life <= 0) corpses.splice(i, 1);
            }

                        // Fizyka łusek
            for (let i = shells.length - 1; i >= 0; i--) {
                const s = shells[i];
                s.x += s.vx;
                s.y += s.vy;
                s.rotation += s.rotationSpeed;
                
                // Tarcie (zwalnianie)
                s.vx *= 0.9;
                s.vy *= 0.9;
                
                // Jeśli przestała się ruszać, przestaje wirować
                if (Math.abs(s.vx) < 0.1 && Math.abs(s.vy) < 0.1) s.rotationSpeed = 0;

                s.life--;
                if (s.life <= 0) shells.splice(i, 1);
            }

            // Bullets
// 4. POCISKI (POPRAWIONA PENETRACJA + DROP)
                        // 4. POCISKI (PENETRACJA + DROP + GORE/SZKIELETY)
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                
                // Ruch i ślad
                b.trail.push({x:b.x, y:b.y}); 
                if(b.trail.length > 15) b.trail.shift();
                
                b.x += b.vx; 
                b.y += b.vy; 
                b.life--;
                
                // Hitbox pocisku (większy dla wyższych tierów snajperki)
                let bulletRadius = 3;
                if (b.weapon === 'sniper') {
                    if (b.tier === 1) bulletRadius = 9;
                    if (b.tier === 2) bulletRadius = 18;
                }

                // Sprawdzanie dzików
                for (let j = boars.length - 1; j >= 0; j--) {
                    const boar = boars[j];
                    
                    // 1. Ignoruj już trafione (bardzo ważne przy penetracji!)
                    // Używamy referencji do obiektu 'boar', a nie indeksu 'j'
                    if (b.hitBoars.includes(boar)) continue; 

                    // 2. Kolizja
                    if (Math.hypot(b.x - boar.x, b.y - boar.y) < boar.width/2 + bulletRadius) {
                        boar.health -= b.damage;
                        
                        // Dodajemy OBIEKT dzika do trafionych
                        b.hitBoars.push(boar); 
                        
                        // Efekt trafienia
                        createBloodEffect(b.x, b.y, b.weapon === 'sniper' ? 25 : 12);
                        
                        // --- ŚMIERĆ DZIKA ---
                        if (boar.health <= 0) {
                            handleBoarDeath(boar, j);
                        }
                        
                        // --- PENETRACJA ---
                        // Jeśli pocisk NIE penetruje (np. rewolwer), niszczymy go po trafieniu
                        if (!b.piercing) { 
                            b.life = 0; // Zabij pocisk
                            break;      // Przerwij sprawdzanie innych dzików
                        }
                        // Jeśli penetruje (snajperka), pętla leci dalej
                    }
                }
                
                // Usuń martwe pociski lub te poza ekranem
                if (b.x < -50 || b.x > gameCanvas.width+50 || b.y < -50 || b.y > gameCanvas.height+50 || b.life <= 0) {
                    bullets.splice(i, 1);
                }
            }

                        // --- POCISKI BOSSA (Ślina) ---
            for (let i = bossProjectiles.length - 1; i >= 0; i--) {
                const b = bossProjectiles[i];
                b.x += b.vx;
                b.y += b.vy;
                
                // Liczmy przebyty dystans
                const step = Math.hypot(b.vx, b.vy);
                b.traveled += step;

                // Kolizja z graczem (bezpośrednia)
                let hitPlayer = false;
                if (Math.hypot(player.x - b.x, player.y - b.y) < b.size + 10) {
                    hitPlayer = true;
                    if (player.invincible <= 0) {
                        // Redukcja pancerzem
                        let dmg = b.damage;
                        if(player.armorTier===1) dmg*=0.7;
                        if(player.armorTier===2) dmg*=0.5;
                        player.health -= dmg;
                        player.invincible = 60;
                    }
                }

                // Wybuch (jeśli trafił gracza LUB doleciał do celu)
                if (hitPlayer || b.traveled >= b.targetDist) {
                    // Efekt wybuchu
                    for(let k=0; k<10; k++) {
                        particles.push({x:b.x, y:b.y, vx:(Math.random()-0.5)*6, vy:(Math.random()-0.5)*6, life:20, maxLife:20, size:4, color:'#76ff03'});
                    }
                    
                    // Zostaw plamę kwasu
                    acidPools.push({
                        x: b.x, y: b.y,
                        radius: b.size * 5, // Plama większa od pocisku
                        life: 360 // Trwa 3 sekundy
                    });

                    bossProjectiles.splice(i, 1);
                }
            }

            // --- PLAMY KWASU (AOE) ---
            for (let i = acidPools.length - 1; i >= 0; i--) {
                const p = acidPools[i];
                p.life--;
                
                // Obrażenia od stania w kwasie (co klatkę!)
                if (Math.hypot(player.x - p.x, player.y - p.y) < p.radius) {
                    // Małe obrażenia ale częste (0.2 dmg/klatkę = 12 dmg/sekundę)
                    // Pancerz nie chroni przed kwasem (chyba że maska - opcjonalnie)
                    let acidDmg = 0.2;
                    if (player.armorTier === 2) acidDmg = 0; // Maska chroni przed oparami? (Twoja decyzja, tu dałem 0)
                    
                    player.health -= acidDmg;
                }

                if (p.life <= 0) acidPools.splice(i, 1);
            }

                        // FALE UDERZENIOWE (Update)
            for (let i = shockwaves.length - 1; i >= 0; i--) {
                const s = shockwaves[i];
                s.radius += 12; // Lekko wolniej, żeby dłużej było widać
                s.alpha -= 0.02; // WOLNIEJSZE ZANIKANIE (dłuższy efekt)
                s.lineWidth -= 0.15;
                
                if (s.alpha <= 0) shockwaves.splice(i, 1);
            }

                         // ============================================================
            // 6. AI DZIKÓW (Z Ruchem, Kolizją i Spowolnieniem)
            // ============================================================
            boars.forEach(boar => {
                // Jeśli ogłuszony (np. przez Vape), nic nie robi
                if (boar.stunned > 0) {
                    boar.stunned--;
                    // Resetujemy flagę spowolnienia, bo i tak stoi
                    boar.slowedBy = null; 
                    return;
                }

                // 1. Obliczanie prędkości (z uwzględnieniem pułapek)
                let speedMultiplier = 1.0;
                
                // Sprawdzamy flagę ustawioną w sekcji fortyfikacji
                if (boar.slowedBy === 'wire') {
                    speedMultiplier = 0.3; // Drut - bardzo wolno
                } else if (boar.slowedBy === 'spikes') {
                    speedMultiplier = 0.6; // Kolce - wolniej
                }
                
                // Resetujemy flagę na koniec klatki (żeby w następnej klatce znów sprawdził czy jest w pułapce)
                boar.slowedBy = null; 

                const currentSpeed = boar.speed * speedMultiplier; // boar.speed to jego bazowa prędkość

                // 2. Wybór celu
                let targetX, targetY;
                if (boar.target === 'player') {
                    targetX = player.x;
                    targetY = player.y;
                } else {
                    targetX = house.x + house.width / 2;
                    targetY = house.y + house.height / 2;
                }

                // 3. Obliczanie ruchu
                boar.angle = Math.atan2(targetY - boar.y, targetX - boar.x);
                let vx = Math.cos(boar.angle) * currentSpeed;
                let vy = Math.sin(boar.angle) * currentSpeed;

                let touchingHouse = false;

                // 4. RUCH X (Z kolizją domu)
                boar.x += vx;
                if (boar.x > wallL - 15 && boar.x < wallR + 15 && 
                    boar.y > wallT - 15 && boar.y < wallB + 10) {
                    
                    touchingHouse = true;
                    if (vx > 0) boar.x = wallL - 15;
                    else if (vx < 0) boar.x = wallR + 15;
                }

                // 5. RUCH Y (Z kolizją domu)
                boar.y += vy;
                if (boar.x > wallL - 15 && boar.x < wallR + 15 && 
                    boar.y > wallT - 15 && boar.y < wallB + 10) {
                    
                    touchingHouse = true;
                    if (vy > 0) boar.y = wallT - 15;
                    else if (vy < 0) boar.y = wallB + 10;
                }

                // Animacja
                boar.walkFrame += currentSpeed * 0.1;
                if (boar.attackCooldown > 0) boar.attackCooldown--;

                // 6. ATAK NA GRACZA
                if (Math.hypot(player.x - boar.x, player.y - boar.y) < 45 && boar.attackCooldown <= 0 && player.invincible <= 0) {
                    
                    // Redukcja obrażeń pancerzem
                    let dmgTaken = boar.damage;
                    if (player.armorTier === 1) dmgTaken *= 0.7; // Kamizelka (30% def)
                    if (player.armorTier === 2) dmgTaken *= 0.5; // Maska (50% def)
                    
                    player.health -= dmgTaken;
                    player.invincible = 45; 
                    boar.attackCooldown = 60;
                    
                    for (let i = 0; i < 5; i++) {
                        particles.push({x: player.x, y: player.y, vx: (Math.random()-0.5)*6, vy: (Math.random()-0.5)*6, life: 20, maxLife: 20, size: 3, color: '#8b0000', gravity: 0.15});
                    }
                }

                // 7. ATAK NA DOM
                if (touchingHouse && boar.target !== 'player') {
                    if (boar.attackCooldown <= 0) {
                        house.health -= boar.damage * 0.5;
                        boar.attackCooldown = 90;
                        
                        // Wióry
                        for (let i = 0; i < 8; i++) {
                            particles.push({
                                x: boar.x, y: boar.y,
                                vx: (Math.random()-0.5)*8, vy: (Math.random()-0.5)*8-2,
                                life: 30, maxLife: 30, size: 2+Math.random()*3, color: '#8a6914', gravity: 0.3
                            });
                        }
                    }
                }
            });

            // Ammo pickups
             // ZBIERANIE PRZEDMIOTÓW (Z LIMITAMI)
                        // ZBIERANIE PRZEDMIOTÓW (Z LIMITAMI TIEROWYMI)
            [ammoPickups, medkitPickups, scrapPickups].forEach(arr => {
                for (let i = arr.length-1; i>=0; i--) {
                    const p = arr[i]; 
                    p.pulsePhase += 0.08;
                    
                    if (Math.hypot(player.x - p.x, player.y - p.y) < 40) {
                        let collected = false;

                        if (arr === ammoPickups) { 
                            // Limit snajperki zależny od tieru
                            let maxAmmo = 5;
                            if (player.sniperTier === 1) maxAmmo = 10;
                            if (player.sniperTier === 2) maxAmmo = 15;

                            if (player.sniperAmmo < maxAmmo) {
                                // Nie przekraczaj maxa
                                const space = maxAmmo - player.sniperAmmo;
                                const toAdd = Math.min(space, p.amount);
                                
                                player.sniperAmmo += toAdd;
                                showPickupNotification(`+${toAdd} naboje`); 
                                collected = true;
                                
                                // Jeśli w paczce było więcej niż zmieściliśmy, zostaw resztę na ziemi?
                                // (Dla uproszczenia: zjadamy całą paczkę, nawet jak weźmiemy 1 nabój)
                            }
                        }
                        else if (arr === medkitPickups) { 
                            // Limit 5 apteczek
                            if (player.medkits < 5) {
                                player.medkits++; 
                                showPickupNotification("+1 Apteczka"); 
                                collected = true;
                            }
                        }
                        else if (arr === scrapPickups) { 
                            // Limit 300 złomu
                            if (player.scrap < 300) {
                                const space = 300 - player.scrap;
                                const toAdd = Math.min(space, p.amount);
                                
                                player.scrap += toAdd; 
                                showPickupNotification(`+${toAdd} Złom`); 
                                collected = true;
                            }
                        }
                        
                        if (collected) arr.splice(i, 1);
                    }
                }
            });

            // Particles update
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                if (p.gravity) p.vy += p.gravity;
                p.vx *= 0.95;
                p.vy *= 0.95;
                p.life--;
                if (p.life <= 0) particles.splice(i, 1);
            }

            // Vape particles update
            for (let i = vapeParticles.length - 1; i >= 0; i--) {
                const p = vapeParticles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.97;
                p.vy *= 0.97;
                p.size *= 0.995;
                p.life--;
                if (p.life <= 0) vapeParticles.splice(i, 1);
            }

             // ============================================================
            // 7.5 AI JASTRZĘBIA (Odkurzacz z Limitami)
            // ============================================================
            hawk.animFrame += 0.5;

            // 1. KUPNO (Jeśli nie kupiony)
            if (!hawk.purchased) {
                hawk.x = hawkNest.x;
                hawk.y = hawkNest.y;
                if (waveDelay > 0 && keys['r'] && player.scrap >= hawk.cost) {
                    const dist = Math.hypot(player.x - hawkNest.x, player.y - hawkNest.y);
                    if (dist < 100) {
                        player.scrap -= hawk.cost;
                        hawk.purchased = true;
                        hawk.state = 'idle'; // Zaczynamy pracę
                        showPickupNotification("Wynajęto Jastrzębia!");
                    }
                }
            } 
            else {
                // --- TRYB PRACY ---
                
                const itemsCarried = hawk.inventory.scrap + hawk.inventory.medkits + hawk.inventory.ammo;
                const maxCapacity = 10; 

                // Jeśli pełny -> Wracaj
                if (itemsCarried >= maxCapacity && hawk.state !== 'delivering') {
                    hawk.state = 'delivering';
                    if (hawk.target) {
                        hawk.target.claimedByHawk = false; // Zwolnij cel
                        hawk.target = null;
                    }
                }

                // SZUKANIE (Gdy nie ma celu i nie wraca)
                if (!hawk.target && hawk.state !== 'delivering') {
                    
                    let bestDist = Infinity;
                    let bestItem = null;
                    let bestType = '';
                    const searchList = [];

                    // Budujemy listę tego, co POTRZEBUJEMY
                    if (player.scrap < 300) searchList.push({arr: scrapPickups, type: 'scrap'});
                    if (player.medkits < 5) searchList.push({arr: medkitPickups, type: 'medkit'});
                    
                    let maxAmmo = 5 + player.sniperTier * 5;
                    if (player.sniperAmmo < maxAmmo) searchList.push({arr: ammoPickups, type: 'ammo'});

                    // Promień szukania (lokalny lub globalny)
                    const searchRadius = (itemsCarried > 0) ? 250 : Infinity; 

                    // Szukamy
                    searchList.forEach(list => {
                        list.arr.forEach(item => {
                            if (!item.claimedByHawk) {
                                const d = Math.hypot(hawk.x - item.x, hawk.y - item.y);
                                // Szukamy najbliższego w zasięgu
                                if (d < bestDist && d < searchRadius) {
                                    bestDist = d;
                                    bestItem = item;
                                    bestType = list.type;
                                }
                            }
                        });
                    });

                    if (bestItem) {
                        // Znaleziono!
                        hawk.target = bestItem;
                        hawk.target.claimedByHawk = true;
                        hawk.targetType = bestType;
                        hawk.state = 'fetching';
                    } else {
                        // Nic nie znaleziono
                        if (itemsCarried > 0) {
                            // Masz coś w plecaku, a w pobliżu pusto -> WRACAJ
                            hawk.state = 'delivering';
                        } else {
                            // Pusty i pusto na mapie -> IDLE / KRĄŻENIE
                            if (hawk.state !== 'idle') {
                                const distToNest = Math.hypot(hawk.x - hawkNest.x, hawk.y - hawkNest.y);
                                if (distToNest < 10) {
                                    hawk.state = 'idle'; hawk.x = hawkNest.x; hawk.y = hawkNest.y;
                                } else {
                                    hawk.state = 'searching'; // Wracanie
                                    const dx = hawkNest.x - hawk.x;
                                    const dy = hawkNest.y - hawk.y;
                                    hawk.x += (dx/distToNest) * hawk.speed;
                                    hawk.y += (dy/distToNest) * hawk.speed;
                                }
                            }
                        }
                    }
                }

                // --- RUCH ---

                // FETCHING
                if (hawk.state === 'fetching' && hawk.target) {
                    const dx = hawk.target.x - hawk.x;
                    const dy = hawk.target.y - hawk.y;
                    const dist = Math.hypot(dx, dy);
                    
                    if (dist < 15) {
                        // Podnieś
                        let arr = hawk.targetType === 'scrap' ? scrapPickups : (hawk.targetType === 'medkit' ? medkitPickups : ammoPickups);
                        const idx = arr.indexOf(hawk.target);
                        
                        if (idx > -1) { // Czy przedmiot jeszcze istnieje? (Mógł zniknąć przez despawn)
                            arr.splice(idx, 1);
                            if (hawk.targetType === 'scrap') hawk.inventory.scrap += hawk.target.amount;
                            else if (hawk.targetType === 'medkit') hawk.inventory.medkits += 1;
                            else if (hawk.targetType === 'ammo') hawk.inventory.ammo += hawk.target.amount;
                        }
                        hawk.target = null; 
                    } else {
                        hawk.x += (dx/dist) * hawk.speed;
                        hawk.y += (dy/dist) * hawk.speed;
                    }
                }

                // DELIVERING
                if (hawk.state === 'delivering') {
                    const dx = player.x - hawk.x;
                    const dy = player.y - hawk.y;
                    const dist = Math.hypot(dx, dy);

                    if (dist < 30) {
                        // Oddaj (z uwzględnieniem limitów gracza)
                        // Złom
                        if (hawk.inventory.scrap > 0) {
                            const space = 300 - player.scrap;
                            const give = Math.min(space, hawk.inventory.scrap);
                            player.scrap += give;
                            if (give > 0) showPickupNotification(`+${give} Złom (Jastrząb)`);
                        }
                        // Apteczki
                        if (hawk.inventory.medkits > 0) {
                            const space = 5 - player.medkits;
                            const give = Math.min(space, hawk.inventory.medkits);
                            player.medkits += give;
                            if (give > 0) showPickupNotification(`+${give} Apteczki (Jastrząb)`);
                        }
                        // Ammo
                        if (hawk.inventory.ammo > 0) {
                            let maxAmmo = 5 + player.sniperTier * 5;
                            const space = maxAmmo - player.sniperAmmo;
                            const give = Math.min(space, hawk.inventory.ammo);
                            player.sniperAmmo += give;
                            if (give > 0) showPickupNotification(`+${give} Ammo (Jastrząb)`);
                        }
                        
                        // Opróżnij plecak (nawet jak się nie zmieściło - ptak upuszcza resztę / traci)
                        // Dla uproszczenia: ptak zawsze czyści plecak
                        hawk.inventory = { scrap: 0, medkits: 0, ammo: 0 };
                        hawk.state = 'searching'; 
                    } else {
                        hawk.x += (dx/dist) * hawk.speed;
                        hawk.y += (dy/dist) * hawk.speed;
                    }
                }
            }

                    // ============================================================
            // 7.8 LOGIKA LISÓW (Ochroniarze)
            // ============================================================
            if (foxStation.tier > 0) {
                const orbitSpeed = 0.1; 
                const baseOrbitRadius = 100; // ZWIĘKSZONY ZASIĘG (Było 65)

                // Pulsowanie wspólne dla wszystkich (poza pętlą)
                const pulse = Math.sin(gameTime * 0.1) * 25; // +/- 25px
                const currentRadius = baseOrbitRadius + pulse;

                foxStation.foxes.forEach(fox => { // index niepotrzebny do pulsu
                    fox.angle += orbitSpeed;
                    
                    const fx = player.x + Math.cos(fox.angle) * currentRadius;
                    const fy = player.y + Math.sin(fox.angle) * currentRadius;

                    // Sprawdzanie kolizji z dzikami
                    // Pętla od tyłu dla bezpiecznego usuwania
                    for (let j = boars.length - 1; j >= 0; j--) {
                        const boar = boars[j];
                        
                        // Dystans między lisem a dzikiem
                        const dist = Math.hypot(fx - boar.x, fy - boar.y);
                        
                        // Kolizja (Lis gryzie)
                        if (dist < 50) { // Zasięg gryzienia
                            boar.health -= 4.0; // Obrażenia co klatkę (wysokie dps przy ciągłym kontakcie)
                            
                            // Krew
                            if (Math.random() < 0.3) {
                                particles.push({x: boar.x, y: boar.y, vx:(Math.random()-0.5)*4, vy:(Math.random()-0.5)*4, life:10, maxLife:10, size:2, color:'#8b0000'});
                            }

                            // Śmierć dzika
                            if (boar.health <= 0) {
                                handleBoarDeath(boar, j);
                            }
                        }
                    }
                });
            }

               // ============================================================
            // 9. LOGIKA PABLOBITOSA (INTRO + WALKA)
            // ============================================================
            if (pablobitos) {
                
                // --- A. TRYB INTRO (Kamera i Wejście) ---
                if (pablobitos.isIntro) {
                    document.getElementById('healthPanel').style.display = 'none';
                    bossIntroTimer--;
                    
                    // Postęp od 0.0 do 1.0 (czas trwania intro)
                    const progress = 1 - (bossIntroTimer / bossIntroDuration);
                    
                    // Punkt startowy kamery (Środek ekranu/Domu) - zakładamy, że gra zaczyna się wycentrowana
                    const centerScreenX = gameCanvas.width / 2;
                    const centerScreenY = gameCanvas.height / 2;

                    // OBSŁUGA KAMERY (Interpolacja)
                    if (progress < 0.2) { // Faza 1: Najazd kamery na bossa
                        const t = progress * 5; // 0 -> 1
                        // Interpolujemy od środka ekranu do pozycji bossa
                        camera.x = centerScreenX + (pablobitos.x - centerScreenX) * t;
                        camera.y = centerScreenY + (pablobitos.y - centerScreenY) * t;
                        camera.zoom = 1.0 + t * 0.4; // Zoom do 1.4x
                    } 
                    else if (progress > 0.85) { // Faza 3: Powrót kamery na ŚRODEK EKRANU
                        const t = (progress - 0.85) * 6.6; // 0 -> 1
                        
                        // Interpolujemy od Bossa do Środka Ekranu (zamiast do gracza)
                        camera.x = pablobitos.x + (centerScreenX - pablobitos.x) * t;
                        camera.y = pablobitos.y + (centerScreenY - pablobitos.y) * t;
                        
                        camera.zoom = 1.4 - t * 0.4; // Zoom out do 1.0
                    } 
                    else { // Faza 2: Kamera trzyma bossa (Wynurzanie)
                        camera.x = pablobitos.x;
                        camera.y = pablobitos.y;
                        camera.zoom = 1.4;
                        
                        // Tutaj boss się "wynurza" w drawIntroScene, logicznie stoi w miejscu lub idzie bardzo powoli
                        pablobitos.walkFrame += 0.02;
                    }

                    // KONIEC INTRO
                    if (bossIntroTimer <= 0) {
                        pablobitos.isIntro = false;
                        // Reset kamery na środek (0,0 w układzie translate w draw)
                        // W draw() logicznie (0,0) to środek, bo nie przesuwamy nic jeśli nie ma intro
                        camera.x = 0; 
                        camera.y = 0; 
                        camera.zoom = 1.0;
                        
                        document.getElementById('bossContainer').style.display = 'block';
                        document.getElementById('healthPanel').style.display = 'flex';
                    }
                    
                    return; // Przerywamy resztę update dla bossa (nie atakuje w intro)
                } 

                // --- B. TRYB WALKI (Normalny) ---
                const healthPct = pablobitos.health / pablobitos.maxHealth;
                // Wzór: 1.0 (baza) + bonus za brak zdrowia (do +2.0)
                const rageMultiplier = 1.0 + (1.0 - healthPct) * 2.0;
                
                pablobitos.speed = pablobitos.baseSpeed * rageMultiplier;
                
                                // 1. RUCH (Zatrzask na orbicie)
                const houseCX = house.x + house.width / 2;
                const houseCY = house.y + house.height / 2;
                const radiusX = 720; 
                const radiusY = 520;

                // Inicjalizacja flagi (tylko raz)
                if (typeof pablobitos.onOrbit === 'undefined') {
                    pablobitos.onOrbit = false;
                }

                if (!pablobitos.onOrbit) {
                    // --- FAZA 1: DOJŚCIE ---
                    // Obliczamy, gdzie jest najbliższy punkt orbity względem bossa
                    const angleToCenter = Math.atan2(pablobitos.y - houseCY, pablobitos.x - houseCX);
                    
                    const targetX = houseCX + Math.cos(angleToCenter) * radiusX;
                    const targetY = houseCY + Math.sin(angleToCenter) * radiusY;
                    
                    const dx = targetX - pablobitos.x;
                    const dy = targetY - pablobitos.y;
                    const dist = Math.hypot(dx, dy);

                    // Jeśli jest blisko orbity (mniej niż 5px) -> WŁĄCZ ORBITĘ NA STAŁE
                    if (dist < 5) {
                        pablobitos.onOrbit = true;
                        pablobitos.orbitAngle = angleToCenter; // Zapamiętaj kąt wejścia
                    } else {
                        // Idź do orbity
                        pablobitos.x += (dx / dist) * pablobitos.speed;
                        pablobitos.y += (dy / dist) * pablobitos.speed;
                        pablobitos.angle = Math.atan2(dy, dx);
                    }
                } 
                else {
                    // --- FAZA 2: ORBITOWANIE (Już nigdy stąd nie wyjdzie) ---
                    pablobitos.orbitAngle += 0.002; // Prędkość krążenia
                    
                    // Wyliczamy, gdzie ma być w tej klatce
                    const nextX = houseCX + Math.cos(pablobitos.orbitAngle) * radiusX;
                    const nextY = houseCY + Math.sin(pablobitos.orbitAngle) * radiusY;
                    
                    const dx = nextX - pablobitos.x;
                    const dy = nextY - pablobitos.y;
                    const dist = Math.hypot(dx, dy);
                    
                    // Ruch do punktu (płynny)
                    if (dist > 0) {
                        pablobitos.x += (dx / dist) * pablobitos.speed;
                        pablobitos.y += (dy / dist) * pablobitos.speed;
                        pablobitos.angle = Math.atan2(dy, dx);
                    }
                }

                pablobitos.walkFrame += 0.05;
                                                // 1.5 ATAK DYSTANSOWY (PLUCIE)
                if (pablobitos.spitCooldown > 0) {
                    pablobitos.spitCooldown--;
                } else {
                    // Plunięcie!
                    pablobitos.spitCooldown = 60; // Co 4 sekundy
                    screamCooldown: 0;
                    
                    const aimAngle = Math.atan2(player.y - pablobitos.y, player.x - pablobitos.x);
                    const mouthX = pablobitos.x + Math.cos(pablobitos.angle) * 60; // Wylot z ryja
                    const mouthY = pablobitos.y + Math.sin(pablobitos.angle) * 60;

                    // Funkcja pomocnicza
                    const spawnSpit = (size, spread, speed) => {
                        const a = aimAngle + (Math.random() - 0.5) * spread;
                        // Celujemy w miejsce gdzie jest gracz (plus błąd)
                        // Pocisk doleci tam i wybuchnie
                        const dist = Math.hypot(player.x - mouthX, player.y - mouthY);
                        
                        bossProjectiles.push({
                            x: mouthX, y: mouthY,
                            vx: Math.cos(a) * speed, vy: Math.sin(a) * speed,
                            targetDist: dist, // Ile ma przelecieć zanim wybuchnie
                            traveled: 0,      // Ile przeleciał
                            size: size,       // Duży/Mały
                            damage: size === 20 ? 40 : 15 // Obrażenia przy trafieniu bezpośrednim
                        });
                    };

                    // 1. Główny Glut (Duży, Celny, Wolny)
                    spawnSpit(20, 0.0, 7);

                    // 2. Małe Gluty (Małe, Niecelne, Szybsze)
                    spawnSpit(10, 0.5, 10);
                    spawnSpit(10, 0.5, 10);
                }

                                // 1.8 RYK ZAGŁADY (Odrzucenie gracza)
                if (pablobitos.screamCooldown > 0) pablobitos.screamCooldown--;

                // Jeśli gracz jest blisko (180px) i krzyk gotowy
                if (Math.hypot(player.x - pablobitos.x, player.y - pablobitos.y) < 270 && pablobitos.screamCooldown <= 0) {
                    pablobitos.screamCooldown = 240; // Co 4 sekundy
                    
                    // Obliczenie kąta odrzutu
                    const pushAngle = Math.atan2(player.y - pablobitos.y, player.x - pablobitos.x);
                    
                    // A. Fizyczne Odrzucenie (Knockback)
                    const pushForce = 150; 
                    player.x += Math.cos(pushAngle) * pushForce;
                    player.y += Math.sin(pushAngle) * pushForce;
                    
                    // B. Obrażenia (fala uderzeniowa)
                    if (player.invincible <= 0) {
                        let dmg = 20;
                        if (player.armorTier === 2) dmg = 0; // Maska chroni przed ogłuszeniem/krzykiem? (Opcjonalne)
                        player.health -= dmg;
                        player.invincible = 45;
                        createBloodEffect(player.x, player.y, 10); // Gracz krwawi
                    }

                    // C. Efekt wizualny (Dodanie fali do tablicy)
                    shockwaves.push({
                        x: pablobitos.x, y: pablobitos.y,
                        radius: 20, // Startowy rozmiar
                        maxRadius: 300, // Końcowy rozmiar
                        alpha: 1.0,
                        lineWidth: 10
                    });

                    // D. Efekt cząsteczek (Ślina przy ryku)
                    for(let k=0; k<30; k++) {
                        // Rozrzut w stożku w stronę gracza
                        const sprayAngle = pushAngle + (Math.random()-0.5);
                        particles.push({
                            x: pablobitos.x, y: pablobitos.y, 
                            vx: Math.cos(sprayAngle)*12, vy: Math.sin(sprayAngle)*12, 
                            life: 30, maxLife: 30, size: 3, color: '#e3f2fd' // Biała ślina
                        });
                    }
                }

                // 2. KOLIZJA Z GRACZEM (Atak)
                if (Math.hypot(player.x - pablobitos.x, player.y - pablobitos.y) < 80 && player.invincible <= 0) {
                    let dmg = pablobitos.damage;
                    // Redukcja pancerzem
                    if(player.armorTier===1) dmg*=0.7;
                    if(player.armorTier===2) dmg*=0.5;
                    
                    player.health -= dmg;
                    player.invincible = 60;
                    createBloodEffect(player.x, player.y, 20);
                }

                // 3. KOLIZJA Z POCISKAMI (Boss sam sprawdza pociski)
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const b = bullets[i];
                    // Duży hitbox (90px)
                    if (Math.hypot(b.x - pablobitos.x, b.y - pablobitos.y) < 90) {
                        pablobitos.health -= b.damage;
                        createBloodEffect(b.x, b.y, 15);
                        b.life = 0; // Zniszcz pocisk (boss jest twardy, nie przepuszcza nawet snajperki)
                        bullets.splice(i, 1); 
                    }
                }

                // 4. KOLIZJA Z FORTYFIKACJAMI (Boss je niszczy)
                for (let i = fortifications.length - 1; i >= 0; i--) {
                    const fort = fortifications[i];
                    // Hitbox kolizji z budynkiem
                    if (Math.hypot(fort.x - pablobitos.x, fort.y - pablobitos.y) < fort.radius + 90) {
                        pablobitos.health -= fort.damage;
                        fort.health -= 2.0; // Boss niszczy je bardzo szybko
                        
                        // Spowolnienie (Boss jest odporny, zwalnia tylko w drucie)
                        if (fort.type === 'wire') pablobitos.speed = 0.2; 
                    }
                }

                // 5. KOLIZJA Z LISAMI
                if (foxStation.tier > 0) {
                    foxStation.foxes.forEach(fox => {
                        // Oblicz pozycję lisa (z uwzględnieniem pulsowania z update)
                        const pulse = Math.sin(gameTime * 0.1) * 25;
                        const orbitR = 100 + pulse;
                        
                        const fx = player.x + Math.cos(fox.angle) * orbitR;
                        const fy = player.y + Math.sin(fox.angle) * orbitR;
                        
                        if (Math.hypot(fx - pablobitos.x, fy - pablobitos.y) < 90) {
                            pablobitos.health -= 2.0; // Lis gryzie
                            if (Math.random() < 0.1) createBloodEffect(pablobitos.x, pablobitos.y, 5);
                        }
                    });
                }

                // 6. UI ZDROWIA
                const pct = Math.max(0, (pablobitos.health / pablobitos.maxHealth) * 100);
                document.getElementById('bossHealthFill').style.width = `${pct}%`;

                // 7. ŚMIERĆ
                if (pablobitos.health <= 0) {
                    // Efekty Gore
                    createBloodEffect(pablobitos.x, pablobitos.y, 150);
                    for(let i=0; i<25; i++) meatChunks.push({
                        x:pablobitos.x, y:pablobitos.y, 
                        vx:(Math.random()-0.5)*15, vy:(Math.random()-0.5)*15, 
                        rot:Math.random(), rotSpeed:0.1, size:10+Math.random()*10, life:1200
                    });
                    
                    // Wielki szkielet
                    corpses.push({
                        x:pablobitos.x, y:pablobitos.y, angle:pablobitos.angle, 
                        type:'boss', life:1200
                    });
                    
                    // Mega Drop
                    scrapPickups.push({x:pablobitos.x, y:pablobitos.y, amount:100, visuals:[{dx:0,dy:0,type:'gear',rot:0}], pulsePhase:0});
                    ammoPickups.push({x:pablobitos.x+30, y:pablobitos.y, amount:20, pulsePhase:0});
                    medkitPickups.push({x:pablobitos.x-30, y:pablobitos.y, pulsePhase:0});

                    pablobitos = null; // Usunięcie obiektu -> Koniec walki
                }
            }
              // ============================================================
            // ZARZĄDZANIE FALAMI (Wave Management)
            // ============================================================
            
            // 1. PRZERWA MIĘDZY FALAMI
            if (waveDelay > 0) {
                waveDelay--;
                
                document.getElementById('waveTimerPanel').style.display = 'block';
                document.getElementById('timerText').textContent = `KOLEJNA FALA ZA: ${Math.ceil(waveDelay / 60)}s`;

                if (waveDelay === 0) {
                    showWaveAnnouncement();
                    document.getElementById('waveTimerPanel').style.display = 'none';
                }
            } 
            else {
                document.getElementById('waveTimerPanel').style.display = 'none';

                // --- SPECJALNA FALA Z BOSSEM (DEBUG: FALA 1) ---
                // Zmień 'wave === 1' na 'wave === 10' jak skończysz testy
                                // --- SPECJALNA FALA Z BOSSEM (FALA 1/10) ---
                if (wave === 10) { 
                    
                    // A. Spawn Bossa (Jednorazowo na start)
                    if (!pablobitos && !bossEncountered) {
                        pablobitos = {
                            x: -300, y: gameCanvas.height/2,
                            width: 180, height: 140,
                            health: 25000, maxHealth: 25000,
                            speed: 0.6, baseSpeed: 0.6, speedMult: 1,
                            angle: 0, walkFrame: 0,
                            damage: 80, stun: 0,
                            isIntro: true,
                            spitCooldown: 120,
                            screamCooldown: 0,
                            summonCooldown: 0 
                        };
                        bossEncountered = true;
                        bossIntroTimer = bossIntroDuration;
                        
                        // Na start dajemy mu obstawę
                        boarsToSpawn = 5; 
                    }

                    // B. Spawn Zwykłych Dzików (Z pętli)
                    if (!pablobitos || !pablobitos.isIntro) { // Czekaj na koniec intro
                        if (boarsToSpawn > 0) {
                            spawnTimer++;
                            if (spawnTimer >= 30) {
                                spawnBoar();
                                boarsToSpawn--;
                                spawnTimer = 0;
                            }
                        }
                        // C. PRZYZYWANIE POSIŁKÓW (Nieskończone dziki, dopóki boss żyje)
                        // Jeśli nie ma dzików do zespawnowania I nie ma dzików na mapie I boss wciąż żyje
                        else if (boars.length === 0 && pablobitos) {
                            // Jeśli cooldown minął -> przyzwij
                            if (pablobitos.summonCooldown <= 0) {
                                boarsToSpawn = 10;
                                pablobitos.summonCooldown = 1200; // 20 sekund (120 * 10)
                                showPickupNotification("Pablobitos wzywa posiłki!");
                            } 
                            // Jeśli cooldown trwa -> odliczaj
                            else {
                                pablobitos.summonCooldown--;
                            }
                        }
                    }
                    
                    // D. WARUNEK KOŃCA FALI BOSSA
                    // Fala kończy się TYLKO, gdy boss nie żyje (jest null)
                    // (Dziki zginą same, albo zostaną wyczyszczone, to bez znaczenia, ważne że boss padł)
                    if (bossEncountered && !pablobitos) {
                        // Boss pokonany!

                        if (boars.length === 0) { // Czekamy aż gracz dobije resztki
                            document.getElementById('bossContainer').style.display = 'none';
                            bossEncountered = false;
                            
                            wave++;
                            boarsToSpawn = 5 + wave * 4;
                            waveDelay = 2400; 
                        }
                    }
                }
                
                // --- ZWYKŁE FALE ---
                else {
                    // A. Spawn
                    if (boarsToSpawn > 0) {
                        spawnTimer++;
                        if (spawnTimer >= Math.max(30, 80 - wave * 5)) {
                            spawnBoar();
                            boarsToSpawn--;
                            spawnTimer = 0;
                        }
                    } 
                    // B. Koniec zwykłej fali (Tylko dziki muszą zginąć)
                    else if (boars.length === 0) {
                        wave++;
                        boarsToSpawn = 5 + wave * 4;
                        waveDelay = 2400; 
                    }
                }
            }
            // Check game over
            if (player.health <= 0 || house.health <= 0) {
                endGame(player.health <= 0 ? 'Maciej padł pod nawałą dzików...' : 'Leśniczówka legła w gruzach...');
            }

            // Update UI
            updateUI();
        }
        function updateUI() {
                        const slots = document.querySelectorAll('.med-slot');
            // Pętla po 5 slotach
            for (let i = 0; i < 5; i++) {
                if (i < player.medkits) {
                    slots[i].classList.add('filled'); // Pokaż apteczkę
                } else {
                    slots[i].classList.remove('filled'); // Pusty slot
                }
            }
            // 1. GRACZ (Serce)
const hpPct = Math.max(0, Math.round(player.health));
const hpBox = document.getElementById('playerHeartBox');
const hpFill = document.getElementById('playerHpFill');

// Ustaw CSS variable dla animacji
const hpOffset = 100 - hpPct;
hpFill.style.setProperty('--hp-offset', `${hpOffset}%`);
hpFill.style.transform = `translateY(${hpOffset}%)`;

document.getElementById('hpText').textContent = hpPct;

// Chybotanie gdy HP spada
if (hpPct < lastPlayerHealth) {
    hpFill.classList.remove('sloshing');
    void hpFill.offsetWidth; // Reset animacji
    hpFill.classList.add('sloshing');
}
lastPlayerHealth = hpPct;

// Bicie serca
if (hpPct <= 30) hpBox.classList.add('critical');
else hpBox.classList.remove('critical');

// W updateUI() - sekcja VAPE:
const vapePct = Math.max(0, Math.round(player.vapeCharge));
const vapeBox = document.getElementById('vapeBox');
const vapeLiquid = document.getElementById('vapeLiquid');
const vapeText = document.getElementById('vapeText');

// Wypełnienie zbiornika
const vapeOffset = 100 - vapePct;
vapeLiquid.style.setProperty('--vape-offset', `${vapeOffset}%`);
vapeLiquid.style.transform = `translateY(${vapeOffset}%)`;

// Tekst - FULL lub procent
if (vapePct >= 100) {
    vapeText.textContent = 'FULL';
    vapeBox.classList.add('full');
} else {
    vapeText.textContent = vapePct;
    vapeBox.classList.remove('full');
}

// Chybotanie gdy wartość się zmienia
if (vapePct !== lastVapeCharge) {
    vapeLiquid.classList.remove('sloshing');
    void vapeLiquid.offsetWidth;
    vapeLiquid.classList.add('sloshing');
}
lastVapeCharge = vapePct;

// W updateUI() - sekcja DOM:
const housePct = Math.max(0, Math.round((house.health / house.maxHealth) * 100));
const houseBox = document.getElementById('houseBox');
const houseLeds = houseBox.querySelectorAll('.tablet-led');

document.getElementById('houseText').textContent = housePct + '%';

// Status kolorów
houseBox.classList.remove('status-good', 'status-warning', 'status-critical');
if (housePct > 60) {
    houseBox.classList.add('status-good');
    houseLeds[0].classList.add('active');
    houseLeds[1].classList.add('active');
    houseLeds[2].classList.add('active');
} else if (housePct > 30) {
    houseBox.classList.add('status-warning');
    houseLeds[0].classList.add('active');
    houseLeds[1].classList.add('active');
    houseLeds[2].classList.remove('active');
} else {
    houseBox.classList.add('status-critical');
    houseLeds[0].classList.add('active');
    houseLeds[1].classList.remove('active');
    houseLeds[2].classList.remove('active');
}

// Glitch effect przy otrzymaniu obrażeń
if (housePct < lastHouseHealth) {
    houseBox.classList.remove('damage-flash');
    void houseBox.offsetWidth;
    houseBox.classList.add('damage-flash');
}
lastHouseHealth = housePct;

// --- AMUNICJA (MAGAZYNKI) ---
const mag1 = document.getElementById('mag1');
const mag2 = document.getElementById('mag2');
const mag3 = document.getElementById('mag3');

// Odblokowywanie magazynków wg Tieru
if (player.sniperTier >= 1) {
    if (mag2.classList.contains('locked')) {
        mag2.classList.remove('locked');
        mag2.classList.add('appearing');
        setTimeout(() => mag2.classList.remove('appearing'), 500);
    }
} else {
    mag2.classList.add('locked');
}

if (player.sniperTier >= 2) {
    if (mag3.classList.contains('locked')) {
        mag3.classList.remove('locked');
        mag3.classList.add('appearing');
        setTimeout(() => mag3.classList.remove('appearing'), 500);
    }
} else {
       mag3.classList.add('locked');
}

// Pobierz wszystkie sloty z ODBLOKOWANYCH magazynków
const allSlots = document.querySelectorAll('.ammo-mag:not(.locked) .bullet-slot');
const currentAmmo = player.sniperAmmo;

// Wypełnij nabojami
for (let i = 0; i < allSlots.length; i++) {
    if (i < currentAmmo) {
        allSlots[i].classList.add('filled');
    } else {
        allSlots[i].classList.remove('filled');
    }
}

// Aktualizuj sprężyny
const mags = [mag1, mag2, mag3];
let ammoLeft = currentAmmo;

mags.forEach(mag => {
    if (mag.classList.contains('locked')) return;

    const spring = mag.querySelector('.mag-spring');
    const bulletsInMag = Math.min(5, ammoLeft);
    ammoLeft -= bulletsInMag;

    const emptySlots = 5 - bulletsInMag;
    const springHeight = emptySlots * 28;
    spring.style.setProperty('--spring-height', springHeight + 'px');
});

            let tierName = "";
            if (player.weapon === 'revolver') tierName = player.revolverTier === 0 ? "Podstawowy" : (player.revolverTier === 1 ? "Dwulufowy" : "Seria");
            else tierName = player.sniperTier === 0 ? "Myśliwska" : (player.sniperTier === 1 ? ".50 Cal" : "Gauss");
            document.getElementById('scrapCount').textContent = `Złom: ${player.scrap}`;
            
            const romanNumerals = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X'];
            const waveNum = wave <= 10 ? romanNumerals[wave-1] : wave;
            document.getElementById('waveCount').textContent = `Fala ${waveNum}`;
            document.getElementById('killCount').textContent = `Eliminacje: ${kills}`;
        }

        function endGame(reason) {
            gameOver = true;
            const romanNumerals = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 
                                   'XI', 'XII', 'XIII', 'XIV', 'XV', 'XVI', 'XVII', 'XVIII', 'XIX', 'XX'];
            document.getElementById('gameOverScreen').style.display = 'flex';
            document.getElementById('gameOverReason').textContent = reason;
            document.getElementById('gameOverStats').textContent = `Eliminacje: ${kills} | Fala: ${romanNumerals[Math.min(wave - 1, 19)]}`;
        }

        // ==================== RENDERING ====================
        function draw() {
            // Clear and draw background
            drawBackground();

                        // --- TŁO (Zawsze statyczne, na cały ekran) ---
            const skyGrad = ctx.createLinearGradient(0, 0, 0, gameCanvas.height); skyGrad.addColorStop(0, '#1a1520'); skyGrad.addColorStop(1, '#0f1810');
            ctx.fillStyle = skyGrad; ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
            ctx.fillStyle = '#1a2515'; ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

       // ========================================================
            // START KAMERY
            // ========================================================
            ctx.save();
            
            // Domyślna kamera (statyczna, wycentrowana na środku ekranu/domu)
            // Zakładamy, że "środek świata" (0,0) w Twoim kodzie to lewy górny róg canvasa, 
            // a gra dzieje się na obszarze jednego ekranu.
            // Więc normalnie nie przesuwamy nic (camX=0, camY=0).
            
            let camX = 0;
            let camY = 0;
            let camZoom = 1.0;

            // Tylko podczas INTRO kamera się rusza
            if (pablobitos && pablobitos.isIntro) {
                // Centrowanie zooma
                ctx.translate(gameCanvas.width/2, gameCanvas.height/2);
                ctx.scale(camera.zoom, camera.zoom);
                ctx.translate(-gameCanvas.width/2, -gameCanvas.height/2);
                
                // Przesunięcie na bossa
                // Jeśli normalnie boss jest na x=-200, a ekran ma width=1920, to boss jest poza ekranem.
                // Musimy przesunąć świat w prawo, żeby boss wszedł w kadr.
                // camera.x w update() to pozycja, na którą patrzymy.
                // Żeby ta pozycja była na środku ekranu (width/2), musimy przesunąć świat o:
                // (width/2) - camera.x
                
                camX = (gameCanvas.width/2) - camera.x;
                camY = (gameCanvas.height/2) - camera.y;
                
                ctx.translate(camX, camY);
            }
            // ========================================================
            // ... (TU JEST TWÓJ CAŁY STARY KOD RYSOWANIA ŚWIATA: krew, pickupy, dom, gracze, pociski...) ...
            
            // Draw blood splatters on ground
            bloodSplatters.forEach(splat => {
                ctx.fillStyle = `rgba(60, 0, 0, ${splat.opacity * 0.5})`;
                ctx.beginPath();
                ctx.ellipse(splat.x, splat.y, splat.size, splat.size * 0.6, Math.random() * 0.5, 0, Math.PI * 2);
                ctx.fill();
            });

                        // RYSOWANIE ZWŁOK (SZKIELETY)
            corpses.forEach(c => {
                ctx.save();
                ctx.translate(c.x, c.y);
                // Odbicie lustrzane jeśli dzik szedł w lewo (zachowuje logikę drawBoar)
                if (Math.cos(c.angle) < 0) ctx.scale(-1, 1);
                
                // Zanikanie pod koniec czasu
                ctx.globalAlpha = Math.min(1, c.life / 60);

                // Skala zależna od typu
                const sc = c.type === 'boss' ? 1.5 : (c.type === 'charger' ? 0.8 : 1.0);
                ctx.scale(sc, sc);

                // Kolor kości
                ctx.fillStyle = '#e0e0e0'; 
                
                // Czaszka
                ctx.beginPath();
                ctx.moveTo(15, 0); // Ryj
                ctx.lineTo(5, -8); // Czoło
                ctx.lineTo(-5, -5); // Tył czaszki
                ctx.lineTo(-5, 5); // Szczęka
                ctx.lineTo(10, 8); 
                ctx.fill();
                
                // Oczodół (Pusty)
                ctx.fillStyle = '#111';
                ctx.beginPath(); ctx.arc(5, -2, 2, 0, Math.PI*2); ctx.fill();

                // Żebra (Leżące płasko)
                ctx.strokeStyle = '#e0e0e0'; ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(-10, 0); ctx.lineTo(-25, 0); // Kręgosłup
                ctx.stroke();
                
                // Kilka żeber
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(-12, -5); ctx.lineTo(-12, 5); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(-18, -4); ctx.lineTo(-18, 4); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(-24, -3); ctx.lineTo(-24, 3); ctx.stroke();

                // Kości nóg (połamane)
                ctx.strokeStyle = '#d7ccc8';
                ctx.beginPath(); ctx.moveTo(-20, 2); ctx.lineTo(-25, 10); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(10, 5); ctx.lineTo(15, 12); ctx.stroke();

                ctx.restore();
            });
            ctx.globalAlpha = 1; // Reset alpha

// RYSOWANIE MIĘSA
meatChunks.forEach(m => {
    ctx.save();
    ctx.translate(m.x, m.y);
    ctx.rotate(m.rot);
    ctx.globalAlpha = Math.min(1, m.life / 60);
    
    const s = m.size * 1.8; // 2.5x większe
    
    // ==================== GŁÓWNY KAWAŁEK MIĘSA ====================
    // Zewnętrzna warstwa - ciemniejsza
    ctx.fillStyle = '#5a0a0a';
    ctx.beginPath();
    ctx.moveTo(-s * 0.9, -s * 0.3);
    ctx.quadraticCurveTo(-s * 0.7, -s * 0.8, -s * 0.1, -s * 0.7);
    ctx.quadraticCurveTo(s * 0.4, -s * 0.9, s * 0.8, -s * 0.4);
    ctx.quadraticCurveTo(s * 1.0, s * 0.1, s * 0.7, s * 0.5);
    ctx.quadraticCurveTo(s * 0.3, s * 0.9, -s * 0.3, s * 0.7);
    ctx.quadraticCurveTo(-s * 0.8, s * 0.5, -s * 0.9, -s * 0.3);
    ctx.closePath();
    ctx.fill();
    
    // Środkowa warstwa - główne mięso
    ctx.fillStyle = '#8b0000';
    ctx.beginPath();
    ctx.moveTo(-s * 0.7, -s * 0.2);
    ctx.quadraticCurveTo(-s * 0.5, -s * 0.6, 0, -s * 0.5);
    ctx.quadraticCurveTo(s * 0.4, -s * 0.6, s * 0.6, -s * 0.2);
    ctx.quadraticCurveTo(s * 0.7, s * 0.2, s * 0.5, s * 0.4);
    ctx.quadraticCurveTo(s * 0.2, s * 0.6, -s * 0.2, s * 0.5);
    ctx.quadraticCurveTo(-s * 0.6, s * 0.4, -s * 0.7, -s * 0.2);
    ctx.closePath();
    ctx.fill();
    
    // ==================== TEKSTURA MIĘSA ====================
    // Włókna mięsne
    ctx.strokeStyle = '#6a0000';
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    
    // Włókno 1
    ctx.beginPath();
    ctx.moveTo(-s * 0.5, -s * 0.3);
    ctx.quadraticCurveTo(-s * 0.2, -s * 0.25, s * 0.2, -s * 0.3);
    ctx.stroke();
    
    // Włókno 2
    ctx.beginPath();
    ctx.moveTo(-s * 0.4, 0);
    ctx.quadraticCurveTo(0, s * 0.05, s * 0.4, -s * 0.05);
    ctx.stroke();
    
    // Włókno 3
    ctx.beginPath();
    ctx.moveTo(-s * 0.3, s * 0.25);
    ctx.quadraticCurveTo(s * 0.1, s * 0.3, s * 0.35, s * 0.2);
    ctx.stroke();
    
    // ==================== POŁYSK (wilgotność) ====================
    ctx.fillStyle = '#a52a2a';
    ctx.beginPath();
    ctx.ellipse(-s * 0.2, -s * 0.25, s * 0.15, s * 0.08, -0.3, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#aa3030';
    ctx.beginPath();
    ctx.ellipse(s * 0.15, s * 0.1, s * 0.1, s * 0.06, 0.5, 0, Math.PI * 2);
    ctx.fill();
    
    // ==================== CIEMNE ZAGŁĘBIENIA ====================
    ctx.fillStyle = '#4a0505';
    ctx.beginPath();
    ctx.ellipse(s * 0.3, -s * 0.15, s * 0.08, s * 0.05, 0.2, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.beginPath();
    ctx.ellipse(-s * 0.35, s * 0.15, s * 0.06, s * 0.04, -0.4, 0, Math.PI * 2);
    ctx.fill();
    
    // ==================== KRAWĘDŹ (surowe mięso) ====================
    ctx.strokeStyle = '#3a0505';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-s * 0.9, -s * 0.3);
    ctx.quadraticCurveTo(-s * 0.7, -s * 0.8, -s * 0.1, -s * 0.7);
    ctx.quadraticCurveTo(s * 0.4, -s * 0.9, s * 0.8, -s * 0.4);
    ctx.quadraticCurveTo(s * 1.0, s * 0.1, s * 0.7, s * 0.5);
    ctx.quadraticCurveTo(s * 0.3, s * 0.9, -s * 0.3, s * 0.7);
    ctx.quadraticCurveTo(-s * 0.8, s * 0.5, -s * 0.9, -s * 0.3);
    ctx.closePath();
    ctx.stroke();
    
    ctx.restore();
});
 ctx.globalAlpha = 1;
			
			            // 1. RYSOWANIE PLACEHOLDERÓW
            if (waveDelay > 0) {
                fortSlots.forEach(slot => {
                    if (!slot.built) {
                        const dist = Math.hypot(player.x - slot.x, player.y - slot.y);
                        const alpha = dist < 60 ? 0.8 : 0.3;
                        
                        ctx.save();
                        ctx.translate(slot.x, slot.y);
                        if (slot.isVertical) ctx.rotate(Math.PI / 2); // Obrót dla pionowych

                        // Rysowanie zależne od typu
                        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);

                        if (slot.type === 'wire') {
                            // Placeholder Drutu (3x większy)
                            ctx.strokeRect(-120, -10, 240, 20); // Było -40, 80
                            // Słupki
                            ctx.strokeRect(-120, -36, 18, 72);  // Było -40, -12, 6, 24
                            ctx.strokeRect(102, -36, 18, 72);   // Było 34, -12, 6, 24
                        } else {
                            // Placeholder Kolców (Koło)
                            ctx.beginPath();
                            ctx.arc(0, 0, 25, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        ctx.setLineDash([]);

                        // Tekst kosztu
                        if (dist < 60) {
                            ctx.fillStyle = player.scrap >= slot.cost ? '#00ff00' : '#ff0000';
                            ctx.font = '12px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText(`[R] - ${slot.cost} Złom`, 0, 40);
                        }
                        ctx.restore();
                    }
                });
            }

                    function drawTurret() {
            // --- PLACEHOLDER (Duch przed zbudowaniem) ---
            if (turret.tier === 0) {
                if (waveDelay > 0) {
                    const dist = Math.hypot(player.x - turret.x, player.y - turret.y);
                    const alpha = dist < 60 ? 0.8 : 0.3;
                    
                    ctx.save();
                    ctx.translate(turret.x, turret.y);
                    
                    // Okrąg zasięgu/bazy (2x większy)
                    ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.lineWidth = 3;
                    ctx.setLineDash([8, 8]);
                    ctx.beginPath(); ctx.arc(0, 0, 40, 0, Math.PI * 2); ctx.stroke(); // Promień 40 zamiast 20
                    
                    // Krzyżyk w środku
                    ctx.beginPath();
                    ctx.moveTo(-20, 0); ctx.lineTo(20, 0);
                    ctx.moveTo(0, -20); ctx.lineTo(0, 20);
                    ctx.stroke();
                    
                    ctx.setLineDash([]); // Reset linii

                    if (dist < 60) {
                        ctx.fillStyle = player.scrap >= turret.costs[0] ? '#00ff00' : '#ff0000';
                        ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center';
                        ctx.fillText(`[R] Wieżyczka: ${turret.costs[0]} Złom`, 0, 60);
                    }
                    ctx.restore();
                }
                return;
            }

            // --- RYSOWANIE ZBUDOWANEJ WIEŻYCZKI ---
            ctx.save();
            ctx.translate(turret.x, turret.y);

            // Podstawa (Beton/Stal) - Wspólna, duża
            ctx.fillStyle = '#2a2a2a';
            ctx.beginPath(); ctx.arc(0, 0, 32, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#111'; ctx.lineWidth = 4; ctx.stroke();
            
            // Nity na podstawie
            ctx.fillStyle = '#555';
            for(let i=0; i<6; i++) {
                const ang = (i/6) * Math.PI*2;
                ctx.beginPath(); ctx.arc(Math.cos(ang)*24, Math.sin(ang)*24, 3, 0, Math.PI*2); ctx.fill();
            }

            // Obrót lufy w stronę celu
            ctx.rotate(turret.angle);

                        // --- EFEKT ODRZUTU (Cofnięcie lufy) ---
            ctx.translate(-turret.recoil, 0); 

            // Cień lufy
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(10, 10, 60, 20);

            if (turret.tier === 1) { 
                // === TIER 1: STEAMPUNK (Miedź i Para) ===
                
                // Tylny zbiornik
                ctx.fillStyle = '#8b4513'; // Brąz
                ctx.beginPath(); ctx.arc(-10, 0, 22, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = '#cd7f32'; ctx.lineWidth = 2; ctx.stroke();

                // Główna lufa (Miedziana cewka)
                const barrelLen = 50;
                ctx.fillStyle = '#b87333'; // Miedź
                ctx.fillRect(0, -12, barrelLen, 24);
                
                // Pierścienie na lufie
                ctx.strokeStyle = '#8b4513'; ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(10, -12); ctx.lineTo(10, 12);
                ctx.moveTo(25, -12); ctx.lineTo(25, 12);
                ctx.moveTo(40, -12); ctx.lineTo(40, 12);
                ctx.stroke();

                // Wylot
                ctx.fillStyle = '#111';
                ctx.fillRect(barrelLen, -8, 6, 16);

                // Ozdobna zębatka na górze
                ctx.fillStyle = '#ffd700';
                ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#b87333'; ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI*2); ctx.fill();
            } 
            else if (turret.tier === 2) { 
                // === TIER 2: WW1 (Ciężki Maxim Gun) ===
                
                // Skrzynka z amunicją (z boku)
                ctx.fillStyle = '#3e4b35'; // Ciemna zieleń
                ctx.fillRect(-10, 14, 20, 14); 
                ctx.strokeStyle = '#2a3022'; ctx.strokeRect(-10, 14, 20, 14);

                // Korpus zamka
                ctx.fillStyle = '#2f4f4f'; // Ciemnoszary
                ctx.fillRect(-20, -15, 30, 30);
                
                // Gruba lufa (chłodnica wodna)
                ctx.fillStyle = '#556b2f'; // Olive Drab
                ctx.fillRect(10, -14, 60, 28); // Długa i gruba
                
                // Detale lufy (korek wlewu wody)
                ctx.fillStyle = '#333';
                ctx.beginPath(); ctx.arc(20, -8, 3, 0, Math.PI*2); ctx.fill();

                // Wylot lufy
                ctx.fillStyle = '#111';
                ctx.fillRect(70, -4, 8, 8);

                // Tarcza ochronna (płaska linia prostopadła)
                ctx.fillStyle = '#4b5320';
                ctx.fillRect(5, -30, 4, 60);
                ctx.strokeStyle = '#222'; ctx.strokeRect(5, -30, 4, 60);
            } 
            else if (turret.tier === 3) { 
                // === TIER 3: WW2 (Flakvierling / Anti-Air) ===
                
                // Korpus (Opancerzony)
                ctx.fillStyle = '#708090'; // Slate Grey (Stal)
                ctx.beginPath();
                ctx.moveTo(-25, -20); ctx.lineTo(10, -15); ctx.lineTo(10, 15); ctx.lineTo(-25, 20);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = '#2f4f4f'; ctx.lineWidth = 2; ctx.stroke();

                // Dwa długie działa
                ctx.fillStyle = '#2f2f2f'; // Ciemna stal
                // Lewe
                ctx.fillRect(5, -18, 70, 10);
                // Prawe
                ctx.fillRect(5, 8, 70, 10);

                // Hamulce wylotowe (końcówki luf)
                ctx.fillStyle = '#111';
                ctx.fillRect(75, -20, 12, 14); // Lewy
                ctx.fillRect(75, 6, 12, 14);  // Prawy

                // Magazynki (od góry)
                ctx.fillStyle = '#333';
                ctx.fillRect(-5, -22, 20, 44); // Centralny blok zasilania
                
                // Oznaczenie (Biały pasek/Gwiazda)
                ctx.fillStyle = '#ddd';
                ctx.fillRect(-15, -5, 10, 10);
            }

            ctx.restore();

            // Info o ulepszeniu (Unosi się nad wieżyczką w przerwie)
            if (waveDelay > 0 && turret.tier < 3) {
                const dist = Math.hypot(player.x - turret.x, player.y - turret.y);
                if (dist < 60) {
                    const cost = turret.costs[turret.tier];
                    ctx.fillStyle = player.scrap >= cost ? '#00ff00' : '#ff0000';
                    ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center';
                    
                    ctx.fillStyle = player.scrap >= cost ? '#00ff00' : '#ff0000';
                    ctx.fillText(`[R] Ulepsz: ${cost} Złom`, turret.x, turret.y + 63);
                }
            }
        }

            // 2. RYSOWANIE ZBUDOWANYCH FORTYFIKACJI
            fortifications.forEach(fort => {
                ctx.save();
                ctx.translate(fort.x, fort.y);
                if (fort.isVertical) ctx.rotate(Math.PI / 2);

                const damageScale = fort.health / fort.maxHealth; 

                                if (fort.type === 'wire') {
                    // --- DRUT KOLCZASTY (3x WIĘKSZY) ---
                    // Słupki (3x szersze i wyższe)
                    ctx.fillStyle = '#3a2515'; 
                    ctx.fillRect(-120, -36, 18, 72); 
                    ctx.fillRect(102, -36, 18, 72);
                    
                    // Druty (3 linie)
                    ctx.strokeStyle = '#888888';
                    ctx.lineWidth = 2;
                    for(let i=0; i<3; i++) {
                        const yOff = -24 + i * 24; // Większe odstępy
                        ctx.beginPath();
                        ctx.moveTo(-111, yOff); // Od lewego słupka
                        // Dłuższy drut
                        ctx.quadraticCurveTo(0, yOff + (1-damageScale)*30, 111, yOff);
                        ctx.stroke();
                        
                        // Więcej kolców na drucie
                        for(let j=1; j<10; j++) { // Więcej iteracji
                            const xPos = -110 + j*22;
                            ctx.beginPath();
                            ctx.moveTo(xPos - 5, yOff - 5); ctx.lineTo(xPos + 5, yOff + 5);
                            ctx.moveTo(xPos + 5, yOff - 5); ctx.lineTo(xPos - 5, yOff + 5);
                            ctx.stroke();
                        }
                    }
                } else {
                    // --- KOLCE (Stary kod) ---
                    ctx.fillStyle = 'rgba(0,0,0,0.4)';
                    ctx.beginPath(); ctx.ellipse(0, 10, 25, 8, 0, 0, Math.PI*2); ctx.fill();

                    ctx.strokeStyle = '#5c4033';
                    ctx.lineWidth = 4;
                    for(let i=0; i<3; i++) {
                        ctx.save();
                        ctx.rotate(i + 1);
                        ctx.beginPath();
                        ctx.moveTo(-15 * damageScale, 10);
                        ctx.lineTo(15 * damageScale, -15 * damageScale);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(15 * damageScale, 10);
                        ctx.lineTo(-15 * damageScale, -15 * damageScale);
                        ctx.stroke();
                        ctx.fillStyle = '#8b5a2b';
                        ctx.beginPath();
                        ctx.moveTo(15 * damageScale, -15 * damageScale);
                        ctx.lineTo(13 * damageScale, -10 * damageScale);
                        ctx.lineTo(17 * damageScale, -10 * damageScale);
                        ctx.fill();
                        ctx.restore();
                    }
                }
                
                // Pasek życia (wspólny)
                if (fort.health < fort.maxHealth) {
                    ctx.fillStyle = 'red';
                    ctx.fillRect(-15, -25, 30, 4);
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(-15, -25, 30 * (fort.health/fort.maxHealth), 4);
                }

                ctx.restore();
            });

// Draw ammo pickups
ammoPickups.forEach(pickup => {
    const pulse = Math.sin(pickup.pulsePhase) * 0.3 + 0.7;
    
    ctx.save();
    ctx.translate(pickup.x, pickup.y);
    
    const w = 48;
    const h = 32;
    
    // ==================== CIEŃ ====================
    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
    ctx.beginPath();
    ctx.ellipse(0, h/2 + 4, w/2 - 2, 6, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // ==================== GŁÓWNA SKRZYNKA ====================
    // Spód skrzynki
    ctx.fillStyle = '#2a3025';
    ctx.fillRect(-w/2, -h/2 + 4, w, h - 4);
    
    // Główny korpus
    const boxGrad = ctx.createLinearGradient(0, -h/2, 0, h/2);
    boxGrad.addColorStop(0, '#4a5040');
    boxGrad.addColorStop(0.3, '#3d4235');
    boxGrad.addColorStop(0.7, '#353a30');
    boxGrad.addColorStop(1, '#2a2f25');
    ctx.fillStyle = boxGrad;
    ctx.fillRect(-w/2, -h/2, w, h);
    
    // ==================== METALOWE KRAWĘDZIE ====================
    ctx.fillStyle = '#5a5a50';
    ctx.fillRect(-w/2, -h/2, w, 3);
    
    ctx.fillStyle = '#3a3a30';
    ctx.fillRect(-w/2, h/2 - 3, w, 3);
    
    const leftEdgeGrad = ctx.createLinearGradient(-w/2, 0, -w/2 + 4, 0);
    leftEdgeGrad.addColorStop(0, '#5a5a50');
    leftEdgeGrad.addColorStop(1, '#4a5040');
    ctx.fillStyle = leftEdgeGrad;
    ctx.fillRect(-w/2, -h/2, 4, h);
    
    const rightEdgeGrad = ctx.createLinearGradient(w/2 - 4, 0, w/2, 0);
    rightEdgeGrad.addColorStop(0, '#4a5040');
    rightEdgeGrad.addColorStop(1, '#3a3a30');
    ctx.fillStyle = rightEdgeGrad;
    ctx.fillRect(w/2 - 4, -h/2, 4, h);
    
    // ==================== METALOWE NAROŻNIKI ====================
    ctx.fillStyle = '#6a6a5a';
    ctx.fillRect(-w/2, -h/2, 8, 6);
    ctx.fillRect(-w/2, -h/2, 6, 8);
    ctx.fillRect(w/2 - 8, -h/2, 8, 6);
    ctx.fillRect(w/2 - 6, -h/2, 6, 8);
    ctx.fillRect(-w/2, h/2 - 6, 8, 6);
    ctx.fillRect(-w/2, h/2 - 8, 6, 8);
    ctx.fillRect(w/2 - 8, h/2 - 6, 8, 6);
    ctx.fillRect(w/2 - 6, h/2 - 8, 6, 8);
    
    // ==================== NITY ====================
    ctx.fillStyle = '#7a7a6a';
    const rivetPositions = [
        [-w/2 + 4, -h/2 + 4],
        [w/2 - 4, -h/2 + 4],
        [-w/2 + 4, h/2 - 4],
        [w/2 - 4, h/2 - 4]
    ];
    rivetPositions.forEach(([rx, ry]) => {
        ctx.beginPath();
        ctx.arc(rx, ry, 2.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#4a4a40';
        ctx.beginPath();
        ctx.arc(rx + 0.5, ry + 0.5, 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#7a7a6a';
    });
    
    // ==================== POZIOME WGŁĘBIENIA ====================
    ctx.strokeStyle = '#2a2f25';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-w/2 + 10, -h/2 + 10);
    ctx.lineTo(w/2 - 10, -h/2 + 10);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(-w/2 + 10, h/2 - 10);
    ctx.lineTo(w/2 - 10, h/2 - 10);
    ctx.stroke();
    
    // ==================== 3 POCISKI ====================
    const bulletPositions = [-10, 0, 10];
    
    bulletPositions.forEach((bx) => {
        // Łuska
        ctx.fillStyle = '#c9a227';
        ctx.beginPath();
        ctx.moveTo(bx - 3, 8);
        ctx.lineTo(bx - 3, 0);
        ctx.lineTo(bx + 3, 0);
        ctx.lineTo(bx + 3, 8);
        ctx.closePath();
        ctx.fill();
        
        // Gradient na łusce
        const casingGrad = ctx.createLinearGradient(bx - 3, 0, bx + 3, 0);
        casingGrad.addColorStop(0, '#a08020');
        casingGrad.addColorStop(0.3, '#d4b030');
        casingGrad.addColorStop(0.7, '#c9a227');
        casingGrad.addColorStop(1, '#8a6a15');
        ctx.fillStyle = casingGrad;
        ctx.fillRect(bx - 3, 0, 6, 8);
        
        // Rowek na łusce
        ctx.fillStyle = '#8a6a15';
        ctx.fillRect(bx - 3, 5, 6, 2);
        
        // Pocisk (główka)
        ctx.fillStyle = '#b85518';
        ctx.beginPath();
        ctx.moveTo(bx - 3, 0);
        ctx.lineTo(bx - 2, -4);
        ctx.lineTo(bx, -7);
        ctx.lineTo(bx + 2, -4);
        ctx.lineTo(bx + 3, 0);
        ctx.closePath();
        ctx.fill();
        
        // Gradient na pocisku
        const bulletGrad = ctx.createLinearGradient(bx - 3, -7, bx + 3, -7);
        bulletGrad.addColorStop(0, '#983810');
        bulletGrad.addColorStop(0.4, '#c45e28');
        bulletGrad.addColorStop(0.6, '#b85518');
        bulletGrad.addColorStop(1, '#7a2808');
        ctx.fillStyle = bulletGrad;
        ctx.beginPath();
        ctx.moveTo(bx - 3, 0);
        ctx.lineTo(bx - 2, -4);
        ctx.lineTo(bx, -7);
        ctx.lineTo(bx + 2, -4);
        ctx.lineTo(bx + 3, 0);
        ctx.closePath();
        ctx.fill();
        
        // Połysk na pocisku
        ctx.fillStyle = 'rgba(255, 200, 150, 0.3)';
        ctx.beginPath();
        ctx.moveTo(bx - 1, -1);
        ctx.lineTo(bx, -5);
        ctx.lineTo(bx + 1, -1);
        ctx.closePath();
        ctx.fill();
    });
    
    // ==================== ZATRZASK ====================
    ctx.fillStyle = '#6a6a55';
    ctx.fillRect(-8, -h/2, 16, 4);
    ctx.fillStyle = '#5a5a45';
    ctx.fillRect(-6, -h/2 + 1, 12, 2);
    
    // Szczelina zatrzasku
    ctx.fillStyle = '#2a2a20';
    ctx.fillRect(-1, -h/2, 2, 3);
    
    // ==================== ŚWIECĄCE KRAWĘDZIE ====================
    ctx.strokeStyle = `rgba(200, 170, 50, ${0.4 * pulse})`;
    ctx.lineWidth = 2;
    ctx.shadowColor = 'rgba(200, 170, 50, 0.8)';
    ctx.shadowBlur = 8 * pulse;
    
    // Górna krawędź
    ctx.beginPath();
    ctx.moveTo(-w/2 + 8, -h/2);
    ctx.lineTo(w/2 - 8, -h/2);
    ctx.stroke();
    
    // Dolna krawędź
    ctx.beginPath();
    ctx.moveTo(-w/2 + 8, h/2);
    ctx.lineTo(w/2 - 8, h/2);
    ctx.stroke();
    
    // Lewa krawędź
    ctx.beginPath();
    ctx.moveTo(-w/2, -h/2 + 8);
    ctx.lineTo(-w/2, h/2 - 8);
    ctx.stroke();
    
    // Prawa krawędź
    ctx.beginPath();
    ctx.moveTo(w/2, -h/2 + 8);
    ctx.lineTo(w/2, h/2 - 8);
    ctx.stroke();
    
    ctx.shadowBlur = 0;
    
    ctx.restore();
});
			
			 medkitPickups.forEach(pickup => {
                const pulse = Math.sin(pickup.pulsePhase) * 0.2 + 1.0;
                
                // Poświata
                const glow = ctx.createRadialGradient(pickup.x, pickup.y, 0, pickup.x, pickup.y, 25);
                glow.addColorStop(0, `rgba(50, 255, 50, ${0.3 * pulse})`);
                glow.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = glow;
                ctx.fillRect(pickup.x - 25, pickup.y - 25, 50, 50);

                ctx.save();
                ctx.translate(pickup.x, pickup.y);
                ctx.scale(pulse, pulse); // Pulsujący rozmiar
                
                // Pudełko
                ctx.fillStyle = '#eeeeee';
                ctx.fillRect(-10, -8, 20, 16);
                ctx.strokeStyle = '#bbbbbb';
                ctx.strokeRect(-10, -8, 20, 16);
                
                // Czerwony krzyż
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(-3, -5, 6, 10);
                ctx.fillRect(-5, -3, 10, 6);
                
                ctx.restore();
            });

            // NOWE: Rysowanie Złomu
            scrapPickups.forEach(pickup => {
                const bounce = Math.sin(pickup.pulsePhase) * 3;
                
                ctx.save();
                ctx.translate(pickup.x, pickup.y + bounce);
                
                // Cień
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                ctx.beginPath();
                ctx.ellipse(0, 10 - bounce, 15, 5, 0, 0, Math.PI*2);
                ctx.fill();

                // Elementy złomu (zębatki, blaszki)
                pickup.visuals.forEach(item => {
                    ctx.save();
                    ctx.translate(item.dx, item.dy);
                    ctx.rotate(item.rot);
                    
                    if (item.type === 'gear') {
                        // Zębatka
                        ctx.fillStyle = '#7a7a7a';
                        ctx.beginPath();
                        ctx.arc(0, 0, 6, 0, Math.PI*2);
                        ctx.fill();
                        ctx.strokeStyle = '#5a5a5a'; // Ząbki
                        ctx.setLineDash([2, 2]);
                        ctx.lineWidth = 3;
                        ctx.stroke();
                        ctx.setLineDash([]);
                        // Dziurka w środku
                        ctx.fillStyle = '#1a1a1a';
                        ctx.beginPath();
                        ctx.arc(0,0,2,0,Math.PI*2);
                        ctx.fill();
                    } else {
                        // Blaszka/płytka
                        ctx.fillStyle = '#8a6a4a'; // Pordzewiała
                        ctx.fillRect(-6, -4, 12, 8);
                        ctx.fillStyle = '#3a2a1a'; // Nit
                        ctx.fillRect(-4, -2, 2, 2);
                        ctx.fillRect(2, 2, 2, 2);
                    }
                    ctx.restore();
                });

                ctx.restore();
            });


            // Draw trees behind house
            trees.forEach(tree => {
                drawGameTree(tree);
            });


            // Draw house
            drawHouse();
            drawTurret();
            drawArmorStation();
            drawGunStation();
            drawSniperStation();
            drawHawkNest(); // Gniazdo na dachu
            drawHawk(); 
            drawFoxStation();
            drawFoxes();

            // Draw vape particles (behind player)
            vapeParticles.forEach(p => {
                const alpha = (p.life / p.maxLife) * 0.6;
                ctx.fillStyle = `hsla(${p.hue}, 60%, 50%, ${alpha})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw boars
            boars.forEach(boar => {
                drawBoar(boar);
            });

            // Rysowanie Pablobitosa
            if (pablobitos) {
                if (pablobitos.isIntro) {
                    drawIntroScene(); // Rysuje bagno, mgłę i wyłaniającego się bossa
                } else {
                    drawPablobitos(pablobitos); // Rysuje normalnego bossa w walce
                }
            }

// RYSOWANIE FAL UDERZENIOWYCH (KRZYK)
shockwaves.forEach(s => {
    ctx.save();
    ctx.translate(s.x, s.y);
    
    const r = s.radius;
    
    // ==================== ZEWNĘTRZNA FALA ====================
    ctx.globalAlpha = s.alpha * 0.25;
    ctx.strokeStyle = '#888888';
    ctx.lineWidth = Math.max(2, s.lineWidth * 1.5);
    
    ctx.beginPath();
    ctx.arc(0, 0, r * 1.1, 0, Math.PI * 2);
    ctx.stroke();
    
    // ==================== GŁÓWNA FALA ====================
    ctx.globalAlpha = s.alpha * 0.7;
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = Math.max(3, s.lineWidth);
    
    // Zniekształcona fala - nie idealny okrąg
    ctx.beginPath();
    for (let i = 0; i <= 64; i++) {
        const angle = (i / 64) * Math.PI * 2;
        const wobble = Math.sin(angle * 8 + r * 0.05) * (r * 0.03);
        const dist = r + wobble;
        
        const x = Math.cos(angle) * dist;
        const y = Math.sin(angle) * dist;
        
        if (i === 0) {
            ctx.moveTo(x, y);
        } else {
            ctx.lineTo(x, y);
        }
    }
    ctx.closePath();
    ctx.stroke();
    
    // ==================== WEWNĘTRZNA FALA ====================
    ctx.globalAlpha = s.alpha * 0.45;
    ctx.strokeStyle = '#cccccc';
    ctx.lineWidth = Math.max(2, s.lineWidth * 0.7);
    
    ctx.beginPath();
    for (let i = 0; i <= 64; i++) {
        const angle = (i / 64) * Math.PI * 2;
        const wobble = Math.sin(angle * 6 - r * 0.08) * (r * 0.025);
        const dist = r * 0.85 + wobble;
        
        const x = Math.cos(angle) * dist;
        const y = Math.sin(angle) * dist;
        
        if (i === 0) {
            ctx.moveTo(x, y);
        } else {
            ctx.lineTo(x, y);
        }
    }
    ctx.closePath();
    ctx.stroke();
    
    // ==================== PROMIENIE ENERGII ====================
    ctx.globalAlpha = s.alpha * 0.35;
    ctx.strokeStyle = '#dddddd';
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    
    const rayCount = 12;
    for (let i = 0; i < rayCount; i++) {
        const angle = (i / rayCount) * Math.PI * 2;
        const rayLength = r * 0.15;
        const startDist = r * 0.75;
        const endDist = startDist + rayLength;
        
        const offset = Math.sin(r * 0.1 + i * 0.5) * r * 0.05;
        
        ctx.beginPath();
        ctx.moveTo(
            Math.cos(angle) * (startDist + offset),
            Math.sin(angle) * (startDist + offset)
        );
        ctx.lineTo(
            Math.cos(angle) * (endDist + offset),
            Math.sin(angle) * (endDist + offset)
        );
        ctx.stroke();
    }
    
    // ==================== CZĄSTECZKI PYŁU ====================
    ctx.globalAlpha = s.alpha * 0.3;
    ctx.fillStyle = '#aaaaaa';
    
    const particleCount = 16;
    for (let i = 0; i < particleCount; i++) {
        const angle = (i / particleCount) * Math.PI * 2 + r * 0.02;
        const particleDist = r * (0.6 + Math.sin(i * 2.7) * 0.15);
        const particleSize = 2 + Math.sin(i * 1.8 + r * 0.05) * 1.5;
        
        const px = Math.cos(angle) * particleDist;
        const py = Math.sin(angle) * particleDist;
        
        ctx.beginPath();
        ctx.arc(px, py, particleSize, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // ==================== EFEKT GLOW (poświata) ====================
    ctx.globalAlpha = s.alpha * 0.12;
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = Math.max(10, s.lineWidth * 3);
    
    ctx.beginPath();
    ctx.arc(0, 0, r * 0.95, 0, Math.PI * 2);
    ctx.stroke();
    
    ctx.restore();
});
ctx.globalAlpha = 1;

            

            // Draw player
            drawPlayer();

            // Draw bullets
                        // RYSOWANIE POCISKÓW
            // RYSOWANIE POCISKÓW
                        // RYSOWANIE POCISKÓW
            bullets.forEach(b => { 
                // 1. Smuga (Tracer) - Rysowana za pociskiem
                if (b.trail.length > 1) {
                    ctx.beginPath();
                    b.trail.forEach((p, i) => {
                        if (i === 0) ctx.moveTo(p.x, p.y);
                        else ctx.lineTo(p.x, p.y);
                    });
                    ctx.lineTo(b.x, b.y);
                    
                    ctx.lineCap = 'round';
                    // Snajperka T2 ma grubszą smugę
                    ctx.lineWidth = (b.weapon === 'sniper' && b.tier === 2) ? 5 : (b.weapon === 'sniper' ? 3 : 2);
                    
                    // Kolory smug
                    let trailColor = '255, 200, 100'; // Rewolwer (Złoty)
                    if (b.weapon === 'sniper') {
                        trailColor = b.tier === 2 ? '0, 255, 255' : '255, 50, 50'; // Niebieski (T2) lub Czerwony
                    }

                    const grad = ctx.createLinearGradient(b.trail[0].x, b.trail[0].y, b.x, b.y);
                    grad.addColorStop(0, `rgba(${trailColor}, 0)`);
                    grad.addColorStop(1, `rgba(${trailColor}, 0.8)`);
                    
                    ctx.strokeStyle = grad;
                    ctx.stroke();
                }

                // 2. Sam Pocisk (Głowica)
                ctx.save();
                ctx.translate(b.x, b.y);
                ctx.rotate(b.rotation);
                
                if (b.weapon === 'sniper') {
                    if (b.tier === 0) {
                        // Zwykła snajperka
                        ctx.fillStyle = '#fff'; ctx.fillRect(-4, -1.5, 8, 3);
                        ctx.fillStyle = 'rgba(255, 50, 0, 0.8)'; ctx.beginPath(); ctx.arc(0,0,5,0,Math.PI*2); ctx.fill();
                    }
                    else if (b.tier === 1) {
                        // TIER 1: Wielki Kaliber (Duży, czerwony)
                        ctx.fillStyle = '#fff'; ctx.fillRect(-12, -4.5, 24, 9); // Rdzeń
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.6)'; ctx.beginPath(); ctx.ellipse(0,0,15,8,0,0,Math.PI*2); ctx.fill(); // Glow
                        ctx.strokeStyle = '#ffaa00'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(-5, 0, 8, 0, Math.PI*2); ctx.stroke(); // Pierścień
                    }
                    else if (b.tier === 2) {
                        // TIER 2: Railgun (Ogromny, niebieski, elektryczny)
                        ctx.fillStyle = '#e0ffff'; ctx.fillRect(-24, -9, 48, 18); // Rdzeń
                        // Potężna poświata
                        const glow = ctx.createRadialGradient(0, 0, 0, 0, 0, 35);
                        glow.addColorStop(0, 'rgba(0, 255, 255, 1)');
                        glow.addColorStop(1, 'rgba(0, 100, 255, 0)');
                        ctx.fillStyle = glow; ctx.beginPath(); ctx.arc(0,0,35,0,Math.PI*2); ctx.fill();
                        // Pioruny
                        ctx.strokeStyle = '#fff'; ctx.lineWidth=2;
                        ctx.beginPath(); ctx.moveTo(-10, 0); ctx.lineTo(-25, (Math.random()-0.5)*25); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(25, (Math.random()-0.5)*25); ctx.stroke();
                    }
                } else {
                    // Rewolwer (Standardowy)
                    ctx.fillStyle = '#fff'; ctx.fillRect(-4, -1.5, 8, 3);
                    ctx.fillStyle = '#ffcc00'; ctx.globalAlpha = 0.6; ctx.beginPath(); ctx.ellipse(0, 0, 8, 3, 0, 0, Math.PI*2); ctx.fill();
                }
                
                ctx.restore();
                ctx.globalAlpha = 1;
            });

            // PLAMY ŚLINY (KWASU)
acidPools.forEach(p => {
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.globalAlpha = Math.min(0.6, p.life / 50);
    
    const pulse = 1 + Math.sin(gameTime * 0.15) * 0.05;
    ctx.scale(pulse, pulse);
    
    const r = p.radius;
    
    // ==================== GŁÓWNA KAŁUŻA ====================
    ctx.fillStyle = '#4a6b35';
    ctx.globalAlpha = Math.min(0.4, p.life / 60);
    ctx.beginPath();
    ctx.moveTo(-r * 0.9, -r * 0.2);
    ctx.quadraticCurveTo(-r * 0.7, -r * 0.7, -r * 0.1, -r * 0.8);
    ctx.quadraticCurveTo(r * 0.5, -r * 0.9, r * 0.85, -r * 0.3);
    ctx.quadraticCurveTo(r * 1.0, r * 0.2, r * 0.7, r * 0.6);
    ctx.quadraticCurveTo(r * 0.2, r * 0.95, -r * 0.4, r * 0.75);
    ctx.quadraticCurveTo(-r * 0.9, r * 0.5, -r * 0.95, r * 0.1);
    ctx.quadraticCurveTo(-r * 1.0, -r * 0.3, -r * 0.9, -r * 0.2);
    ctx.closePath();
    ctx.fill();
    
    ctx.fillStyle = '#6b8c50';
    ctx.globalAlpha = Math.min(0.5, p.life / 50);
    ctx.beginPath();
    ctx.moveTo(-r * 0.7, -r * 0.15);
    ctx.quadraticCurveTo(-r * 0.5, -r * 0.55, 0, -r * 0.6);
    ctx.quadraticCurveTo(r * 0.4, -r * 0.65, r * 0.65, -r * 0.2);
    ctx.quadraticCurveTo(r * 0.75, r * 0.15, r * 0.55, r * 0.45);
    ctx.quadraticCurveTo(r * 0.15, r * 0.7, -r * 0.3, r * 0.55);
    ctx.quadraticCurveTo(-r * 0.7, r * 0.35, -r * 0.75, 0);
    ctx.quadraticCurveTo(-r * 0.8, -r * 0.2, -r * 0.7, -r * 0.15);
    ctx.closePath();
    ctx.fill();
    
    ctx.fillStyle = '#8ba870';
    ctx.globalAlpha = Math.min(0.55, p.life / 45);
    ctx.beginPath();
    ctx.ellipse(r * 0.05, r * 0.05, r * 0.4, r * 0.35, 0.2, 0, Math.PI * 2);
    ctx.fill();
    
    // ==================== POŁYSK ====================
    ctx.fillStyle = '#a8c090';
    ctx.globalAlpha = Math.min(0.4, p.life / 50);
    ctx.beginPath();
    ctx.ellipse(-r * 0.25, -r * 0.25, r * 0.18, r * 0.1, -0.5, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#9ab885';
    ctx.beginPath();
    ctx.ellipse(r * 0.3, r * 0.15, r * 0.12, r * 0.07, 0.3, 0, Math.PI * 2);
    ctx.fill();
    
    // ==================== BĄBELKI ====================
    const bubbles = [
        { x: -r * 0.4, y: -r * 0.35, size: r * 0.08 },
        { x: r * 0.5, y: -r * 0.2, size: r * 0.06 },
        { x: r * 0.25, y: r * 0.4, size: r * 0.07 },
        { x: -r * 0.55, y: r * 0.2, size: r * 0.05 },
        { x: -r * 0.15, y: r * 0.5, size: r * 0.06 },
        { x: r * 0.6, y: r * 0.25, size: r * 0.04 }
    ];
    
    bubbles.forEach((bub, i) => {
        const bubblePulse = 1 + Math.sin(gameTime * 0.3 + i * 1.2) * 0.2;
        const bubbleSize = bub.size * bubblePulse;
        
        ctx.fillStyle = '#7a9960';
        ctx.globalAlpha = Math.min(0.5, p.life / 50);
        ctx.beginPath();
        ctx.arc(bub.x, bub.y, bubbleSize, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#a8c090';
        ctx.globalAlpha = Math.min(0.4, p.life / 50);
        ctx.beginPath();
        ctx.arc(bub.x - bubbleSize * 0.3, bub.y - bubbleSize * 0.3, bubbleSize * 0.35, 0, Math.PI * 2);
        ctx.fill();
    });
    
    ctx.restore();
});

// POCISKI ŚLINY
bossProjectiles.forEach(b => {
    ctx.save();
    ctx.translate(b.x, b.y);
    
    const s = b.size;
    const angle = Math.atan2(b.vy || 0, b.vx || 0);
    ctx.rotate(angle);
    
    // ==================== TRACER - ANIMOWANE ODPADAJĄCE KAWAŁKI ====================
    // Stałe kąty dla każdej kropli (pseudolosowe ale stabilne)
    const dropletAngles = [0.12, -0.35, 0.58, -0.22, 0.45, -0.68, 0.31, -0.15];
    const maxAngle = Math.PI / 4; // 45 stopni
    
    for (let i = 0; i < 6; i++) {
        // Wolniejsza animacja
        const baseSpeed = gameTime * 0.8;
        const cyclePos = ((baseSpeed + i * 1.5) % 6) / 6;
        
        const dist = cyclePos * s * 4;
        const trailSize = s * (0.55 - cyclePos * 0.45);
        const trailAlpha = 0.55 - cyclePos * 0.5;
        
        if (trailSize > 0 && trailAlpha > 0) {
            // Kąt w zakresie -45 do +45 stopni
            const dropAngle = dropletAngles[i % dropletAngles.length] * maxAngle;
            
            // Pozycja kropli w kierunku kąta
            const dropX = -dist * Math.cos(dropAngle);
            const dropY = -dist * Math.sin(dropAngle);
            
            // Główna kropelka
            ctx.fillStyle = '#6b8c50';
            ctx.globalAlpha = trailAlpha;
            ctx.beginPath();
            ctx.arc(dropX, dropY, trailSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Połysk
            if (trailSize > s * 0.2) {
                ctx.fillStyle = '#8ba870';
                ctx.globalAlpha = trailAlpha * 0.5;
                ctx.beginPath();
                ctx.arc(dropX + trailSize * 0.2, dropY - trailSize * 0.25, trailSize * 0.3, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }
    
    // Mikro-odpryski
    const microAngles = [0.72, -0.48, 0.25, -0.62, 0.38];
    
    for (let i = 0; i < 4; i++) {
        const microSpeed = gameTime * 1.0;
        const microCycle = ((microSpeed + i * 2.0) % 5) / 5;
        
        const microDist = microCycle * s * 3;
        const microSize = s * (0.22 - microCycle * 0.18);
        const microAlpha = 0.35 - microCycle * 0.3;
        
        if (microSize > 0 && microAlpha > 0) {
            const microAngle = microAngles[i % microAngles.length] * maxAngle;
            
            const microX = -microDist * Math.cos(microAngle);
            const microY = -microDist * Math.sin(microAngle);
            
            ctx.fillStyle = '#5a7a45';
            ctx.globalAlpha = microAlpha;
            ctx.beginPath();
            ctx.arc(microX, microY, microSize, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    ctx.globalAlpha = 0.75;
    
    // ==================== GŁÓWNA KROPLA ====================
    ctx.fillStyle = '#4a6b35';
    ctx.beginPath();
    ctx.arc(0, 0, s, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#6b8c50';
    ctx.beginPath();
    ctx.arc(s * 0.1, 0, s * 0.75, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#8ba870';
    ctx.globalAlpha = 0.7;
    ctx.beginPath();
    ctx.arc(s * 0.2, 0, s * 0.5, 0, Math.PI * 2);
    ctx.fill();
    
    // ==================== POŁYSK ====================
    ctx.fillStyle = '#a8c090';
    ctx.globalAlpha = 0.6;
    ctx.beginPath();
    ctx.ellipse(s * 0.3, -s * 0.25, s * 0.25, s * 0.15, -0.3, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#c5d8b5';
    ctx.globalAlpha = 0.5;
    ctx.beginPath();
    ctx.arc(s * 0.35, -s * 0.3, s * 0.12, 0, Math.PI * 2);
    ctx.fill();
    
    // ==================== KRAWĘDŹ ====================
    ctx.strokeStyle = '#3d5a28';
    ctx.globalAlpha = 0.6;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(0, 0, s, 0, Math.PI * 2);
    ctx.stroke();
    
    ctx.restore();
});

            // Draw particles
            particles.forEach(p => {
                const alpha = p.life / p.maxLife;
                ctx.fillStyle = p.color;
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            ctx.restore();

            // Draw crosshair
            drawCrosshair();

            drawBossIntro();

            // --- EFEKTY EKRANOWE (OVERLAYE) ---

            // 1. Standardowa Winieta (Ciemność)
            const vignette = ctx.createRadialGradient(
                gameCanvas.width/2, gameCanvas.height/2, gameCanvas.height * 0.4,
                gameCanvas.width/2, gameCanvas.height/2, gameCanvas.height
            );
            vignette.addColorStop(0, 'rgba(0,0,0,0)');
            vignette.addColorStop(1, 'rgba(0,0,0,0.5)');
            ctx.fillStyle = vignette;
            ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

            // 2. Szkarłatna Winieta (NOWE: Krytyczne HP <= 30)
            if (player.health <= 40) {
                // Im mniej życia, tym mocniejszy efekt (0.0 -> 1.0)
                let deathFactor = 1 - (Math.max(0, player.health) / 30);
                
                // Pulsowanie (szybsze przy śmierci)
                const pulse = (Math.sin(gameTime * (0.1 + deathFactor * 0.2)) + 1) / 2;
                
                // Finalna przezroczystość
                const alpha = (deathFactor * 0.5) + (pulse * 0.3 * deathFactor);

                const bloodGrad = ctx.createRadialGradient(
                    gameCanvas.width/2, gameCanvas.height/2, gameCanvas.height * 0.2,
                    gameCanvas.width/2, gameCanvas.height/2, gameCanvas.height
                );
                bloodGrad.addColorStop(0, 'rgba(139, 0, 0, 0)'); 
                bloodGrad.addColorStop(1, `rgba(180, 0, 0, ${alpha})`); 
                
                ctx.fillStyle = bloodGrad;
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
            }

            // 3. Damage Flash (Błysk przy trafieniu)
            if (player.invincible > 30) {
                ctx.fillStyle = `rgba(139, 0, 0, ${(player.invincible - 30) / 45 * 0.3})`;
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
            }

            // 4. Vape Overlay (Najwyższy priorytet - na wierzchu)
            if (player.vapeActive) {
                ctx.fillStyle = `rgba(75, 0, 130, ${0.1 + Math.sin(gameTime / 10) * 0.05})`;
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
            }

                        // --- ALARM STANU DOMU ---
            // Wyświetlaj tylko, gdy: dom uszkodzony (<=30 HP), nie ma intro bossa, gra się nie skończyła
            if (house.health <= 30 && (!pablobitos || !pablobitos.isIntro) && !gameOver) {
                ctx.save();
                
                // Miganie (Sinusoida od 0.2 do 1.0)
                const blink = (Math.sin(gameTime * 0.15) + 1) / 2; // Wolne miganie
                const alpha = 0.2 + blink * 0.8;
                
                ctx.globalAlpha = alpha;
                ctx.textAlign = 'center';
                ctx.font = 'bold 30px "Courier New", monospace'; // Czcionka komputerowa
                
                // Czerwona poświata
                ctx.shadowColor = 'red';
                ctx.shadowBlur = 10;
                
                // Tekst
                ctx.fillStyle = '#ff3333';
                ctx.fillText("!!! STAN DOMU KRYTYCZNY !!!", gameCanvas.width / 2, gameCanvas.height - 110);
                
                ctx.restore();
            }

                    // RYSOWANIE ŁUSEK
            shells.forEach(s => {
                ctx.save();
                ctx.translate(s.x, s.y);
                ctx.rotate(s.rotation);
                
                // Efekt zanikania
                ctx.globalAlpha = Math.min(1, s.life / 60);

                if (s.type === 'sniper') {
                    // Duża łuska snajperska (.50 BMG)
                    ctx.fillStyle = '#ffd700'; // Mosiądz jasny
                    ctx.fillRect(-4, -1.5, 8, 3);
                    ctx.fillStyle = '#b8860b'; // Ciemniejszy tył
                    ctx.fillRect(-4, -1.5, 2, 3);
                } else {
                    // Mała łuska rewolwerowa
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(-2, -1, 4, 2);
                    ctx.fillStyle = '#b8860b';
                    ctx.fillRect(-2, -1, 1, 2);
                }

                ctx.restore();
            });
            ctx.globalAlpha = 1; // Reset alpha
        }

        function drawBackground() {
            // Sky gradient (dusk/evening)
            const skyGrad = ctx.createLinearGradient(0, 0, 0, gameCanvas.height);
            skyGrad.addColorStop(0, '#1a1520');
            skyGrad.addColorStop(0.3, '#2a2030');
            skyGrad.addColorStop(0.6, '#1a2518');
            skyGrad.addColorStop(1, '#0f1810');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

            // Ground texture
            ctx.fillStyle = '#1a2515';
            ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

            // Grass tufts
            for (let i = 0; i < 200; i++) {
                const x = (i * 137) % gameCanvas.width;
                const y = (i * 89) % gameCanvas.height;
                ctx.strokeStyle = `rgba(30, 50, 25, ${0.3 + Math.random() * 0.3})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + (Math.random() - 0.5) * 8, y - 5 - Math.random() * 10);
                ctx.stroke();
            }

            // Fog layers
            for (let i = 0; i < 3; i++) {
                ctx.fillStyle = `rgba(100, 100, 90, ${0.03 - i * 0.008})`;
                ctx.beginPath();
                ctx.ellipse(
                    gameCanvas.width / 2 + Math.sin(gameTime / 200 + i) * 100,
                    300 + i * 100,
                    gameCanvas.width * 0.8,
                    50 + i * 20,
                    0, 0, Math.PI * 2
                );
                ctx.fill();
            }
        }

        function drawGameTree(tree) {
            ctx.save();
            ctx.translate(tree.x, tree.y);
            const scale = tree.size;
            ctx.scale(scale, scale);

            // Subtle sway
            const sway = Math.sin(gameTime / 60 + tree.sway) * 0.02;
            ctx.rotate(sway);

            if (tree.type === 'pine') {
                // Pine trunk
                ctx.fillStyle = '#1a1510';
                ctx.fillRect(-6, -10, 12, 60);

                // Pine layers
                for (let i = 0; i < 5; i++) {
                    ctx.fillStyle = `rgb(${15 + i * 3}, ${35 + i * 5}, ${15 + i * 3})`;
                    ctx.beginPath();
                    ctx.moveTo(0, -70 + i * 15);
                    ctx.lineTo(-25 + i * 3, -20 + i * 15);
                    ctx.lineTo(25 - i * 3, -20 + i * 15);
                    ctx.closePath();
                    ctx.fill();
                }
            } else {
                // Oak trunk
                ctx.fillStyle = '#1a1510';
                ctx.fillRect(-8, -5, 16, 55);

                // Oak crown
                ctx.fillStyle = '#1a3015';
                ctx.beginPath();
                ctx.arc(0, -35, 35, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#152510';
                ctx.beginPath();
                ctx.arc(-15, -25, 25, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(15, -25, 25, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

       function drawHouse() {
    ctx.save();
    ctx.translate(house.x, house.y);

    const damage = 1 - house.health / house.maxHealth;
    const w = house.width;
    const h = house.height;

    // ==================== CIEŃ ====================
    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
    ctx.beginPath();
    ctx.ellipse(w / 2 + 10, h + 5, w * 0.6, 15, 0, 0, Math.PI * 2);
    ctx.fill();

    // ==================== GRUZ (pojawia się przy zniszczeniach) ====================
    if (damage > 0.1) {
        ctx.fillStyle = '#4a4035';
        const rubbleCount = Math.floor(damage * 15);
        for (let i = 0; i < rubbleCount; i++) {
            const rx = -20 + (i * 17) % (w + 40);
            const ry = h - 5 + Math.sin(i * 3) * 5;
            const rs = 4 + (i % 5) * 2;
            ctx.beginPath();
            ctx.moveTo(rx, ry);
            ctx.lineTo(rx + rs, ry - rs * 0.5);
            ctx.lineTo(rx + rs * 1.5, ry + rs * 0.3);
            ctx.lineTo(rx + rs * 0.3, ry + rs * 0.5);
            ctx.closePath();
            ctx.fill();
        }
    }

    // ==================== GŁÓWNA KUPKA GRUZU (70%+ damage) ====================
    if (damage > 0.7) {
        const rubbleProgress = (damage - 0.7) / 0.3;
        
        // Podstawa gruzu
        ctx.fillStyle = '#3a3530';
        ctx.beginPath();
        ctx.moveTo(-10, h);
        ctx.lineTo(w + 10, h);
        ctx.lineTo(w - 20, h - 30 - rubbleProgress * 40);
        ctx.lineTo(w / 2, h - 50 - rubbleProgress * 30);
        ctx.lineTo(20, h - 25 - rubbleProgress * 35);
        ctx.closePath();
        ctx.fill();
        
        // Duże kawałki gruzu
        ctx.fillStyle = '#4a4540';
        for (let i = 0; i < 12; i++) {
            const rx = 5 + (i * 12) % (w - 10);
            const ry = h - 15 - rubbleProgress * 20 - (i % 4) * 10;
            const rs = 10 + (i % 5) * 8;
            ctx.beginPath();
            ctx.moveTo(rx, ry);
            ctx.lineTo(rx + rs * 0.8, ry - rs * 0.4);
            ctx.lineTo(rx + rs, ry + rs * 0.2);
            ctx.lineTo(rx + rs * 0.5, ry + rs * 0.5);
            ctx.lineTo(rx - rs * 0.2, ry + rs * 0.2);
            ctx.closePath();
            ctx.fill();
        }
        
        // Kawałki drewna (żółte/złote)
        ctx.fillStyle = '#8a7520';
        for (let i = 0; i < 8; i++) {
            const bx = 10 + (i * 15) % (w - 20);
            const by = h - 20 - rubbleProgress * 25 - (i % 3) * 12;
            const angle = (i * 0.7) - 0.5;
            ctx.save();
            ctx.translate(bx, by);
            ctx.rotate(angle);
            ctx.fillRect(-12, -3, 24, 6);
            ctx.restore();
        }
        
        // Ciemniejsze kawałki drewna
        ctx.fillStyle = '#5a4a30';
        for (let i = 0; i < 6; i++) {
            const bx = 15 + (i * 18) % (w - 30);
            const by = h - 10 - rubbleProgress * 15 - (i % 2) * 8;
            const angle = (i * 0.9) - 0.3;
            ctx.save();
            ctx.translate(bx, by);
            ctx.rotate(angle);
            ctx.fillRect(-15, -4, 30, 7);
            ctx.restore();
        }
        
        // Kawałki dachu (trójkąty)
        ctx.fillStyle = '#3a2515';
        for (let i = 0; i < 5; i++) {
            const tx = 15 + i * 22;
            const ty = h - 35 - rubbleProgress * 30 + (i % 2) * 15;
            ctx.beginPath();
            ctx.moveTo(tx, ty);
            ctx.lineTo(tx + 18, ty + 5);
            ctx.lineTo(tx + 8, ty - 12);
            ctx.closePath();
            ctx.fill();
        }
        
        // Cegły/kamienie
        ctx.fillStyle = '#5a5550';
        for (let i = 0; i < 10; i++) {
            const cx = 8 + (i * 14) % (w - 16);
            const cy = h - 8 - (i % 3) * 6;
            ctx.fillRect(cx, cy, 10 + (i % 3) * 4, 6 + (i % 2) * 3);
        }
    }

    // ==================== DOM (tylko gdy damage < 0.95) ====================
    if (damage < 0.95) {
        
        // ==================== FUNDAMENT ====================
        if (damage < 0.85) {
            ctx.fillStyle = '#3a3530';
            const foundationCrumble = damage > 0.6 ? (damage - 0.6) * 30 : 0;
            ctx.fillRect(-5 + foundationCrumble, h - 10, w + 10 - foundationCrumble * 2, 15);
            
            if (damage > 0.4) {
                ctx.strokeStyle = '#1a1510';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(w * 0.3, h - 5);
                ctx.lineTo(w * 0.35, h + 3);
                ctx.stroke();
            }
        }

        // ==================== GŁÓWNE ŚCIANY ====================
        if (damage < 0.9) {
            const wallDarkness = damage * 0.4;
            const wallGrad = ctx.createLinearGradient(0, 30, 0, h);
            wallGrad.addColorStop(0, `rgb(${212 - wallDarkness * 150}, ${168 - wallDarkness * 120}, ${50 - wallDarkness * 40})`);
            wallGrad.addColorStop(0.5, `rgb(${201 - wallDarkness * 150}, ${162 - wallDarkness * 120}, ${39 - wallDarkness * 40})`);
            wallGrad.addColorStop(1, `rgb(${168 - wallDarkness * 150}, ${133 - wallDarkness * 120}, ${32 - wallDarkness * 40})`);
            ctx.fillStyle = wallGrad;

            // Kształt ściany z ubytkami
            ctx.beginPath();
            
            if (damage < 0.75) {
                ctx.moveTo(0, 35);
                ctx.lineTo(w, 35);
                ctx.lineTo(w, h - 10);
                ctx.lineTo(0, h - 10);
            } else {
                // Rozpadająca się ściana
                const collapse = (damage - 0.75) / 0.2;
                ctx.moveTo(5 + collapse * 15, 35 + collapse * 20);
                ctx.lineTo(w - 5 - collapse * 15, 35 + collapse * 15);
                ctx.lineTo(w - 10 - collapse * 20, h - 15 - collapse * 30);
                ctx.lineTo(10 + collapse * 20, h - 10 - collapse * 25);
            }
            
            ctx.closePath();
            ctx.fill();

            // Linie desek
            if (damage < 0.8) {
                ctx.strokeStyle = `rgba(138, 105, 20, ${1 - damage * 0.6})`;
                ctx.lineWidth = 1;
                for (let i = 0; i < 8; i++) {
                    const lineY = 40 + i * 12;
                    if (damage < 0.5 || i < 6 - Math.floor(damage * 4)) {
                        const wobble = damage > 0.3 ? Math.sin(i * 2) * damage * 8 : 0;
                        ctx.beginPath();
                        ctx.moveTo(8, lineY + wobble);
                        ctx.lineTo(w - 8, lineY - wobble);
                        ctx.stroke();
                    }
                }
            }
        }

        // ==================== NAROŻNIKI ====================
        if (damage < 0.75) {
            ctx.fillStyle = '#7a5a10';
            
            if (damage < 0.65) {
                ctx.fillRect(0, 35, 8, h - 45 - damage * 30);
            }
            
            if (damage < 0.55) {
                ctx.fillRect(w - 8, 35, 8, h - 45 - damage * 40);
            }
        }

        // ==================== DACH ====================
        if (damage < 0.85) {
            ctx.fillStyle = '#3a2515';
            
            if (damage < 0.7) {
                // Pełny dach
                ctx.beginPath();
                ctx.moveTo(-15, 40);
                ctx.lineTo(w / 2, -5);
                ctx.lineTo(w + 15, 40);
                ctx.closePath();
                ctx.fill();
            } else {
                // Rozpadający się dach
                const roofCollapse = (damage - 0.7) / 0.15;
                ctx.beginPath();
                ctx.moveTo(-15 + roofCollapse * 25, 40 + roofCollapse * 20);
                ctx.lineTo(w / 2, -5 + roofCollapse * 35);
                ctx.lineTo(w + 15 - roofCollapse * 25, 40 + roofCollapse * 15);
                ctx.closePath();
                ctx.fill();
            }

            // Dziury w dachu
            if (damage > 0.35) {
                ctx.fillStyle = '#1a1510';
                const holeSize = (damage - 0.35) * 35;
                ctx.beginPath();
                ctx.ellipse(w * 0.35, 18, Math.min(holeSize, 20), Math.min(holeSize * 0.6, 12), -0.3, 0, Math.PI * 2);
                ctx.fill();
            }

            if (damage > 0.5) {
                ctx.fillStyle = '#1a1510';
                const holeSize = (damage - 0.5) * 30;
                ctx.beginPath();
                ctx.ellipse(w * 0.65, 22, Math.min(holeSize, 18), Math.min(holeSize * 0.5, 10), 0.2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Linie dachówek
            if (damage < 0.6) {
                ctx.strokeStyle = '#2a1a10';
                ctx.lineWidth = 2;
                for (let i = 0; i < 4; i++) {
                    if (damage < 0.3 || i < 3 - Math.floor(damage * 3)) {
                        ctx.beginPath();
                        ctx.moveTo(-10 + i * 8, 35 - i * 8);
                        ctx.lineTo(w + 10 - i * 8, 35 - i * 8);
                        ctx.stroke();
                    }
                }
            }
        }

        // ==================== DRZWI ====================
        if (damage < 0.8) {
            ctx.save();
            ctx.translate(w / 2, h - 10);
            
            if (damage > 0.5) {
                // Przechylone/upadające drzwi
                const doorFall = (damage - 0.5) / 0.3;
                ctx.rotate(doorFall * 0.8);
                ctx.translate(doorFall * 15, doorFall * 10);
            }
            
            ctx.fillStyle = '#2a1a10';
            ctx.fillRect(-18, -70, 36, 70);
            
            if (damage < 0.65) {
                ctx.fillStyle = '#3a2515';
                ctx.fillRect(-15, -67, 30, 64);
                
                if (damage < 0.4) {
                    ctx.strokeStyle = '#2a1a10';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, -67);
                    ctx.lineTo(0, -3);
                    ctx.stroke();
                    
                    ctx.fillStyle = '#8a7a50';
                    ctx.beginPath();
                    ctx.arc(10, -35, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            ctx.restore();
        }

        // ==================== OKNA ====================
        const windowPositions = [[20, 55], [w - 50, 55]];
        windowPositions.forEach(([wx, wy], index) => {
            const windowGone = index === 0 ? damage > 0.75 : damage > 0.8;
            const windowBroken = index === 0 ? damage > 0.4 : damage > 0.55;
            
            if (!windowGone) {
                ctx.fillStyle = '#2a1a10';
                ctx.fillRect(wx - 3, wy - 3, 36, 36);
                
                if (!windowBroken) {
                    ctx.fillStyle = '#1a3045';
                    ctx.fillRect(wx, wy, 30, 30);

                    if (damage < 0.3) {
                        const lightIntensity = 0.4 - damage;
                        const lightGlow = ctx.createRadialGradient(wx + 15, wy + 15, 0, wx + 15, wy + 15, 25);
                        lightGlow.addColorStop(0, `rgba(180, 140, 60, ${lightIntensity})`);
                        lightGlow.addColorStop(1, 'rgba(180, 140, 60, 0)');
                        ctx.fillStyle = lightGlow;
                        ctx.fillRect(wx, wy, 30, 30);
                    }

                    ctx.strokeStyle = '#3a2515';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(wx + 15, wy);
                    ctx.lineTo(wx + 15, wy + 30);
                    ctx.moveTo(wx, wy + 15);
                    ctx.lineTo(wx + 30, wy + 15);
                    ctx.stroke();
                } else {
                    ctx.fillStyle = '#0a0808';
                    ctx.fillRect(wx, wy, 30, 30);
                    
                    ctx.strokeStyle = '#2a4550';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(wx + 2, wy + 2);
                    ctx.lineTo(wx + 18, wy + 20);
                    ctx.lineTo(wx + 28, wy + 8);
                    ctx.moveTo(wx + 8, wy + 28);
                    ctx.lineTo(wx + 22, wy + 12);
                    ctx.stroke();
                }
            }
        });

        // ==================== KOMIN ====================
        if (damage < 0.5) {
            ctx.save();
            ctx.translate(w - 35, 15);
            ctx.rotate(damage * 0.3);
            
            ctx.fillStyle = '#4a3525';
            ctx.fillRect(-10, -20, 20, 35);
            ctx.fillStyle = '#3a2515';
            ctx.fillRect(-12, -23, 24, 6);
            
            ctx.restore();

            if (damage < 0.2) {
                ctx.fillStyle = `rgba(80, 80, 70, ${0.25 - damage})`;
                for (let i = 0; i < 4; i++) {
                    const smokeOffset = Math.sin(gameTime / 40 + i * 2) * 10;
                    ctx.beginPath();
                    ctx.arc(w - 35 + smokeOffset, -20 - i * 20, 10 + i * 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        } else if (damage < 0.7) {
            // Upadły komin
            ctx.fillStyle = '#4a3525';
            ctx.save();
            ctx.translate(w - 15, h - 25);
            ctx.rotate(1.3);
            ctx.fillRect(-12, -6, 28, 14);
            ctx.restore();
            
            // Cegły z komina
            ctx.fillStyle = '#5a4535';
            ctx.fillRect(w - 30, h - 15, 8, 6);
            ctx.fillRect(w - 18, h - 12, 7, 5);
            ctx.fillRect(w - 40, h - 10, 9, 6);
        }

        // ==================== PĘKNIĘCIA NA ŚCIANACH ====================
        ctx.strokeStyle = '#1a1510';
        ctx.lineWidth = 2;

        if (damage > 0.1 && damage < 0.9) {
            ctx.beginPath();
            ctx.moveTo(25, 45);
            ctx.lineTo(32, 65);
            ctx.lineTo(28, 85);
            ctx.stroke();
        }

        if (damage > 0.2 && damage < 0.85) {
            ctx.beginPath();
            ctx.moveTo(w - 22, 50);
            ctx.lineTo(w - 30, 72);
            ctx.lineTo(w - 26, 98);
            ctx.stroke();
        }

        if (damage > 0.3 && damage < 0.85) {
            ctx.beginPath();
            ctx.moveTo(w / 2 + 20, 42);
            ctx.lineTo(w / 2 + 15, 60);
            ctx.lineTo(w / 2 + 22, 82);
            ctx.stroke();
        }

        if (damage > 0.4 && damage < 0.8) {
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(12, 65);
            ctx.lineTo(22, 92);
            ctx.lineTo(18, 118);
            ctx.stroke();
        }

        if (damage > 0.5 && damage < 0.8) {
            ctx.beginPath();
            ctx.moveTo(w - 12, 75);
            ctx.lineTo(w - 22, 102);
            ctx.lineTo(w - 16, 125);
            ctx.stroke();
        }

        // ==================== DZIURY W ŚCIANACH ====================
        if (damage > 0.45 && damage < 0.9) {
            ctx.fillStyle = '#0a0805';
            const holeSize = Math.min((damage - 0.45) * 40, 20);
            ctx.beginPath();
            ctx.ellipse(w * 0.22, 88, holeSize, holeSize * 0.7, 0.1, 0, Math.PI * 2);
            ctx.fill();
        }

        if (damage > 0.55 && damage < 0.85) {
            ctx.fillStyle = '#0a0805';
            const holeSize = Math.min((damage - 0.55) * 45, 22);
            ctx.beginPath();
            ctx.ellipse(w * 0.72, 95, holeSize, holeSize * 0.8, -0.15, 0, Math.PI * 2);
            ctx.fill();
        }

        // ==================== SADZA ====================
        if (damage > 0.35 && damage < 0.9) {
            ctx.fillStyle = `rgba(25, 18, 12, ${Math.min((damage - 0.35) * 0.6, 0.3)})`;
            ctx.beginPath();
            ctx.ellipse(w * 0.28, 72, 22, 32, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        if (damage > 0.5 && damage < 0.85) {
            ctx.fillStyle = `rgba(25, 18, 12, ${Math.min((damage - 0.5) * 0.7, 0.35)})`;
            ctx.beginPath();
            ctx.ellipse(w * 0.68, 82, 28, 38, 0, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    ctx.restore();
}

        function drawBoar(boar) {
            ctx.save();
            ctx.translate(boar.x, boar.y);

            const bobY = Math.sin(boar.walkFrame) * 3;
            const legOffset = Math.sin(boar.walkFrame) * 5;

            // Flip based on movement direction
            if (Math.cos(boar.angle) < 0) {
                ctx.scale(-1, 1);
            }

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(0, boar.height / 2 + 5, boar.width / 2.5, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Legs
            ctx.fillStyle = boar.isBoss ? '#2a1515' : '#3a2a20';
            // Back legs
            ctx.fillRect(-boar.width / 3 - legOffset, boar.height / 4, 8, 15);
            ctx.fillRect(-boar.width / 3 + legOffset, boar.height / 4, 8, 15);
            // Front legs
            ctx.fillRect(boar.width / 5 + legOffset, boar.height / 4, 8, 15);
            ctx.fillRect(boar.width / 5 - legOffset, boar.height / 4, 8, 15);

            // Body
            const bodyGrad = ctx.createRadialGradient(0, bobY, 0, 0, bobY, boar.width / 2);
            if (boar.isBoss) {
                bodyGrad.addColorStop(0, '#4a2020');
                bodyGrad.addColorStop(1, '#2a1010');
            } else if (boar.isCharger) {
                bodyGrad.addColorStop(0, '#5a4030');
                bodyGrad.addColorStop(1, '#3a2515');
            } else {
                bodyGrad.addColorStop(0, '#5a4535');
                bodyGrad.addColorStop(1, '#3a2a20');
            }
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.ellipse(0, bobY, boar.width / 2, boar.height / 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Bristles/fur texture
            ctx.strokeStyle = boar.isBoss ? '#3a1515' : '#2a1a15';
            ctx.lineWidth = 1;
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI - Math.PI / 2;
                ctx.beginPath();
                ctx.moveTo(Math.cos(angle) * boar.width * 0.3, bobY + Math.sin(angle) * boar.height * 0.3);
                ctx.lineTo(Math.cos(angle) * boar.width * 0.5, bobY + Math.sin(angle) * boar.height * 0.5 - 5);
                ctx.stroke();
            }

            // Head
            ctx.fillStyle = boar.isBoss ? '#3a1818' : '#4a3528';
            ctx.beginPath();
            ctx.ellipse(boar.width / 3, bobY, boar.width / 4, boar.height / 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Snout
            ctx.fillStyle = '#8a6a5a';
            ctx.beginPath();
            ctx.ellipse(boar.width / 2.2, bobY + 5, boar.width / 8, boar.height / 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nostrils
            ctx.fillStyle = '#2a1a15';
            ctx.beginPath();
            ctx.ellipse(boar.width / 2, bobY + 3, 3, 2, 0, 0, Math.PI * 2);
            ctx.ellipse(boar.width / 2, bobY + 8, 3, 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Tusks
            ctx.fillStyle = '#e8e0d0';
            ctx.beginPath();
            ctx.moveTo(boar.width / 3, bobY - boar.height / 4);
            ctx.quadraticCurveTo(boar.width / 2 + 10, bobY - boar.height / 3, boar.width / 2.5, bobY - boar.height / 6);
            ctx.lineTo(boar.width / 3.5, bobY - boar.height / 5);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(boar.width / 3, bobY + boar.height / 4);
            ctx.quadraticCurveTo(boar.width / 2 + 10, bobY + boar.height / 3, boar.width / 2.5, bobY + boar.height / 6);
            ctx.lineTo(boar.width / 3.5, bobY + boar.height / 5);
            ctx.closePath();
            ctx.fill();

            // Eyes
            const eyeGlow = boar.isBoss || boar.stunned > 0;
            ctx.fillStyle = eyeGlow ? '#ff3333' : '#8b0000';
            ctx.beginPath();
            ctx.ellipse(boar.width / 4, bobY - boar.height / 5, 5, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Eye shine
            ctx.fillStyle = '#ff6666';
            ctx.beginPath();
            ctx.arc(boar.width / 4 + 1, bobY - boar.height / 5 - 1, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Ears
            ctx.fillStyle = boar.isBoss ? '#3a1818' : '#4a3528';
            ctx.beginPath();
            ctx.ellipse(boar.width / 8, bobY - boar.height / 2.5, 8, 12, -0.3, 0, Math.PI * 2);
            ctx.fill();

            // Stun effect
            if (boar.stunned > 0) {
                ctx.strokeStyle = `rgba(148, 0, 211, ${boar.stunned / 90})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, bobY, boar.width / 2 + 10, 0, Math.PI * 2);
                ctx.stroke();

                // Stars
                ctx.fillStyle = `rgba(200, 150, 255, ${boar.stunned / 90})`;
                for (let i = 0; i < 3; i++) {
                    const starAngle = gameTime / 20 + (i / 3) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.arc(
                        Math.cos(starAngle) * 25,
                        bobY - 25 + Math.sin(starAngle * 2) * 5,
                        4, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }

            ctx.restore();

            // Health bar (only if damaged)
            if (boar.health < boar.maxHealth) {
                const barWidth = boar.width * 0.8;
                const barHeight = 6;
                const barY = boar.y - boar.height / 2 - 15;

                ctx.fillStyle = '#1a1510';
                ctx.fillRect(boar.x - barWidth / 2 - 1, barY - 1, barWidth + 2, barHeight + 2);

                const healthPercent = boar.health / boar.maxHealth;
                const healthColor = boar.isBoss ? '#8b0000' : (healthPercent > 0.5 ? '#5a8a3a' : (healthPercent > 0.25 ? '#8a8a3a' : '#8a3a3a'));
                ctx.fillStyle = healthColor;
                ctx.fillRect(boar.x - barWidth / 2, barY, barWidth * healthPercent, barHeight);
            }
        }

function drawPablobitos(b) {
    ctx.save();
    ctx.translate(b.x, b.y);

    const bobY = Math.sin(b.walkFrame) * 3;
    const legOffset = Math.sin(b.walkFrame) * 5;

    // Flip based on movement direction
    if (Math.cos(b.angle) < 0) {
        ctx.scale(-1, 1);
    }

    // Shadow
    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
    ctx.beginPath();
    ctx.ellipse(0, b.height / 2 + 5, b.width / 2.5, 8, 0, 0, Math.PI * 2);
    ctx.fill();

    // ==================== ZAKRĘCONY OGONEK ====================
    ctx.strokeStyle = '#8b4560';
    ctx.lineWidth = 5;
    ctx.lineCap = 'round';
    ctx.beginPath();
    
    const tailBaseX = -b.width / 2 + 5;
    const tailBaseY = bobY - 5;
    const tailWiggle = Math.sin(b.walkFrame * 2) * 2;
    
    ctx.moveTo(tailBaseX, tailBaseY);
    ctx.bezierCurveTo(
        tailBaseX - 12, tailBaseY - 8 + tailWiggle,
        tailBaseX - 22, tailBaseY + 8 + tailWiggle,
        tailBaseX - 18, tailBaseY - 12 + tailWiggle
    );
    ctx.bezierCurveTo(
        tailBaseX - 14, tailBaseY - 25 + tailWiggle,
        tailBaseX - 6, tailBaseY - 20 + tailWiggle,
        tailBaseX - 10, tailBaseY - 14 + tailWiggle
    );
    ctx.stroke();

    // ==================== NOGI (2x większe, trochę niżej) ====================
    ctx.fillStyle = '#6b3548';
    const legY = b.height / 3 + 2;
    const legWidth = 16;
    const legHeight = 28;
    
    // Back legs
    ctx.fillRect(-b.width / 3 - legOffset - 3, legY, legWidth, legHeight);
    ctx.fillRect(-b.width / 3 + legOffset + 10, legY, legWidth, legHeight);
    // Front legs
    ctx.fillRect(b.width / 5 + legOffset, legY, legWidth, legHeight);
    ctx.fillRect(b.width / 5 - legOffset + 12, legY, legWidth, legHeight);
    
    // Kopyta (większe)
    ctx.fillStyle = '#2a1520';
    ctx.fillRect(-b.width / 3 - legOffset - 3, legY + legHeight - 6, legWidth, 7);
    ctx.fillRect(-b.width / 3 + legOffset + 10, legY + legHeight - 6, legWidth, 7);
    ctx.fillRect(b.width / 5 + legOffset, legY + legHeight - 6, legWidth, 7);
    ctx.fillRect(b.width / 5 - legOffset + 12, legY + legHeight - 6, legWidth, 7);

    // ==================== CIAŁO ====================
    const bodyGrad = ctx.createRadialGradient(0, bobY, 0, 0, bobY, b.width / 2);
    bodyGrad.addColorStop(0, '#a85a75');
    bodyGrad.addColorStop(0.7, '#7d3a55');
    bodyGrad.addColorStop(1, '#5c2540');
    
    ctx.fillStyle = bodyGrad;
    ctx.beginPath();
    ctx.ellipse(0, bobY, b.width / 2, b.height / 2, 0, 0, Math.PI * 2);
    ctx.fill();

    // Blizny na ciele
    ctx.strokeStyle = '#4a2030';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-b.width / 5, bobY - b.height / 6);
    ctx.lineTo(-b.width / 8, bobY);
    ctx.lineTo(-b.width / 4, bobY + b.height / 8);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(b.width / 10, bobY + b.height / 5);
    ctx.lineTo(-b.width / 15, bobY + b.height / 4);
    ctx.stroke();

    // ==================== IROKEZ (wzdłuż okrągłego tułowia) ====================
const spikeCount = 16;
const spikeHeight = 28;

for (let i = 0; i < spikeCount; i++) {
    // Kąt wzdłuż górnej części elipsy (nie tak daleko do tyłu)
    const t = i / (spikeCount - 1);
    const angle = Math.PI * 0.75 + t * Math.PI * 0.9; // Krótsza sekcja, nie zakrywa ogonka
    
    // Pozycja na elipsie - dalej od środka
    const baseX = Math.cos(angle) * b.width / 2 * 0.95;
    const baseY = bobY + Math.sin(angle) * b.height / 2 * 0.95;
    
    // Kierunek kolca (prostopadle do powierzchni)
    const normalX = Math.cos(angle);
    const normalY = Math.sin(angle);
    
    // Animacja falowania
    const spikeWave = Math.sin(b.walkFrame * 1.5 + i * 0.4) * 3;
    const thisHeight = spikeHeight - Math.abs(i - spikeCount / 2) * 0.8;
    
    // Główny kolec
    const spikeGrad = ctx.createLinearGradient(
        baseX, baseY,
        baseX + normalX * thisHeight, baseY + normalY * thisHeight
    );
    spikeGrad.addColorStop(0, '#2a1520');
    spikeGrad.addColorStop(0.5, '#1a0a10');
    spikeGrad.addColorStop(1, '#0a0005');
    
    ctx.fillStyle = spikeGrad;
    ctx.beginPath();
    
    const perpX = -normalY;
    const perpY = normalX;
    
    ctx.moveTo(baseX + perpX * 5, baseY + perpY * 5);
    ctx.lineTo(baseX + normalX * thisHeight + spikeWave, baseY + normalY * thisHeight + spikeWave * 0.3);
    ctx.lineTo(baseX - perpX * 5, baseY - perpY * 5);
    ctx.closePath();
    ctx.fill();
    
    // Mniejsze kolce między głównymi
    if (i < spikeCount - 1) {
        const t2 = (i + 0.5) / (spikeCount - 1);
        const angle2 = Math.PI * 0.75 + t2 * Math.PI * 0.9;
        const smallBaseX = Math.cos(angle2) * b.width / 2 * 0.95;
        const smallBaseY = bobY + Math.sin(angle2) * b.height / 2 * 0.95;
        const smallNormalX = Math.cos(angle2);
        const smallNormalY = Math.sin(angle2);
        const smallHeight = thisHeight * 0.6;
        const smallWave = Math.sin(b.walkFrame * 1.5 + (i + 0.5) * 0.4) * 2;
        
        const smallPerpX = -smallNormalY;
        const smallPerpY = smallNormalX;
        
        ctx.fillStyle = '#1a0a10';
        ctx.beginPath();
        ctx.moveTo(smallBaseX + smallPerpX * 3, smallBaseY + smallPerpY * 3);
        ctx.lineTo(smallBaseX + smallNormalX * smallHeight + smallWave, smallBaseY + smallNormalY * smallHeight + smallWave * 0.3);
        ctx.lineTo(smallBaseX - smallPerpX * 3, smallBaseY - smallPerpY * 3);
        ctx.closePath();
        ctx.fill();
    }
}

    // ==================== GŁOWA ====================
    ctx.fillStyle = '#8b4a60';
    ctx.beginPath();
    ctx.ellipse(b.width / 3, bobY, b.width / 4, b.height / 3, 0, 0, Math.PI * 2);
    ctx.fill();

    // ==================== RYJE ====================
    ctx.fillStyle = '#9a6070';
    ctx.beginPath();
    ctx.ellipse(b.width / 2.2, bobY + 5, b.width / 7, b.height / 5, 0, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.strokeStyle = '#5a3040';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Nozdrza
    ctx.fillStyle = '#2a1015';
    ctx.beginPath();
    ctx.ellipse(b.width / 2.1, bobY + 2, 4, 3, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(b.width / 2.1, bobY + 9, 4, 3, 0, 0, Math.PI * 2);
    ctx.fill();

    // ==================== KIEŁY ====================
    ctx.fillStyle = '#d8d0c0';
    ctx.strokeStyle = '#8a8070';
    ctx.lineWidth = 1;
    
    // Górny kieł
    ctx.beginPath();
    ctx.moveTo(b.width / 3, bobY - b.height / 4);
    ctx.quadraticCurveTo(b.width / 2 + 15, bobY - b.height / 2.5, b.width / 2.2, bobY - b.height / 5);
    ctx.lineTo(b.width / 3.2, bobY - b.height / 4.5);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // Dolny kieł
    ctx.beginPath();
    ctx.moveTo(b.width / 3, bobY + b.height / 4);
    ctx.quadraticCurveTo(b.width / 2 + 15, bobY + b.height / 2.5, b.width / 2.2, bobY + b.height / 5);
    ctx.lineTo(b.width / 3.2, bobY + b.height / 4.5);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // ==================== OKO ====================
    ctx.fillStyle = '#2a1520';
    ctx.beginPath();
    ctx.ellipse(b.width / 4, bobY - b.height / 5, 8, 6, 0, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#aa2020';
    ctx.beginPath();
    ctx.ellipse(b.width / 4, bobY - b.height / 5, 6, 5, 0, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#ff6666';
    ctx.beginPath();
    ctx.arc(b.width / 4 + 2, bobY - b.height / 5 - 1, 2, 0, Math.PI * 2);
    ctx.fill();

    // ==================== BREW ====================
    ctx.strokeStyle = '#1a0a10';
    ctx.lineWidth = 5;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(b.width / 3.5, bobY - b.height / 3.2);
    ctx.lineTo(b.width / 8, bobY - b.height / 2.8);
    ctx.stroke();

    // ==================== USZY ====================
    ctx.fillStyle = '#7a4055';
    ctx.beginPath();
    ctx.ellipse(b.width / 8, bobY - b.height / 2.3, 10, 14, -0.4, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#5a3040';
    ctx.beginPath();
    ctx.ellipse(b.width / 8, bobY - b.height / 2.3, 5, 8, -0.4, 0, Math.PI * 2);
    ctx.fill();

    // Naderwane ucho
    ctx.strokeStyle = '#3a1525';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(b.width / 12, bobY - b.height / 2);
    ctx.lineTo(b.width / 10, bobY - b.height / 1.8);
    ctx.stroke();

    ctx.restore();
}

function drawIntroScene() {
    if (!pablobitos || !pablobitos.isIntro) return;

    ctx.save();
    
    const bx = pablobitos.x;
    const by = pablobitos.y;

    // ==================== 1. DALEKIE DRZEWA I KRZEWY (tło) ====================
    
    // Góra-lewo - gęściej
    drawRealisticTree(bx - 280, by - 240, 0.55, 0.08, true, true);
    drawRealisticTree(bx - 180, by - 280, 0.48, -0.05, true, false);
    drawRealisticTree(bx - 350, by - 200, 0.52, 0.12, true, true);
    drawBush(bx - 240, by - 190, 0.35, true);
    drawBush(bx - 310, by - 260, 0.3, false);
    
    // Góra-środek
    drawRealisticTree(bx - 60, by - 300, 0.45, -0.03, true, false);
    drawRealisticTree(bx + 40, by - 280, 0.5, 0.06, true, true);
    drawBush(bx - 20, by - 240, 0.32, true);
    drawBush(bx + 90, by - 260, 0.28, false);
    
    // Góra-prawo - tylko małe drzewka i krzewy
    drawRealisticTree(bx + 180, by - 260, 0.4, -0.08, true, true);
    drawRealisticTree(bx + 280, by - 220, 0.38, 0.04, true, false);
    drawBush(bx + 220, by - 200, 0.4, true);
    drawBush(bx + 320, by - 240, 0.35, false);
    drawBush(bx + 150, by - 210, 0.3, true);
    
    // Lewo
    drawRealisticTree(bx - 380, by - 80, 0.6, -0.1, true, true);
    drawRealisticTree(bx - 420, by + 40, 0.55, 0.05, true, false);
    drawRealisticTree(bx - 350, by + 120, 0.5, -0.08, true, true);
    drawBush(bx - 320, by - 30, 0.45, false);
    drawBush(bx - 380, by + 90, 0.38, true);
    drawBush(bx - 290, by + 60, 0.4, true);
    
    // Prawo - tylko krzewy i małe drzewka
    drawBush(bx + 300, by - 60, 0.5, true);
    drawBush(bx + 350, by + 20, 0.45, false);
    drawBush(bx + 280, by + 80, 0.48, true);
    drawBush(bx + 320, by + 140, 0.4, false);
    drawRealisticTree(bx + 380, by - 20, 0.35, 0.06, true, true);
    drawRealisticTree(bx + 360, by + 100, 0.32, -0.04, true, false);
    
    // Dół-lewo
    drawRealisticTree(bx - 300, by + 200, 0.5, 0.07, true, true);
    drawRealisticTree(bx - 200, by + 250, 0.45, -0.05, true, false);
    drawBush(bx - 250, by + 180, 0.38, true);
    drawBush(bx - 150, by + 220, 0.35, false);
    
    // Dół-środek (daleko za bagnem)
    drawBush(bx - 40, by + 280, 0.3, true);
    drawBush(bx + 60, by + 260, 0.32, false);
    drawRealisticTree(bx + 20, by + 300, 0.4, 0.03, true, true);
    
    // Dół-prawo - krzewy
    drawBush(bx + 180, by + 220, 0.42, true);
    drawBush(bx + 250, by + 180, 0.38, false);
    drawBush(bx + 140, by + 260, 0.35, true);
    
    // Dodatkowe rozproszone krzewy w tle
    drawBush(bx - 400, by - 150, 0.28, false);
    drawBush(bx - 450, by + 160, 0.3, true);
    drawBush(bx + 400, by - 100, 0.32, false);
    drawBush(bx + 420, by + 60, 0.28, true);
    drawBush(bx - 100, by + 300, 0.25, false);
    drawBush(bx + 100, by + 320, 0.27, true);

    // ==================== 2. BAGNO (wycentrowane) ====================
    const swampW = 380;
    const swampH = 140;
    const bubble = Math.sin(gameTime * 0.08) * 8;
    const swampY = by; // Wycentrowane
    
    // Zewnętrzna warstwa
    ctx.fillStyle = '#4a5a65';
    ctx.beginPath();
    ctx.ellipse(bx, swampY, swampW / 2 + bubble, swampH / 2, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Środkowa warstwa
    ctx.fillStyle = '#3d4d58';
    ctx.beginPath();
    ctx.ellipse(bx, swampY + 2, swampW / 2.5 + bubble * 0.7, swampH / 2.5, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Wewnętrzna warstwa
    ctx.fillStyle = '#2e3a42';
    ctx.beginPath();
    ctx.ellipse(bx, swampY + 5, swampW / 3 + bubble * 0.5, swampH / 3, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Bąble w bagnie
    ctx.fillStyle = '#5a6a75';
    for (let i = 0; i < 8; i++) {
        const bubbleX = bx + Math.sin(gameTime * 0.1 + i * 2) * (swampW / 3);
        const bubbleY = swampY - 10 + Math.cos(gameTime * 0.15 + i) * 20;
        const bubbleSize = 4 + Math.sin(gameTime * 0.2 + i * 1.5) * 3;
        
        if (bubbleSize > 3) {
            ctx.beginPath();
            ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    // Pływające zanieczyszczenia
    ctx.strokeStyle = '#3a4550';
    ctx.lineWidth = 2;
    for (let i = 0; i < 6; i++) {
        const debrisX = bx - 120 + i * 50 + Math.sin(gameTime * 0.05 + i) * 15;
        const debrisY = swampY - 15 + Math.cos(gameTime * 0.07 + i * 2) * 8;
        
        ctx.beginPath();
        ctx.moveTo(debrisX - 10, debrisY);
        ctx.quadraticCurveTo(debrisX, debrisY - 5, debrisX + 10, debrisY + 2);
        ctx.stroke();
    }

    // ==================== 3. ŚREDNIE DRZEWA ====================
    
    // Lewo - duże
    drawRealisticTree(bx - 320, by - 40, 1.2, -0.08, false, true);
    drawRealisticTree(bx - 280, by + 100, 1.0, 0.06, false, false);
    drawRealisticTree(bx - 250, by - 150, 0.95, 0.04, false, true);
    
    // Góra-lewo
    drawRealisticTree(bx - 150, by - 180, 0.9, -0.05, false, true);
    drawRealisticTree(bx - 80, by - 200, 0.85, 0.07, false, false);
    
    // Góra-prawo - mniejsze
    drawRealisticTree(bx + 100, by - 190, 0.7, -0.04, false, true);
    drawRealisticTree(bx + 160, by - 160, 0.65, 0.05, false, false);
    
    // Prawo - tylko krzewy i małe
    drawBush(bx + 240, by - 80, 0.7, true);
    drawBush(bx + 260, by + 40, 0.65, false);
    drawBush(bx + 220, by + 120, 0.6, true);
    
    // Dół
    drawBush(bx - 180, by + 160, 0.6, true);
    drawBush(bx + 50, by + 180, 0.55, false);
    drawBush(bx - 60, by + 200, 0.5, true);

    // ==================== 4. PABLOBITOS (Wynurzanie) ====================
    const progress = 1 - (bossIntroTimer / bossIntroDuration);
    let emerge = 0;
    if (progress > 0.2 && progress < 0.8) {
        emerge = (progress - 0.2) / 0.6;
    } else if (progress >= 0.8) {
        emerge = 1;
    }

    const currentY = swampY + 80 * (1 - emerge);

    ctx.save();
    ctx.beginPath();
    ctx.rect(bx - 200, swampY - 250, 400, 250 + 10);
    ctx.clip();

    const tempBoss = { ...pablobitos, y: currentY };
    drawPablobitos(tempBoss);
    
    ctx.restore();
    
    // Rozbryzg wody przy wynurzaniu
    if (emerge > 0.1 && emerge < 0.9) {
        ctx.fillStyle = '#3a4a55';
        for (let i = 0; i < 12; i++) {
            const splashX = bx + (Math.random() - 0.5) * 100;
            const splashY = swampY - 15 - Math.random() * 30 * emerge;
            const splashSize = 3 + Math.random() * 5;
            
            ctx.beginPath();
            ctx.arc(splashX, splashY, splashSize, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // ==================== 5. BLISKIE DRZEWA (tylko lewo i góra) ====================
    
    // Lewo - duże
    drawRealisticTree(bx - 450, by - 20, 1.6, -0.05, false, true);
    drawRealisticTree(bx - 400, by + 120, 1.4, 0.08, false, false);
    drawRealisticTree(bx - 380, by - 130, 1.35, -0.03, false, true);
    
    // Góra-lewo
    drawRealisticTree(bx - 200, by - 220, 1.3, 0.06, false, true);
    drawRealisticTree(bx - 120, by - 250, 1.2, -0.04, false, false);
    
    // Góra-środek (dalej od środka)
    drawRealisticTree(bx + 30, by - 280, 1.1, 0.03, false, true);
    
    // Prawo - tylko krzewy
    drawBush(bx + 380, by - 40, 0.9, true);
    drawBush(bx + 350, by + 80, 0.85, false);
    drawBush(bx + 400, by + 150, 0.8, true);
    drawBush(bx + 320, by - 100, 0.75, false);
    
    // Dół - krzewy
    drawBush(bx - 220, by + 200, 0.8, true);
    drawBush(bx + 120, by + 220, 0.75, false);
    drawBush(bx - 80, by + 240, 0.7, true);
    drawBush(bx + 200, by + 190, 0.72, false);

    // ==================== 6. MGŁA ====================
    for (let i = 0; i < 10; i++) {
        const fogX = bx + Math.sin(gameTime * 0.03 + i * 1.3) * 200 - 100;
        const fogY = swampY - 30 + Math.cos(gameTime * 0.02 + i * 0.8) * 25;
        const fogSize = 50 + Math.sin(gameTime * 0.04 + i) * 20;
        const fogAlpha = 0.15 + Math.sin(gameTime * 0.05 + i * 2) * 0.08;
        
        ctx.fillStyle = `rgba(74, 80, 85, ${fogAlpha})`;
        ctx.beginPath();
        ctx.arc(fogX, fogY, fogSize, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Smugi mgły
    for (let i = 0; i < 5; i++) {
        const streakX = bx - 300 + (gameTime * 0.5 + i * 150) % 600;
        const streakY = swampY - 50 + i * 15;
        
        ctx.strokeStyle = 'rgba(90, 95, 100, 0.1)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(streakX - 80, streakY);
        ctx.quadraticCurveTo(streakX, streakY - 10, streakX + 80, streakY + 5);
        ctx.stroke();
    }

    ctx.restore();
}

// ==================== KRZEW ====================
function drawBush(x, y, scale, hasLeaves) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);
    
    const trunkColor = '#4a3525';
    const leafColors = ['#2d4a1c', '#3b5a25', '#384d20'];
    const deadLeafColors = ['#5c4a30', '#6b5535'];
    
    ctx.strokeStyle = trunkColor;
    ctx.lineCap = 'round';
    ctx.lineWidth = 3;
    
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.quadraticCurveTo(-15, -20, -25, -40);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.quadraticCurveTo(10, -25, 20, -45);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.quadraticCurveTo(-5, -30, -10, -50);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.quadraticCurveTo(18, -15, 30, -30);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.quadraticCurveTo(-20, -10, -35, -25);
    ctx.stroke();
    
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-20, -35);
    ctx.lineTo(-30, -50);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(15, -40);
    ctx.lineTo(25, -55);
    ctx.stroke();
    
    if (hasLeaves) {
        const leafPositions = [
            { x: -25, y: -42 }, { x: -30, y: -50 }, { x: -20, y: -35 },
            { x: 20, y: -47 }, { x: 25, y: -55 }, { x: 15, y: -40 },
            { x: -10, y: -52 }, { x: -5, y: -48 }, { x: 0, y: -45 },
            { x: 30, y: -32 }, { x: -35, y: -27 }, { x: 10, y: -50 },
            { x: -15, y: -55 }, { x: 5, y: -52 }, { x: -28, y: -45 }
        ];
        
        for (let i = 0; i < leafPositions.length; i++) {
            const leaf = leafPositions[i];
            const colorArray = i % 4 === 0 ? deadLeafColors : leafColors;
            ctx.fillStyle = colorArray[i % colorArray.length];
            
            const lsize = 5 + (i % 3);
            const angle = (i * 0.7) % Math.PI;
            
            ctx.beginPath();
            ctx.ellipse(leaf.x, leaf.y, lsize, lsize * 0.6, angle, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    ctx.restore();
}

// ==================== REALISTYCZNE DRZEWO ====================
function drawRealisticTree(x, y, scale, rot, isBackground, hasLeaves) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);
    ctx.rotate(rot);
    
    const trunkDark = isBackground ? '#3d2817' : '#4a3020';
    const trunkMid = isBackground ? '#5c3d25' : '#6b4830';
    const trunkLight = isBackground ? '#7a5035' : '#8b6040';
    
    const leafColors = ['#2d4a1c', '#3b5a25', '#4a6630', '#384d20'];
    const deadLeafColors = ['#5c4a30', '#6b5535', '#7a6040'];
    
    // Pień
    ctx.fillStyle = trunkMid;
    ctx.beginPath();
    ctx.moveTo(-14, 0);
    ctx.quadraticCurveTo(-18, -50, -12, -100);
    ctx.quadraticCurveTo(-10, -130, -6, -150);
    ctx.lineTo(6, -150);
    ctx.quadraticCurveTo(12, -125, 14, -90);
    ctx.quadraticCurveTo(18, -45, 12, 0);
    ctx.closePath();
    ctx.fill();
    
    // Cień na pniu
    ctx.fillStyle = trunkDark;
    ctx.beginPath();
    ctx.moveTo(-14, 0);
    ctx.quadraticCurveTo(-18, -50, -12, -100);
    ctx.quadraticCurveTo(-10, -130, -6, -150);
    ctx.lineTo(-2, -150);
    ctx.quadraticCurveTo(-6, -120, -8, -90);
    ctx.quadraticCurveTo(-10, -45, -6, 0);
    ctx.closePath();
    ctx.fill();
    
    // Tekstura kory
    if (!isBackground) {
        ctx.strokeStyle = trunkDark;
        ctx.lineWidth = 1;
        for (let i = 0; i < 8; i++) {
            const ty = -15 - i * 18;
            const offset = (i % 2) * 3;
            ctx.beginPath();
            ctx.moveTo(-10 + offset, ty);
            ctx.quadraticCurveTo(-5 + offset, ty - 4, 2 + offset, ty - 2);
            ctx.stroke();
        }
        
        ctx.fillStyle = trunkDark;
        ctx.beginPath();
        ctx.ellipse(-5, -60, 4, 3, 0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(4, -100, 3, 2, -0.2, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Główne gałęzie
    ctx.strokeStyle = trunkMid;
    ctx.lineCap = 'round';
    
    ctx.lineWidth = isBackground ? 6 : 10;
    ctx.beginPath();
    ctx.moveTo(-6, -80);
    ctx.quadraticCurveTo(-40, -100, -60, -120);
    ctx.stroke();
    
    ctx.strokeStyle = trunkDark;
    ctx.lineWidth = isBackground ? 3 : 5;
    ctx.beginPath();
    ctx.moveTo(-8, -78);
    ctx.quadraticCurveTo(-42, -98, -62, -118);
    ctx.stroke();
    
    ctx.strokeStyle = trunkMid;
    
    ctx.lineWidth = isBackground ? 6 : 10;
    ctx.beginPath();
    ctx.moveTo(5, -100);
    ctx.quadraticCurveTo(35, -115, 55, -140);
    ctx.stroke();
    
    ctx.lineWidth = isBackground ? 5 : 8;
    ctx.beginPath();
    ctx.moveTo(0, -145);
    ctx.quadraticCurveTo(5, -170, 15, -190);
    ctx.stroke();
    
    // Mniejsze gałęzie
    ctx.strokeStyle = trunkLight;
    ctx.lineWidth = isBackground ? 2 : 4;
    
    ctx.beginPath();
    ctx.moveTo(-35, -95);
    ctx.quadraticCurveTo(-50, -110, -70, -115);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(-50, -112);
    ctx.lineTo(-65, -135);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(-55, -118);
    ctx.lineTo(-45, -140);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(30, -110);
    ctx.quadraticCurveTo(50, -120, 70, -125);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(45, -125);
    ctx.lineTo(60, -150);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(50, -135);
    ctx.lineTo(40, -160);
    ctx.stroke();
    
    ctx.lineWidth = isBackground ? 1 : 3;
    ctx.beginPath();
    ctx.moveTo(8, -165);
    ctx.lineTo(25, -175);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(12, -180);
    ctx.lineTo(-5, -200);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(14, -188);
    ctx.lineTo(30, -205);
    ctx.stroke();
    
    // Liście (statyczne)
    if (hasLeaves) {
        const leafPositions = [
            { x: -65, y: -125, size: 5 }, { x: -70, y: -130, size: 6 }, { x: -60, y: -120, size: 4 },
            { x: -68, y: -118, size: 5 }, { x: -72, y: -125, size: 4 }, { x: -62, y: -128, size: 6 },
            { x: -50, y: -140, size: 5 }, { x: -55, y: -145, size: 4 }, { x: -45, y: -138, size: 5 },
            { x: -48, y: -135, size: 6 }, { x: -52, y: -142, size: 4 },
            { x: -70, y: -110, size: 5 }, { x: -75, y: -115, size: 4 }, { x: -65, y: -108, size: 6 },
            { x: 60, y: -130, size: 5 }, { x: 65, y: -135, size: 6 }, { x: 55, y: -125, size: 4 },
            { x: 58, y: -128, size: 5 }, { x: 68, y: -132, size: 4 }, { x: 62, y: -138, size: 5 },
            { x: 45, y: -155, size: 4 }, { x: 50, y: -160, size: 5 }, { x: 40, y: -152, size: 6 },
            { x: 70, y: -120, size: 5 }, { x: 75, y: -125, size: 4 }, { x: 65, y: -118, size: 6 },
            { x: 20, y: -195, size: 5 }, { x: 25, y: -200, size: 4 }, { x: 15, y: -192, size: 6 },
            { x: -5, y: -205, size: 4 }, { x: 0, y: -210, size: 5 }, { x: -10, y: -202, size: 5 },
            { x: 30, y: -200, size: 5 }, { x: 35, y: -205, size: 4 }, { x: 25, y: -198, size: 6 },
            { x: 10, y: -175, size: 5 }, { x: 15, y: -180, size: 4 }, { x: 5, y: -172, size: 6 }
        ];
        
        for (let i = 0; i < leafPositions.length; i++) {
            const leaf = leafPositions[i];
            const colorArray = i % 5 === 0 ? deadLeafColors : leafColors;
            ctx.fillStyle = colorArray[i % colorArray.length];
            
            const angle = (i * 0.5) % Math.PI;
            
            ctx.beginPath();
            ctx.ellipse(leaf.x, leaf.y, leaf.size, leaf.size * 0.6, angle, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    // Korzenie
    if (!isBackground) {
        ctx.strokeStyle = trunkMid;
        ctx.lineWidth = 6;
        
        ctx.beginPath();
        ctx.moveTo(-12, 0);
        ctx.quadraticCurveTo(-30, 8, -45, 18);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(-8, 0);
        ctx.quadraticCurveTo(-18, 12, -25, 25);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(10, 0);
        ctx.quadraticCurveTo(28, 10, 40, 20);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(6, 0);
        ctx.quadraticCurveTo(12, 15, 18, 28);
        ctx.stroke();
        
        ctx.strokeStyle = trunkDark;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-14, 2);
        ctx.quadraticCurveTo(-32, 10, -47, 20);
        ctx.stroke();
    }
    
    ctx.restore();
}
         function drawBossIntro() {
            if (pablobitos && pablobitos.isIntro) {
                // Reset kamery dla UI
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);

                const w = gameCanvas.width;
                const h = gameCanvas.height;
                const progress = 1 - (bossIntroTimer / bossIntroDuration);

                // 1. CZARNE PASY (Animacja Wjazd / Wyjazd)
                const barMaxHeight = 160; 
                let animFactor = 1;

                // Faza wejścia (0% - 25%): Rozsuwanie
                if (progress < 0.25) {
                    animFactor = progress * 4;
                } 
                // Faza wyjścia (85% - 100%): Zsuwanie (Retract)
                else if (progress > 0.85) {
                    // (1 - progress) daje nam wartość od 0.15 do 0.0
                    // Dzielimy przez 0.15, żeby uzyskać zakres 1.0 -> 0.0
                    animFactor = (1 - progress) / 0.15;
                }

                const currentBarH = barMaxHeight * animFactor;
                
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, w, currentBarH); // Góra
                ctx.fillRect(0, h - currentBarH, w, currentBarH); // Dół

                // 2. TEKST (Widoczny tylko gdy pasy są rozsunięte)
                // Przestajemy rysować tekst, gdy zaczyna się faza wyjścia (0.85)
                if (progress > 0.2 && progress < 0.85) {
                    const name = "PABLOBITOS";
                    const textProgress = (progress - 0.2) / 0.5;
                    const lettersToShow = Math.floor(textProgress * (name.length + 1));

                    // Styl identyczny jak Wave Announcement
                    ctx.font = '60px Georgia, serif'; 
                    ctx.textAlign = 'left';
                    const letterSpacing = 5;

                    let totalWidth = 0;
                    for (let char of name) totalWidth += ctx.measureText(char).width + letterSpacing;
                    
                    let startX = (w / 2) - (totalWidth / 2);
                    const textY = h - 90; 

                    for (let i = 0; i < name.length; i++) {
                        if (i < lettersToShow) {
                            const char = name[i];
                            
                            // Czy to jest "świeża" litera? (Ta, która się właśnie pojawiła)
                            // Sprawdzamy, czy 'i' jest równe ostatniemu indeksowi
                            // Używamy ułamkowej części textProgress do animacji uderzenia
                            const isNew = (i === lettersToShow - 1);
                            
                            // Animacja uderzenia (Scale down)
                            // Jeśli litera jest nowa, bierzemy resztkę z textProgress (np. 0.8 -> skala 1.2)
                            let scaleMult = 1.0;
                            let alphaFlash = 0;
                            
                            if (isNew) {
                                const animTime = (textProgress * (name.length + 1)) % 1; // 0.0 -> 1.0 dla każdej litery
                                // Szybkie skalowanie od 2.0 do 1.0
                                scaleMult = 1 + (1 - animTime) * 1.5;
                                alphaFlash = 1 - animTime; // Zanikanie błysku
                            }

                            if (char !== ' ') {
                                const centerX = startX + ctx.measureText(char).width/2;
                                
                                ctx.save();
                                // Ustawiamy punkt obrotu/skali na środku litery
                                ctx.translate(centerX, textY);
                                ctx.scale(scaleMult, scaleMult);
                                ctx.translate(-centerX, -textY);

                                // A. OGIEŃ (Tło - bez zmian)
                                ctx.save();
                                ctx.globalCompositeOperation = 'lighter'; 
                                for (let f = 0; f < 5; f++) { 
                                    // ... (Twój kod ognia - wklej go tutaj lub zostaw jeśli modyfikujesz istniejący) ...
                                    // Skopiuj logikę ognia z poprzedniej wersji
                                    const time = gameTime * 0.12;
                                    const offset = f * 1.5;
                                    const flameW = 20 + Math.sin(time+offset)*5; 
                                    const flameH = 60 + Math.sin(time*1.5+offset)*20;
                                    const sway = Math.sin(time*2+offset)*15;
                                    const fx = centerX + (Math.random()-0.5)*15;
                                    const fy = textY + 15; 
                                    const grad = ctx.createLinearGradient(fx, fy, fx, fy - flameH);
                                    grad.addColorStop(0, 'rgba(255, 255, 200, 0.6)');
                                    grad.addColorStop(0.4, 'rgba(255, 140, 0, 0.5)');
                                    grad.addColorStop(1, 'rgba(150, 0, 0, 0)');
                                    ctx.fillStyle = grad;
                                    ctx.beginPath(); ctx.moveTo(fx-flameW/2, fy); ctx.quadraticCurveTo(fx-flameW, fy-flameH/2, fx+sway, fy-flameH); ctx.quadraticCurveTo(fx+flameW, fy-flameH/2, fx+flameW/2, fy); ctx.fill();
                                }
                                ctx.restore();

                                // B. EKSPLOZJA (Od środka na zewnątrz)
                                if (isNew) {
                                    ctx.save();
                                    ctx.translate(centerX, textY - 25); // Środek wybuchu
                                    ctx.globalCompositeOperation = 'lighter'; // Tryb ognia
                                    
                                    // Parametr ekspansji (0.0 -> 1.0)
                                    const progress = 1 - alphaFlash; 
                                    
                                    // Rysujemy 12 "jęzorów" wybuchu rozchodzących się promieniście
                                    for(let k=0; k<12; k++) {
                                        const angle = (Math.PI * 2 / 12) * k;
                                        
                                        // Im większy progress, tym dalej od środka
                                        const dist = progress * 60; 
                                        const px = Math.cos(angle) * dist;
                                        const py = Math.sin(angle) * dist;
                                        
                                        // Im dalej, tym większe chmury (rozpraszanie się)
                                        const size = 15 + progress * 30;

                                        const grad = ctx.createRadialGradient(px, py, 0, px, py, size);
                                        // Jądro (Biało-Żółte)
                                        grad.addColorStop(0, `rgba(255, 255, 200, ${alphaFlash})`);
                                        // Środek (Pomarańcz)
                                        grad.addColorStop(0.4, `rgba(255, 140, 0, ${alphaFlash * 0.8})`);
                                        // Krawędź (Czerwona, szybko znika)
                                        grad.addColorStop(1, 'rgba(100, 0, 0, 0)');
                                        
                                        ctx.fillStyle = grad;
                                        ctx.beginPath(); ctx.arc(px, py, size, 0, Math.PI*2); ctx.fill();
                                    }

                                    // Centralny błysk (pozostaje w miejscu, szybko znika)
                                    const coreSize = 20 + progress * 10;
                                    const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, coreSize);
                                    coreGrad.addColorStop(0, `rgba(255, 255, 255, ${alphaFlash})`);
                                    coreGrad.addColorStop(1, 'rgba(255, 200, 50, 0)');
                                    ctx.fillStyle = coreGrad;
                                    ctx.beginPath(); ctx.arc(0, 0, coreSize, 0, Math.PI*2); ctx.fill();

                                    ctx.restore();
                                }

                                // C. LITERA
                                ctx.fillStyle = '#8b0000'; 
                                ctx.shadowColor = 'rgba(139, 0, 0, 0.8)'; ctx.shadowBlur = 20;
                                ctx.fillText(char, startX, textY);

                                ctx.shadowBlur = 0; ctx.shadowColor = '#000'; ctx.shadowOffsetX = 2; ctx.shadowOffsetY = 2;
                                ctx.globalCompositeOperation = 'source-over'; 
                                ctx.fillText(char, startX, textY);
                                
                                ctx.restore(); // Koniec skali
                            }
                        }
                        startX += ctx.measureText(name[i]).width + letterSpacing;
                    }

                    if (progress > 0.6) {
                        // Obliczamy przezroczystość (od 0.6 do 0.8 rośnie do 1.0)
                        let alpha = (progress - 0.6) / 0.2;
                        if (alpha > 1) alpha = 1;

                        ctx.save();
                        ctx.globalAlpha = alpha; // Ustawiamy przezroczystość
                        
                        ctx.fillStyle = '#cfd8dc'; 
                        ctx.font = 'italic 22px "Georgia", serif'; 
                        ctx.textAlign = 'center';
                        ctx.shadowColor = '#000'; ctx.shadowBlur = 4;
                        
                        ctx.fillText("- TUCZNIK ZAGŁADY -", w / 2, h - 45);
                        ctx.restore();
                    }
                }

                ctx.restore();
            }
        }
        function drawPlayer() {
            ctx.save();
            ctx.translate(player.x, player.y);

            // Invincibility flash
            if (player.invincible > 0 && Math.floor(player.invincible / 4) % 2 === 0) {
                ctx.globalAlpha = 0.5;
            }

            // Vape aura
            if (player.vapeActive) {
                const auraGrad = ctx.createRadialGradient(0, -15, 0, 0, -15, 70);
                auraGrad.addColorStop(0, `rgba(100, 50, 150, ${0.2 + Math.sin(gameTime / 8) * 0.1})`);
                auraGrad.addColorStop(1, 'rgba(100, 50, 150, 0)');
                ctx.fillStyle = auraGrad;
                ctx.beginPath();
                ctx.arc(0, -15, 70, 0, Math.PI * 2);
                ctx.fill();
            }

            const walkBob = Math.sin(player.walkFrame) * 2;
            const flip = player.facingRight ? 1 : -1;

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(0, 25, 20, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Legs
            ctx.fillStyle = '#2a3a2a';
            const legOffset = Math.sin(player.walkFrame) * 4;
            ctx.fillRect(-10 - legOffset, 5, 8, 25);
            ctx.fillRect(2 + legOffset, 5, 8, 25);

            // Boots
            ctx.fillStyle = '#1a1a15';
            ctx.fillRect(-12 - legOffset, 25, 12, 8);
            ctx.fillRect(0 + legOffset, 25, 12, 8);

            // Torso
            const torsoGrad = ctx.createLinearGradient(-18, -25, 18, 10);
            torsoGrad.addColorStop(0, '#3a4a3a');
            torsoGrad.addColorStop(1, '#2a3a2a');
            ctx.fillStyle = torsoGrad;
            ctx.fillRect(-18, -25 + walkBob, 36, 35);

            // --- PANCERZ (TIER 1 & 2) ---
            if (player.armorTier >= 1) {
                // Kamizelka taktyczna (Ciemnoszara/Czarna)
                ctx.fillStyle = '#2a2a2a'; // Ciemnoszary
                ctx.fillRect(-20, -27 + walkBob, 40, 28); // Szersza niż ciało
                
                // Detale kamizelki (Płyty/Kieszenie)
                ctx.fillStyle = '#1a1a1a'; // Czarny
                ctx.fillRect(-16, -20 + walkBob, 14, 12); // Lewa płyta
                ctx.fillRect(2, -20 + walkBob, 14, 12);   // Prawa płyta
                
                // Paski
                ctx.fillStyle = '#333';
                ctx.fillRect(-18, -25 + walkBob, 6, 25);
                ctx.fillRect(12, -25 + walkBob, 6, 25);
            } else {
                // Belt (tylko jak nie ma pancerza)
                ctx.fillStyle = '#3a2a1a';
                ctx.fillRect(-18, 5 + walkBob, 36, 6);
                ctx.fillStyle = '#8a7a50';
                ctx.fillRect(-3, 6 + walkBob, 6, 4);
            }

            // Collar (tylko Tier 0)
            if (player.armorTier === 0) {
                ctx.fillStyle = '#4a5a4a';
                ctx.beginPath();
                ctx.moveTo(-12, -25 + walkBob);
                ctx.lineTo(0, -20 + walkBob);
                ctx.lineTo(12, -25 + walkBob);
                ctx.lineTo(12, -22 + walkBob);
                ctx.lineTo(0, -17 + walkBob);
                ctx.lineTo(-12, -22 + walkBob);
                ctx.closePath();
                ctx.fill();
            }

            // Neck
            ctx.fillStyle = '#c9a882';
            ctx.fillRect(-6, -32 + walkBob, 12, 10);

            // Head
            ctx.fillStyle = '#c9a882';
            ctx.beginPath();
            ctx.ellipse(0, -45 + walkBob, 16, 18, 0, 0, Math.PI * 2);
            ctx.fill();

            // --- MASKA (TIER 2) ---
            if (player.armorTier === 2) {
                // Maska Gazowa (Ciemnoszara/Czarna)
                ctx.fillStyle = '#222'; // Czarna guma
                ctx.beginPath(); ctx.ellipse(0, -45 + walkBob, 17, 19, 0, 0, Math.PI * 2); ctx.fill();
                
                // Okulary maski (Świecące na zielono lub niebiesko)
                ctx.fillStyle = 'rgba(194, 163, 79, 0.6)'; // Szkło noktowizyjne
                ctx.beginPath(); ctx.arc(-7, -48 + walkBob, 6, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(7, -48 + walkBob, 6, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = '#111'; ctx.lineWidth=2; 
                ctx.stroke(); // Obwódki
                
                // Filtr na dole (Puszka)
                ctx.fillStyle = '#333'; // Szary metal
                ctx.fillRect(-8, -32 + walkBob, 16, 15);
                
                // Żebrowanie filtra
                ctx.strokeStyle = '#111'; ctx.lineWidth=1;
                ctx.beginPath(); ctx.moveTo(-8, -30+walkBob); ctx.lineTo(8, -30+walkBob); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(-8, -26+walkBob); ctx.lineTo(8, -26+walkBob); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(-8, -22+walkBob); ctx.lineTo(8, -22+walkBob); ctx.stroke();

            } else {
                // --- TWARZ (TIER 0 & 1) ---
                // Hair
                ctx.fillStyle = '#2a2520';
                ctx.beginPath();
                ctx.ellipse(0, -58 + walkBob, 14, 8, 0, Math.PI, 0);
                ctx.fill();

                // Face details
                ctx.fillStyle = '#1a1510';
                ctx.fillRect(-8, -48 + walkBob, 5, 3); // Oczy
                ctx.fillRect(3, -48 + walkBob, 5, 3);

                // Eyebrows
                ctx.fillStyle = '#2a2520';
                ctx.fillRect(-9, -53 + walkBob, 7, 2);
                ctx.fillRect(2, -53 + walkBob, 7, 2);

                // Nose
                ctx.fillStyle = '#b89872';
                ctx.beginPath();
                ctx.moveTo(0, -45 + walkBob);
                ctx.lineTo(3, -38 + walkBob);
                ctx.lineTo(-3, -38 + walkBob);
                ctx.closePath();
                ctx.fill();

                // Mustache
                ctx.fillStyle = '#2a2520';
                ctx.beginPath();
                ctx.moveTo(-10, -35 + walkBob);
                ctx.quadraticCurveTo(-5, -32 + walkBob, 0, -34 + walkBob);
                ctx.quadraticCurveTo(5, -32 + walkBob, 10, -35 + walkBob);
                ctx.quadraticCurveTo(5, -30 + walkBob, 0, -32 + walkBob);
                ctx.quadraticCurveTo(-5, -30 + walkBob, -10, -35 + walkBob);
                ctx.fill();

                // Scar
                ctx.strokeStyle = '#9a8872';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(12, -50 + walkBob);
                ctx.lineTo(14, -40 + walkBob);
                ctx.stroke();
            }

            // Forester hat (Zawsze widoczny, nawet z maską)
            ctx.fillStyle = '#3a4a3a';
            ctx.beginPath();
            ctx.ellipse(0, -60 + walkBob, 22, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#2a3a2a';
            ctx.beginPath();
            ctx.moveTo(-14, -60 + walkBob);
            ctx.quadraticCurveTo(0, -78 + walkBob, 14, -60 + walkBob);
            ctx.closePath();
            ctx.fill();

            // Hat band
            ctx.fillStyle = '#5a4a3a';
            ctx.fillRect(-14, -62 + walkBob, 28, 4);

            // Ikona naprawy nad głową
            if (player.isRepairing) {
                const bounce = Math.sin(gameTime / 5) * 3;
                ctx.fillStyle = '#ffffff';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('🛠️', 0, -80 + bounce);
            }
            
            //pasek zdrowia
            if (player.health < player.maxHealth) {
                const barWidth = 40; // Stała szerokość
                const barHeight = 6;
                const yPos = -80; // Nad głową

                // Tło (Ciemne)
                ctx.fillStyle = '#1a1510';
                ctx.fillRect(-barWidth / 2 - 1, yPos - 1, barWidth + 2, barHeight + 2);

                // Wypełnienie
                const pct = Math.max(0, player.health / player.maxHealth);
                
                // Kolory identyczne jak u dzików
                const color = pct > 0.5 ? '#5a8a3a' : (pct > 0.25 ? '#8a8a3a' : '#8a3a3a');

                ctx.fillStyle = color;
                ctx.fillRect(-barWidth / 2, yPos, barWidth * pct, barHeight);
            }

            ctx.restore();

                        // --- RĘKA I BROŃ (Z OBRÓTEM I ODRZUTEM) ---
            ctx.save();
            ctx.translate(player.x, player.y - 15); // Środek obrotu (ramię)
            ctx.rotate(player.angle);

            // Jeśli celujemy w lewo (kąt > 90 lub < -90 stopni), obróć broń w pionie
            if (Math.abs(player.angle) > Math.PI / 2) {
                ctx.scale(1, -1);
            }

            // Zastosuj odrzut (cofnięcie w osi X lokalnej)
            ctx.translate(-player.recoilOffset, 0);

            // Ramię (Zawsze na górze)
            ctx.fillStyle = player.armorTier >= 1 ? '#2a2a2a' : '#3a4a3a';
            ctx.fillRect(0, -5, 30, 10);

            // Dłoń
            ctx.fillStyle = '#c9a882'; 
            ctx.beginPath(); ctx.arc(28, 0, 6, 0, Math.PI * 2); ctx.fill();

            // --- RYSOWANIE BRONI ---
            if (player.weapon === 'revolver') {
                // REWOLWER (Bez zmian w wyglądzie, tylko kopiuj-wklej stary kod rysowania)
                // Rękojeść
                ctx.fillStyle = '#5d4037'; 
                ctx.beginPath(); ctx.moveTo(25, 4); ctx.lineTo(20, 18); ctx.quadraticCurveTo(25, 22, 32, 18); ctx.lineTo(34, 4); ctx.fill();
                ctx.fillStyle = '#bcaaa4'; ctx.beginPath(); ctx.arc(26, 10, 1.5, 0, Math.PI*2); ctx.fill(); // Śruba

                // Bębenek i rama
                const drumSize = player.revolverTier >= 1 ? 10 : 8;
                const drumColor = player.revolverTier === 2 ? '#37474f' : '#3a3a3a';
                ctx.fillStyle = '#263238'; ctx.fillRect(24, -6, 14, 12); 
                ctx.fillStyle = drumColor; ctx.beginPath(); ctx.arc(32, 0, drumSize, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#111';
                const chambers = player.revolverTier >= 1 ? 8 : 6;
                for (let i = 0; i < chambers; i++) {
                    // Uwaga: kąt komór musi uwzględniać scale(-1) przy celowaniu w lewo
                    const chamberAngle = (i / chambers) * Math.PI * 2 + gameTime / 50;
                    ctx.beginPath(); ctx.arc(32 + Math.cos(chamberAngle) * (drumSize-3), Math.sin(chamberAngle) * (drumSize-3), 1.5, 0, Math.PI * 2); ctx.fill();
                }
                ctx.fillStyle = '#212121'; ctx.beginPath(); ctx.moveTo(24, -6); ctx.lineTo(20, -10); ctx.lineTo(24, -8); ctx.fill(); // Kurek

                // Lufa
                if (player.revolverTier === 0) {
                    ctx.fillStyle = '#2a2a2a'; ctx.fillRect(36, -4, 24, 6);
                    ctx.fillRect(58, -6, 2, 2); ctx.fillStyle = '#000'; ctx.fillRect(60, -3, 2, 4);
                } else if (player.revolverTier === 1) {
                    ctx.fillStyle = '#37474f'; ctx.fillRect(36, -6, 26, 5); ctx.fillRect(36, 1, 26, 5);
                    ctx.fillStyle = '#263238'; ctx.fillRect(45, -1, 15, 2);
                    ctx.fillStyle = '#000'; ctx.fillRect(62, -5, 2, 3); ctx.fillRect(62, 2, 2, 3);
                } else {
                    ctx.fillStyle = '#263238'; ctx.fillRect(36, -8, 32, 16); 
                    ctx.fillStyle = '#1a2327'; ctx.fillRect(40, -8, 2, 16); ctx.fillRect(46, -8, 2, 16); ctx.fillRect(52, -8, 2, 16); ctx.fillRect(58, -8, 2, 16);
                    ctx.fillStyle = '#37474f'; ctx.fillRect(68, -6, 4, 4); ctx.fillRect(68, 2, 4, 4);  
                    ctx.fillStyle = '#000'; ctx.fillRect(72, -6, 2, 4); ctx.fillRect(72, 2, 2, 4);
                    ctx.fillStyle = '#111'; ctx.fillRect(36, -10, 30, 2); ctx.fillRect(66, -12, 2, 4);
                    ctx.fillStyle = '#3e2723'; ctx.fillRect(40, 8, 20, 4); 
                }
                // Spust
                ctx.strokeStyle = '#333'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(28, 5, 4, 0, Math.PI); ctx.stroke();

            } else {
                // SNAJPERKA
                ctx.translate(5, 2); // Przesunięcie do ręki

                if (player.sniperTier === 0) {
                    // Tier 0 (Drewno)
                    ctx.fillStyle = '#5d4037'; ctx.beginPath(); ctx.moveTo(25, -2); ctx.lineTo(-10, -4); ctx.lineTo(-10, 4); ctx.lineTo(5, 2); ctx.lineTo(10, 10); ctx.lineTo(20, 10); ctx.lineTo(25, 2); ctx.fill();
                    ctx.strokeStyle = '#111'; ctx.lineWidth=1; ctx.beginPath(); ctx.arc(18, 2, 5, 0, Math.PI*0.8); ctx.stroke(); ctx.beginPath(); ctx.moveTo(18, 2); ctx.lineTo(18, 5); ctx.stroke();
                    ctx.fillStyle = '#212121'; ctx.fillRect(20, -6, 25, 8); ctx.fillStyle = '#111'; ctx.fillRect(30, 2, 8, 6);
                    ctx.fillStyle = '#1a1a1a'; ctx.fillRect(45, -4, 55, 4);
                    ctx.fillStyle = '#000'; ctx.fillRect(25, -12, 25, 4); ctx.fillStyle = '#3e2723'; ctx.fillRect(28, -8, 2, 2); ctx.fillRect(45, -8, 2, 2);
                } else if (player.sniperTier === 1) {
                    // Tier 1 (Metal)
                    ctx.fillStyle = '#455a64'; ctx.beginPath(); ctx.moveTo(25, -2); ctx.lineTo(-10, -4); ctx.lineTo(-10, 4); ctx.lineTo(5, 2); ctx.lineTo(10, 10); ctx.lineTo(20, 10); ctx.lineTo(25, 2); ctx.fill();
                    ctx.strokeStyle = '#111'; ctx.beginPath(); ctx.arc(18, 2, 5, 0, Math.PI*0.8); ctx.stroke(); ctx.beginPath(); ctx.moveTo(18, 2); ctx.lineTo(18, 5); ctx.stroke();
                    ctx.fillStyle = '#263238'; ctx.fillRect(20, -7, 30, 10); ctx.fillStyle = '#111'; ctx.fillRect(30, 3, 10, 10); ctx.fillStyle = '#333'; ctx.fillRect(32, 5, 6, 6);
                    ctx.fillStyle = '#37474f'; ctx.fillRect(50, -5, 50, 6); ctx.fillStyle = '#111'; for(let i=0; i<6; i++) { ctx.beginPath(); ctx.arc(55 + i*7, -2, 1.5, 0, Math.PI*2); ctx.fill(); }
                    ctx.fillStyle = '#000'; ctx.fillRect(100, -6, 6, 8); ctx.fillStyle = '#111'; ctx.fillRect(22, -14, 30, 5);
                } else {
                    // Tier 2 (Gauss)
                    ctx.fillStyle = '#455a64'; ctx.beginPath(); ctx.moveTo(25, -2); ctx.lineTo(-10, -4); ctx.lineTo(-10, 4); ctx.lineTo(5, 2); ctx.lineTo(10, 10); ctx.lineTo(20, 10); ctx.lineTo(25, 2); ctx.fill();
                    ctx.strokeStyle = '#111'; ctx.beginPath(); ctx.arc(18, 2, 5, 0, Math.PI*0.8); ctx.stroke(); ctx.beginPath(); ctx.moveTo(18, 2); ctx.lineTo(18, 5); ctx.stroke();
                    ctx.fillStyle = '#263238'; ctx.fillRect(20, -7, 30, 10); ctx.fillStyle = '#111'; ctx.fillRect(30, 3, 10, 10); ctx.fillStyle = '#0288d1'; ctx.fillRect(33, 5, 4, 6);
                    ctx.fillStyle = '#111'; ctx.fillRect(22, -14, 30, 5);
                    ctx.fillStyle = '#37474f'; ctx.fillRect(50, -7, 55, 2); ctx.fillRect(50, 1, 55, 2);
                    ctx.fillStyle = '#b87333'; ctx.fillRect(60, -8, 6, 12); ctx.fillRect(75, -8, 6, 12); ctx.fillRect(90, -8, 6, 12);
                    ctx.fillStyle = '#fbc02d'; ctx.fillRect(25, -2, 15, 6); ctx.fillStyle = '#111'; ctx.fillRect(30, -3, 4, 8);
                    ctx.strokeStyle = '#d84315'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(40, 0); ctx.lineTo(60, -2); ctx.stroke();
                }
            }

            
            ctx.restore();
        }

                    function drawArmorStation() {
            ctx.save();
            ctx.translate(armorStation.x, armorStation.y);
            
            // Cień stołu
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.beginPath(); ctx.ellipse(0, 25, 45, 15, 0, 0, Math.PI*2); ctx.fill();

            // Nogi (Solidne, dębowe belki)
            ctx.fillStyle = '#3e2723'; // Ciemny brąz
            ctx.fillRect(-35, 0, 10, 25); // Lewa
            ctx.fillRect(25, 0, 10, 25);  // Prawa
            // Belka poprzeczna
            ctx.fillRect(-25, 15, 50, 6);

            // Blat (Grube drewno z fakturą)
            ctx.fillStyle = '#5d4037'; 
            ctx.fillRect(-40, -15, 80, 20);
            ctx.strokeStyle = '#3e2723'; ctx.lineWidth=2; ctx.strokeRect(-40, -15, 80, 20);
            
            // Faktura drewna (kreski)
            ctx.strokeStyle = '#4e342e'; ctx.lineWidth=1;
            ctx.beginPath();
            ctx.moveTo(-30, -15); ctx.lineTo(-30, 5);
            ctx.moveTo(10, -15); ctx.lineTo(10, 5);
            ctx.stroke();

            // Imadło (Po lewej stronie)
            ctx.fillStyle = '#546e7a'; // Szary metal
            ctx.fillRect(-42, -25, 12, 15); // Korpus
            ctx.fillRect(-45, -28, 4, 8); // Szczęka
            ctx.fillStyle = '#cfd8dc'; // Pokrętło
            ctx.beginPath(); ctx.arc(-36, -20, 2, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#cfd8dc'; ctx.beginPath(); ctx.moveTo(-36, -20); ctx.lineTo(-30, -15); ctx.stroke();

            // Papier z planami (Po prawej)
            ctx.fillStyle = '#fff9c4'; // Pożółkły papier
            ctx.save(); ctx.rotate(0.2);
            ctx.fillRect(15, -20, 20, 15);
            // Linie na papierze
            ctx.fillStyle = '#0277bd'; // Niebieski tusz
            ctx.fillRect(18, -17, 14, 1);
            ctx.fillRect(18, -14, 10, 1);
            ctx.restore();

            // PRZEDMIOTY DO KUPIENIA (Leżą na środku)
            if (player.armorTier < 2) {
                if (player.armorTier === 0) {
                    // Kamizelka (Złożona)
                    ctx.fillStyle = '#2a2a2a';
                    ctx.beginPath();
                    ctx.moveTo(-10, -16); ctx.lineTo(10, -16);
                    ctx.quadraticCurveTo(12, -10, 10, -5);
                    ctx.lineTo(-10, -5);
                    ctx.quadraticCurveTo(-12, -10, -10, -16);
                    ctx.fill();
                    // Paski
                    ctx.fillStyle = '#1a1a1a'; // Czarny (zamiast #1b5e20)
                    ctx.fillRect(-5, -16, 2, 11); ctx.fillRect(3, -16, 2, 11);
                } else {
                    // Maska (Mniejsza, leży obok)
                    ctx.fillStyle = '#333'; // Guma
                    ctx.beginPath(); ctx.arc(0, -10, 6, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#C2A34F'; // Szkła
                    ctx.beginPath(); ctx.arc(-3, -12, 2, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(3, -12, 2, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#555'; // Filtr
                    ctx.fillRect(-2, -6, 4, 6);
                }
            }

            // Narzędzia (Młotek leżący luźno)
            ctx.save(); ctx.translate(25, 5); ctx.rotate(-0.5);
            ctx.fillStyle = '#795548'; ctx.fillRect(0, 0, 15, 3); // Trzonek
            ctx.fillStyle = '#607d8b'; ctx.fillRect(12, -3, 6, 9); // Głowica
            ctx.restore();

            // Info o cenie (tylko w przerwie)
            if (waveDelay > 0 && player.armorTier < 2) {
                const dist = Math.hypot(player.x - armorStation.x, player.y - armorStation.y);
                if (dist < 60) {
                    const cost = armorStation.costs[player.armorTier];
                    const txt = player.armorTier === 0 ? "Kamizelka" : "Maska";
                    
                    ctx.fillStyle = player.scrap >= cost ? '#00ff00' : '#ff0000';
                    ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center';
                    ctx.fillText(`[R] ${txt}: ${cost} Złom`, 0, -40);
                }
            }
            ctx.restore();
        }

                    function drawGunStation() {
            ctx.save();
            ctx.translate(gunStation.x, gunStation.y);
            
            // --- STÓŁ ---
            // Cień
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.beginPath(); ctx.ellipse(0, 20, 50, 15, 0, 0, Math.PI*2); ctx.fill();

            // Nogi (Solidne, ciemne drewno)
            ctx.fillStyle = '#3e2723';
            ctx.fillRect(-35, 0, 8, 25); // Lewa
            ctx.fillRect(27, 0, 8, 25);  // Prawa
            // Belka wzmacniająca
            ctx.fillRect(-28, 18, 56, 4);

            // Blat (Gruby)
            ctx.fillStyle = '#4e342e'; 
            ctx.fillRect(-40, -15, 80, 20);
            // Krawędź blatu
            ctx.fillStyle = '#3e2723'; 
            ctx.fillRect(-42, -15, 2, 20); ctx.fillRect(40, -15, 2, 20); ctx.fillRect(-42, 5, 84, 3);

            // Sukno (Zielona mata robocza na środku)
            ctx.fillStyle = '#2e7d32'; 
            ctx.fillRect(-35, -12, 70, 14);
            ctx.strokeStyle = '#1b5e20'; ctx.lineWidth=1; ctx.strokeRect(-35, -12, 70, 14);

            // --- DETALE NA STOLE ---
            
            // Lampa olejna (Po prawej)
            ctx.fillStyle = '#cd7f32'; // Mosiądz
            ctx.beginPath(); ctx.arc(30, -10, 6, 0, Math.PI*2); ctx.fill(); // Baza
            ctx.fillRect(28, -20, 4, 10); // Palnik
            // Klosz szklany
            ctx.fillStyle = 'rgba(255, 255, 200, 0.3)';
            ctx.beginPath(); ctx.ellipse(30, -25, 5, 10, 0, 0, Math.PI*2); ctx.fill();
            // Płomień (Migoczący)
            const flicker = Math.random() * 0.3 + 0.7;
            const lightSize = 20 * flicker;
            const light = ctx.createRadialGradient(30, -22, 0, 30, -22, lightSize);
            light.addColorStop(0, 'rgba(255, 200, 50, 0.8)');
            light.addColorStop(1, 'rgba(255, 100, 0, 0)');
            ctx.fillStyle = light;
            ctx.beginPath(); ctx.arc(30, -22, lightSize, 0, Math.PI*2); ctx.fill();

            // Schemat techniczny (Po lewej, przybity gwoździem)
            ctx.save(); ctx.translate(-25, -8); ctx.rotate(-0.2);
            ctx.fillStyle = '#fff9c4'; // Papier
            ctx.fillRect(0, 0, 20, 15);
            // Rysunek rewolweru (szkic)
            ctx.strokeStyle = '#5d4037'; ctx.lineWidth=1;
            ctx.beginPath(); 
            ctx.moveTo(5, 5); ctx.lineTo(15, 5); // Lufa
            ctx.moveTo(5, 5); ctx.lineTo(5, 10); // Rękojeść
            ctx.stroke();
            // Gwóźdź
            ctx.fillStyle = '#555'; ctx.beginPath(); ctx.arc(10, 2, 1, 0, Math.PI*2); ctx.fill();
            ctx.restore();

            // Narzędzia (Śrubokręt)
            ctx.save(); ctx.translate(10, -5); ctx.rotate(0.8);
            ctx.fillStyle = '#e65100'; ctx.fillRect(0, 0, 8, 3); // Rączka
            ctx.fillStyle = '#90a4ae'; ctx.fillRect(8, 1, 6, 1); // Grot
            ctx.restore();

            // Naboje (Luzem)
            ctx.fillStyle = '#ffd700'; // Złoty
            ctx.beginPath(); ctx.arc(-5, -2, 2, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(-8, 0, 2, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(-2, 1, 2, 0, Math.PI*2); ctx.fill();

            // PRZEDMIOT ULEPSZENIA (Na środku, podświetlony lampą)
            if (player.revolverTier < 2) {
                ctx.save(); ctx.translate(5, -8);
                
                if (player.revolverTier === 0) {
                    // Podwójna lufa (Leży osobno)
                    ctx.fillStyle = '#78909c'; // Stal
                    ctx.fillRect(-10, 0, 20, 6); // Blok lufy
                    ctx.fillStyle = '#37474f'; 
                    ctx.beginPath(); ctx.arc(-10, 3, 2, 0, Math.PI*2); ctx.fill(); // Gwint
                    ctx.beginPath(); ctx.arc(-10, 5, 2, 0, Math.PI*2); ctx.fill(); // Druga lufa
                } else {
                    // Mechanizm spustowy (Skomplikowany element)
                    ctx.fillStyle = '#ffab00'; // Mosiądz
                    ctx.beginPath();
                    ctx.moveTo(0,0); ctx.lineTo(5, 5); ctx.lineTo(0, 10); ctx.lineTo(-5, 5);
                    ctx.fill();
                    ctx.strokeStyle = '#3e2723'; ctx.stroke();
                    // Sprężynka
                    ctx.strokeStyle = '#b0bec5'; ctx.beginPath(); ctx.arc(0, 5, 4, 0, Math.PI*2); ctx.stroke();
                }
                ctx.restore();
            }

            // --- INFO UI ---
            if (waveDelay > 0 && player.revolverTier < 2) {
                const dist = Math.hypot(player.x - gunStation.x, player.y - gunStation.y);
                if (dist < 60) {
                    const cost = gunStation.costs[player.revolverTier];
                    const txt = player.revolverTier === 0 ? "Dwulufowy" : "Seria";
                    
                    ctx.fillStyle = player.scrap >= cost ? '#00ff00' : '#ff0000';
                    ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center';
                    ctx.fillText(`[R] ${txt}: ${cost} Złom`, 0, -45);
                }
            }
            ctx.restore();
        }

         function drawSniperStation() {
            ctx.save();
            ctx.translate(sniperStation.x, sniperStation.y);
            
            // Cień pod stołem
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.beginPath(); ctx.ellipse(0, 20, 45, 12, 0, 0, Math.PI*2); ctx.fill();

            // --- STÓŁ (Drewniany) ---
            // Nogi
            ctx.fillStyle = '#3e2723'; // Ciemny brąz
            ctx.fillRect(-30, 0, 8, 25);
            ctx.fillRect(22, 0, 8, 25);
            // Belka
            ctx.fillRect(-25, 15, 50, 5);

            // Blat (Jasne drewno)
            ctx.fillStyle = '#5d4037'; 
            ctx.fillRect(-40, -15, 80, 20);
            // Faktura desek
            ctx.strokeStyle = '#3e2723'; ctx.lineWidth=1;
            ctx.beginPath(); ctx.moveTo(-10, -15); ctx.lineTo(-10, 5); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(20, -15); ctx.lineTo(20, 5); ctx.stroke();

            // --- CZĘŚCI BRONI (Dekoracje stałe) ---
            
            // Kolba snajperska (Leży po lewej)
            ctx.fillStyle = '#212121'; // Czarny polimer
            ctx.beginPath();
            ctx.moveTo(-35, -10); 
            ctx.lineTo(-15, -10);
            ctx.lineTo(-15, -5);
            ctx.lineTo(-35, 0);
            ctx.fill();
            // Stopka kolby
            ctx.fillStyle = '#000'; ctx.fillRect(-37, -10, 2, 10);

            // Luneta (Leży po prawej)
            ctx.fillStyle = '#263238'; 
            ctx.fillRect(15, -12, 20, 4);
            ctx.fillStyle = '#4fc3f7'; ctx.fillRect(35, -12, 2, 4); // Soczewka

            // Magazynek (Leży płasko)
            ctx.fillStyle = '#424242';
            ctx.fillRect(5, -5, 10, 8);

            // --- CZĘŚĆ GŁÓWNA (Zależna od Tieru) ---
            if (player.sniperTier < 2) {
                ctx.save(); ctx.translate(0, -10); ctx.rotate(-0.1);
                
                if (player.sniperTier === 0) {
                    // TIER 1 UPGRADE: Ciężka lufa .50
                    ctx.fillStyle = '#37474f'; // Stal
                    ctx.fillRect(-15, -5, 40, 5); // Długa lufa
                    // Hamulec wylotowy
                    ctx.fillStyle = '#000';
                    ctx.beginPath(); ctx.moveTo(25, -5); ctx.lineTo(32, -8); ctx.lineTo(32, 0); ctx.lineTo(25, -2); ctx.fill();
                } else {
                    // TIER 2 UPGRADE: Szyna Gaussa
                    ctx.fillStyle = '#cfd8dc'; // Jasny metal
                    ctx.fillRect(-10, -5, 30, 6);
                    // Cewki
                    ctx.fillStyle = '#00bcd4'; // Miedź/Energia
                    ctx.fillRect(-5, -6, 4, 8);
                    ctx.fillRect(5, -6, 4, 8);
                    ctx.fillRect(15, -6, 4, 8);
                }
                ctx.restore();
            }

            // --- UI CENY (Sam tekst) ---
            if (waveDelay > 0 && player.sniperTier < 2) {
                const dist = Math.hypot(player.x - sniperStation.x, player.y - sniperStation.y);
                if (dist < 60) {
                    const cost = sniperStation.costs[player.sniperTier];
                    const txt = player.sniperTier === 0 ? "Kaliber .50" : "Działo Gaussa";
                    
                    ctx.textAlign = 'center';
                    
                    // Cień tekstu dla czytelności
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 12px Arial';
                    ctx.fillText(`[R] ${txt}: ${cost} Złom`, 1, -39);
                    
                    // Właściwy tekst
                    ctx.fillStyle = player.scrap >= cost ? '#00ff00' : '#ff3333';
                    ctx.fillText(`[R] ${txt}: ${cost} Złom`, 0, -40);
                }
            }
            ctx.restore();
        }

        function drawFoxStation() {
            ctx.save();
            ctx.translate(foxStation.x, foxStation.y);
            
            // 1. CIEŃ (Płaski, pod podstawą)
            const sizeBase = 25 + foxStation.tier * 5;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.beginPath(); 
            ctx.ellipse(0, 10, sizeBase, sizeBase * 0.4, 0, 0, Math.PI*2); 
            ctx.fill();

            // 2. NORA (Zależna od Tieru)

            if (foxStation.tier === 0) {
                // --- TIER 0: Rozkopana ziemia ---
                ctx.fillStyle = '#4e342e'; 
                ctx.beginPath(); ctx.ellipse(0, 5, 20, 10, 0, 0, Math.PI*2); ctx.fill();
                
                // Ciemniejszy środek (dziura)
                ctx.fillStyle = '#3e2723';
                ctx.beginPath(); ctx.ellipse(0, 5, 10, 5, 0, 0, Math.PI*2); ctx.fill();

            } else if (foxStation.tier === 1) {
                // --- TIER 1: Prosty kopiec z kamieniami ---
                ctx.fillStyle = '#5d4037'; 
                ctx.beginPath(); ctx.arc(0, 10, sizeBase - 5, Math.PI, 0); ctx.lineTo(sizeBase - 5, 10); ctx.fill();
                
                // Wejście
                const holeSize = 12;
                const holeGrad = ctx.createRadialGradient(0, 8, 2, 0, 8, holeSize);
                holeGrad.addColorStop(0, '#000'); holeGrad.addColorStop(1, '#3e2723');
                ctx.fillStyle = holeGrad; ctx.beginPath(); ctx.arc(0, 8, holeSize, Math.PI, 0); ctx.fill();

                // Kamienie (Szare otoczaki)
                ctx.fillStyle = '#757575';
                ctx.beginPath(); ctx.arc(-15, 10, 5, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(15, 10, 4, 0, Math.PI*2); ctx.fill();

            } else if (foxStation.tier === 2) {
                // --- TIER 2: Wzmocniony Bunkier Ziemny ---
                
                // Kopiec (Większy, ciemniejszy)
                ctx.fillStyle = '#4e342e'; 
                ctx.beginPath(); ctx.arc(0, 10, sizeBase - 5, Math.PI, 0); ctx.fill();

                // Belki wzmacniające wejście (Pionowe po bokach)
                ctx.fillStyle = '#3e2723'; // Ciemne drewno
                ctx.fillRect(-20, -5, 6, 15); // Lewa
                ctx.fillRect(14, -5, 6, 15);  // Prawa
                
                // Nadproże (Pozioma belka nad dziurą)
                ctx.fillStyle = '#5d4037';
                ctx.fillRect(-22, -8, 44, 6);

                // Wejście
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath(); ctx.arc(0, 10, 14, Math.PI, 0); ctx.fill();

                // Kamienie przy podstawie (Więcej)
                ctx.fillStyle = '#616161';
                ctx.beginPath(); ctx.arc(-25, 10, 6, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(25, 10, 5, 0, Math.PI*2); ctx.fill();

            } else {
                // --- TIER 3: Twierdza Lisa (Palisada i Czaszka) ---

                // Kopiec (Ogromny)
                ctx.fillStyle = '#3e2723';
                ctx.beginPath(); ctx.arc(0, 10, sizeBase - 5, Math.PI, 0); ctx.fill();

                // Palisada (Zaostrzone pale wbite w ziemię po bokach)
                ctx.fillStyle = '#795548';
                // Lewa strona
                ctx.beginPath(); ctx.moveTo(-35, 10); ctx.lineTo(-35, -10); ctx.lineTo(-32, -15); ctx.lineTo(-29, -10); ctx.lineTo(-29, 10); ctx.fill();
                ctx.beginPath(); ctx.moveTo(-28, 10); ctx.lineTo(-28, -8); ctx.lineTo(-25, -13); ctx.lineTo(-22, -8); ctx.lineTo(-22, 10); ctx.fill();
                // Prawa strona
                ctx.beginPath(); ctx.moveTo(35, 10); ctx.lineTo(35, -10); ctx.lineTo(32, -15); ctx.lineTo(29, -10); ctx.lineTo(29, 10); ctx.fill();
                ctx.beginPath(); ctx.moveTo(28, 10); ctx.lineTo(28, -8); ctx.lineTo(25, -13); ctx.lineTo(22, -8); ctx.lineTo(22, 10); ctx.fill();

                // Dach z bali nad wejściem
                ctx.fillStyle = '#4e342e';
                ctx.beginPath();
                ctx.moveTo(-20, -5); ctx.lineTo(0, -15); ctx.lineTo(20, -5); // Daszek trójkątny
                ctx.lineTo(20, 0); ctx.lineTo(0, -10); ctx.lineTo(-20, 0);
                ctx.fill();

                // Wejście (Głęboka czerń)
                ctx.fillStyle = '#000';
                ctx.beginPath(); ctx.arc(0, 10, 16, Math.PI, 0); ctx.fill();

                // Czaszka (Ozdoba przed wejściem)
                ctx.fillStyle = '#bdbdbd'; // Kość
                ctx.save(); ctx.translate(0, -20); // Nad wejściem
                ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI*2); ctx.fill(); // Czaszka
                ctx.fillRect(-2, 3, 1, 3); ctx.fillRect(1, 3, 1, 3); // Zęby
                ctx.restore();
            }

            // UI Ceny
            if (waveDelay > 0 && foxStation.tier < 3) {
                const dist = Math.hypot(player.x - foxStation.x, player.y - foxStation.y);
                if (dist < 60) {
                    const cost = foxStation.costs[foxStation.tier];
                    let nextCount = 0;
                    if (foxStation.tier === 0) nextCount = 2;
                    else if (foxStation.tier === 1) nextCount = 3;
                    else if (foxStation.tier === 2) nextCount = 5;

                    ctx.textAlign = 'center';
                    ctx.font = 'bold 12px Arial';
                    ctx.fillStyle = player.scrap >= cost ? '#00ff00' : '#ff3333';
                    ctx.fillText(`[R] Lisy (${nextCount}): ${cost} Złom`, 0, -35);
                }
            }
            ctx.restore();
        }

        function drawFoxes() {
            if (foxStation.tier > 0) {
                const baseOrbitRadius = 100; // Musi być taki sam jak w update
                
                // Pulsowanie wspólne
                const pulse = Math.sin(gameTime * 0.1) * 25; 
                const currentRadius = baseOrbitRadius + pulse;

                foxStation.foxes.forEach(fox => {
                    const fx = player.x + Math.cos(fox.angle) * currentRadius;
                    const fy = player.y + Math.sin(fox.angle) * currentRadius;

                    ctx.save();
                    ctx.translate(fx, fy);
                    ctx.scale(1.5, 1.5); 
                    
                    ctx.rotate(fox.angle + Math.PI / 2); 
                    // Cień
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.beginPath(); ctx.ellipse(0, 10, 8, 3, 0, 0, Math.PI*2); ctx.fill();

                    // Ciało (Idealna pomarańczowa kulka)
                    ctx.fillStyle = '#e65100'; // Pomarańcz
                    ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI*2); ctx.fill();

                    // Brzuszek (Białe kółko na dole)
                    ctx.fillStyle = '#fff';
                    ctx.beginPath(); ctx.arc(0, 3, 4, 0, Math.PI*2); ctx.fill();

                    // Uszy (Trójkąciki na górze)
                    ctx.fillStyle = '#e65100';
                    ctx.beginPath(); ctx.moveTo(-6, -4); ctx.lineTo(-8, -10); ctx.lineTo(-3, -7); ctx.fill(); // Lewe
                    ctx.beginPath(); ctx.moveTo(6, -4); ctx.lineTo(8, -10); ctx.lineTo(3, -7); ctx.fill();  // Prawe
                    // Wnętrze uszu (Czarne)
                    ctx.fillStyle = '#212121';
                    ctx.beginPath(); ctx.moveTo(-6, -5); ctx.lineTo(-7, -8); ctx.lineTo(-4, -6); ctx.fill();
                    ctx.beginPath(); ctx.moveTo(6, -5); ctx.lineTo(7, -8); ctx.lineTo(4, -6); ctx.fill();

                    // Oczy (Czarne kropki)
                    ctx.fillStyle = '#000';
                    ctx.beginPath(); ctx.arc(-3, -1, 1.5, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(3, -1, 1.5, 0, Math.PI*2); ctx.fill();

                    // Nos (Mały trójkącik)
                    ctx.beginPath(); ctx.moveTo(-1, 1); ctx.lineTo(1, 1); ctx.lineTo(0, 3); ctx.fill();

                    // Policzki (Różowe)
                    ctx.fillStyle = 'rgba(255, 100, 100, 0.5)';
                    ctx.beginPath(); ctx.arc(-5, 1, 2, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(5, 1, 2, 0, Math.PI*2); ctx.fill();

                    // Ogon (Doklejona kulka z tyłu, lekko macha)
                    const wag = Math.sin(gameTime * 0.2) * 2;
                    ctx.translate(wag, 0); // Machanie
                    ctx.fillStyle = '#e65100';
                    ctx.beginPath(); ctx.arc(0, -7, 4, 0, Math.PI*2); ctx.fill(); // Baza ogona
                    ctx.fillStyle = '#fff';
                    ctx.beginPath(); ctx.arc(0, -9, 2, 0, Math.PI*2); ctx.fill(); // Końcówka

                    ctx.restore();
                });
            }
        }
        function drawHawkNest() {
            ctx.save();
            ctx.translate(hawkNest.x, hawkNest.y);
            
            // Cień słupa
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath(); ctx.ellipse(0, 60, 10, 4, 0, 0, Math.PI*2); ctx.fill();

            // Słup (Wysoki, drewniany)
            ctx.fillStyle = '#4e342e'; // Ciemne drewno
            ctx.fillRect(-3, 0, 6, 60);
            
            // Poprzeczka pod klatkę
            ctx.fillRect(-15, 0, 30, 4);
            
            // --- KLATKA ---
            ctx.translate(0, -25); // Środek klatki

            // Podstawa klatki
            ctx.fillStyle = '#3e2723';
            ctx.fillRect(-15, 20, 30, 4);

            // Pręty (Tylne)
            ctx.strokeStyle = '#5d4037'; ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-12, 20); ctx.lineTo(-12, -10);
            ctx.moveTo(0, 20);   ctx.lineTo(0, -15);
            ctx.moveTo(12, 20);  ctx.lineTo(12, -10);
            ctx.stroke();

            // Jastrząb SIEDZĄCY W ŚRODKU (Tylko jeśli kupiony i idle)
            if (hawk.purchased && hawk.state === 'idle') {
                // Ciało (Siedzi)
                ctx.fillStyle = '#6d4c41';
                ctx.beginPath(); ctx.ellipse(0, 10, 8, 12, 0, 0, Math.PI*2); ctx.fill();
                // Skrzydła (Złożone)
                ctx.fillStyle = '#4e342e';
                ctx.beginPath(); ctx.ellipse(-4, 12, 4, 8, 0.2, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.ellipse(4, 12, 4, 8, -0.2, 0, Math.PI*2); ctx.fill();
                // Głowa
                ctx.fillStyle = '#5d4037';
                ctx.beginPath(); ctx.arc(0, 2, 6, 0, Math.PI*2); ctx.fill();
                // Dziób
                ctx.fillStyle = '#ffeb3b';
                ctx.beginPath(); ctx.moveTo(4, 2); ctx.lineTo(8, 4); ctx.lineTo(4, 6); ctx.fill();
                // Oko
                ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(2, 0, 2, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(2.5, 0, 1, 0, Math.PI*2); ctx.fill();
            }

            // Pręty (Przednie)
            ctx.strokeStyle = '#6d4c41';
            ctx.beginPath();
            ctx.moveTo(-8, 20); ctx.lineTo(-8, -12);
            ctx.moveTo(8, 20);  ctx.lineTo(8, -12);
            ctx.stroke();

            // Daszek klatki
            ctx.fillStyle = '#3e2723';
            ctx.beginPath();
            ctx.moveTo(-18, -10);
            ctx.lineTo(0, -25);
            ctx.lineTo(18, -10);
            ctx.fill();

            // UI Ceny (Gdy nie kupiony i przerwa)
            if (!hawk.purchased && waveDelay > 0) {
                const dist = Math.hypot(player.x - hawkNest.x, player.y - hawkNest.y);
                if (dist < 100) {
                    ctx.fillStyle = player.scrap >= hawk.cost ? '#00ff00' : '#ff0000';
                    ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center';
                    ctx.fillText(`[R] Jastrząb: ${hawk.cost} Złom`, 0, -35);
                }
            }
            
            ctx.restore();
        }

                function drawHawk() {
            // Jeśli nie kupiony ALBO siedzi w klatce -> nie rysuj go tutaj
            if (!hawk.purchased || hawk.state === 'idle') return;

            ctx.save();
            ctx.translate(hawk.x, hawk.y);
            
            // Cień
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath(); ctx.ellipse(0, 40, 10, 4, 0, 0, Math.PI*2); ctx.fill();

            // Obrót
            let targetX = (hawk.state === 'fetching' && hawk.target) ? hawk.target.x : player.x;
            if (hawk.state === 'delivering') targetX = player.x;
            if (targetX < hawk.x) ctx.scale(-1, 1);

            // Animacja (Macha skrzydłami bo leci)
            const flap = Math.sin(hawk.animFrame) * 15;

            // Ogon
            ctx.fillStyle = '#4e342e';
            ctx.beginPath(); ctx.moveTo(-8, 0); ctx.lineTo(-18, -4); ctx.lineTo(-18, 4); ctx.fill();

            // Skrzydło tył
            ctx.fillStyle = '#3e2723';
            ctx.beginPath(); ctx.moveTo(2, -2); ctx.quadraticCurveTo(5, -15 + flap, 18, -5 + flap/2); ctx.lineTo(0, 0); ctx.fill();

            // Tułów
            ctx.fillStyle = '#6d4c41'; ctx.beginPath(); ctx.ellipse(0, 0, 12, 7, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#a1887f'; ctx.beginPath(); ctx.ellipse(0, 2, 8, 4, 0, 0, Math.PI*2); ctx.fill(); // Brzuszek

            // Głowa
            ctx.fillStyle = '#5d4037'; ctx.beginPath(); ctx.arc(10, -5, 6, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(11, -6, 2.5, 0, Math.PI*2); ctx.fill(); // Oko
            ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(11.5, -6, 1, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#ffeb3b'; ctx.beginPath(); ctx.moveTo(14, -5); ctx.lineTo(19, -2); ctx.lineTo(14, 0); ctx.fill(); // Dziób

            // Skrzydło przód
            ctx.fillStyle = '#5d4037';
            ctx.beginPath(); ctx.moveTo(2, -2); ctx.quadraticCurveTo(8, -25 - flap, 22, -10 - flap/2); ctx.lineTo(4, 2); ctx.fill();

            // Loot w szponach
            if (hawk.state === 'delivering') {
                const carryY = 8;
                if (hawk.inventory.scrap > 0) {
                    ctx.fillStyle = '#78909c'; ctx.beginPath(); ctx.arc(0, carryY, 5, 0, Math.PI*2); ctx.fill();
                } else if (hawk.inventory.medkits > 0) {
                    ctx.fillStyle = '#eee'; ctx.fillRect(-4, carryY-2, 8, 6); ctx.fillStyle='red'; ctx.fillRect(-1, carryY-1, 2, 4); ctx.fillRect(-3, carryY, 6, 2);
                } else if (hawk.inventory.ammo > 0) {
                    ctx.fillStyle = '#fbc02d'; ctx.fillRect(-4, carryY-2, 8, 5);
                }
                ctx.strokeStyle = '#ffab00'; ctx.lineWidth=2;
                ctx.beginPath(); ctx.moveTo(-2, 4); ctx.lineTo(0, carryY); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(2, 4); ctx.lineTo(0, carryY); ctx.stroke();
            } else {
                ctx.strokeStyle = '#ffab00'; ctx.lineWidth=2;
                ctx.beginPath(); ctx.moveTo(-2, 4); ctx.lineTo(-4, 6); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(2, 4); ctx.lineTo(4, 6); ctx.stroke();
            }

            ctx.restore();
        }

        function drawCrosshair() {
            const size = player.weapon === 'sniper' ? 25 : 18;
            const spread = player.weapon === 'sniper' ? 2 : 4;

            // Outer ring
            ctx.strokeStyle = player.vapeActive ? 'rgba(150, 100, 200, 0.8)' : 'rgba(200, 180, 150, 0.6)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(mouseX, mouseY, size, 0, Math.PI * 2);
            ctx.stroke();

            // Cross lines
            ctx.strokeStyle = player.vapeActive ? 'rgba(150, 100, 200, 0.9)' : 'rgba(200, 180, 150, 0.8)';
            ctx.lineWidth = 1.5;

            ctx.beginPath();
            ctx.moveTo(mouseX - size - 8, mouseY);
            ctx.lineTo(mouseX - spread, mouseY);
            ctx.moveTo(mouseX + spread, mouseY);
            ctx.lineTo(mouseX + size + 8, mouseY);
            ctx.moveTo(mouseX, mouseY - size - 8);
            ctx.lineTo(mouseX, mouseY - spread);
            ctx.moveTo(mouseX, mouseY + spread);
            ctx.lineTo(mouseX, mouseY + size + 8);
            ctx.stroke();

            // Center dot
            ctx.fillStyle = player.vapeActive ? '#a080c0' : '#c9b896';
            ctx.beginPath();
            ctx.arc(mouseX, mouseY, 2, 0, Math.PI * 2);
            ctx.fill();

            // Sniper additional indicators
            // Sniper Ammo Indicator (Nowoczesny Łuk)
            // Sniper Ammo Indicator (Prawy Dół, Mniejszy, Odwrócony)
            if (player.weapon === 'sniper') {
                const maxAmmo = 5 + player.sniperTier * 5;
                const currentAmmo = player.sniperAmmo;
                
                if (maxAmmo > 0) {
                    const radius = size + 10; // Mniejszy promień (było +20)
                    const totalArc = Math.PI / 2; // 1/4 koła (90 stopni)
                    
                    // Start: Dół (PI/2), Koniec: Prawo (0)
                    const startAngle = Math.PI / 2; 
                    
                    ctx.lineCap = 'butt';
                    ctx.lineWidth = 3; // Cieńszy (było 4)

                    // Tło paska (Szare)
                    ctx.beginPath();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                    // Rysujemy łuk tła od dołu do prawa (przeciwnie do wskazówek zegara)
                    ctx.arc(mouseX, mouseY, radius, startAngle, startAngle - totalArc, true);
                    ctx.stroke();

                    // Wypełnienie (Naboje)
                    const step = totalArc / maxAmmo;
                    
                    for (let i = 0; i < currentAmmo; i++) {
                        ctx.beginPath();
                        // Rysujemy od dołu w górę (odejmujemy kąt)
                        const segStart = startAngle - (i * step) - 0.02; 
                        const segEnd = startAngle - ((i + 1) * step) + 0.02;
                        
                        ctx.strokeStyle = '#ffd700'; // Złoty
                        if (currentAmmo <= maxAmmo * 0.2) ctx.strokeStyle = '#ff3d00'; // Czerwony przy końcówce

                        // true = counter-clockwise
                        ctx.arc(mouseX, mouseY, radius, segStart, segEnd, true);
                        ctx.stroke();
                    }
                }
            }
        }
        function gameLoop(timestamp) {
            if (!gameRunning || isPaused) return;
            if (!gameRunning) return;

            // Zabezpieczenie: jeśli timestamp nie istnieje, stwórz go
            if (!timestamp) timestamp = performance.now();

            // Zabezpieczenie: jeśli lastTime się zepsuł (jest NaN lub 0), zresetuj go
            if (!lastTime || isNaN(lastTime)) {
                lastTime = timestamp;
                accumulator = 0;
            }

            let deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            // Zabezpieczenie: jeśli gra miała laga (np. zmiana karty), utnij czas
            if (deltaTime > 1000) deltaTime = 16; 
            if (deltaTime < 0) deltaTime = 0;

            accumulator += deltaTime;

            // Pętla fizyki - wykonuje się, dopóki "uzbierany" czas pozwala na krok
            // Zabezpieczenie: max 10 aktualizacji na klatkę, żeby nie zawiesić przeglądarki
            let loops = 0;
            while (accumulator >= step && loops < 10) {
                update();
                accumulator -= step;
                loops++;
            }
            
            // Jeśli accumulator nadal jest ogromny (błąd), zresetuj go
            if (accumulator > step * 10) accumulator = 0;

            draw();
            requestAnimationFrame(gameLoop);
        }

        // Restart handling
        document.getElementById('restartBtn').addEventListener('click', () => {
            location.reload();
        });

        // Resize handling
        window.addEventListener('resize', () => {
            gameCanvas.width = window.innerWidth;
            gameCanvas.height = window.innerHeight;
            if (gameRunning) {
                house.x = gameCanvas.width / 2 - house.width / 2;
                house.y = gameCanvas.height / 2 - house.height / 2;
                generateEnvironment();
            }
        });

                // ==================== INPUT HANDLING ====================
        
        // Klawiatura
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true; 
            if(e.code==='Space') keys['space']=true;
            
            if (gameRunning && !gameOver) {
                // Blokada akcji podczas intro bossa
                const isBossIntro = (pablobitos && pablobitos.isIntro);

                if (!isBossIntro) {
                    if (e.key.toLowerCase() === 'e') activateVape();
                    if (e.key.toLowerCase() === 'h') {
                        if(player.medkits>0 && player.health<player.maxHealth) { 
                            player.medkits--; 
                            player.health=Math.min(player.maxHealth, player.health+40); 
                            showPickupNotification("Użyto apteczki"); 
                        }
                    }
                    // Spacja kończy przerwę
                    if (e.code === 'Space' && waveDelay > 0) { 
                        waveDelay = 0; 
                        showWaveAnnouncement(); 
                        document.getElementById('waveTimerPanel').style.display='none'; 
                    }
                }
            }
            
            // Obsługa cutscenek (Prolog i inne)
            if(e.code === 'Space' && cutsceneContainer.style.display !== 'none') {
                // Jeśli to prolog
                if (currentCutscene < cutscenes.length) {
                    currentCutscene++;
                    if(currentCutscene >= cutscenes.length) startGame(); else updateCutscene();
                } else {
                    // Jeśli to cutscenka w grze (np. boss) -> zamknij
                    cutsceneContainer.style.display = 'none';
                }
            }
        });

        document.addEventListener('keyup', (e) => { 
            keys[e.key.toLowerCase()] = false; 
            if(e.code==='Space') keys['space']=false; 
        });

        // Myszka (Przypięta do window, żeby nie zacinała)
        window.addEventListener('mousemove', e => { 
            mouseX = e.clientX; 
            mouseY = e.clientY; 
        });
        window.addEventListener('mousedown', () => mouseDown = true);
        window.addEventListener('mouseup', () => mouseDown = false);
        window.addEventListener('contextmenu', e => e.preventDefault());

            function handleBoarDeath(boar, index) {
            // Zabezpieczenie przed podwójnym zaliczeniem
            if (boar.isDead) return;
            boar.isDead = true;

            kills++;
            
            // 1. Krew
            createBloodEffect(boar.x, boar.y, 35);

            // 2. Flaki
            for (let m = 0; m < 5; m++) {
                meatChunks.push({
                    x: boar.x, y: boar.y,
                    vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 10,
                    rot: Math.random() * 7, rotSpeed: (Math.random() - 0.5) * 0.8,
                    size: 2.5 + Math.random() * 5, life: 400
                });
            }

            // 3. Szkielet
            corpses.push({
                x: boar.x, y: boar.y,
                angle: boar.angle,
                type: boar.isBoss ? 'boss' : (boar.isCharger ? 'charger' : 'normal'),
                life: 1200 // Szkielet leży 10s
            });



            // 4. DROP SYSTEM (Z czasami życia)
            
            // 1. Amunicja (Szansa zależna od stanu magazynka)
            let ammoChance = 0.2; // Bazowa szansa (20%)

            if (player.sniperAmmo >= 5 && player.sniperAmmo <= 9) ammoChance *= 0.5;  // 10% szansy
            if (player.sniperAmmo >= 10 && player.sniperAmmo <= 15) ammoChance *= 0.25; // 2.5% szansy
            if (player.sniperAmmo >= 15) ammoChance = 0;     // 0% szansy

            if (Math.random() < ammoChance) {
                ammoPickups.push({
                    x: boar.x, y: boar.y, 
                    amount: 3 + Math.floor(Math.random() * 3), 
                    life: 1200,
                    pulsePhase: 0
                });
            }
            
            // Apteczka (10% szans, znika po 20s)
            if (Math.random() < 0.1) {
                medkitPickups.push({
                    x: boar.x, y: boar.y, 
                    life: 300,
                    pulsePhase: 0
                });
            }
            
            // Złom (50% szans, znika po 60s)
            if (Math.random() < 0.5) {
                const scraps = []; 
                const count = 2 + Math.floor(Math.random() * 3);
                for (let k = 0; k < count; k++) {
                    scraps.push({ 
                        dx: (Math.random() - 0.5) * 20, 
                        dy: (Math.random() - 0.5) * 15, 
                        type: Math.random() > 0.5 ? 'gear' : 'plate', 
                        rot: Math.random() * Math.PI 
                    });
                }
                scrapPickups.push({
                    x: boar.x, y: boar.y, 
                    amount: 1 + Math.floor(Math.random() * 3), 
                    visuals: scraps, 
                    life: 3600,
                    pulsePhase: 0
                });
            }

            // 5. Usuń z gry
            boars.splice(index, 1);
        }

        function togglePause() {
            if (gameOver || (pablobitos && pablobitos.isIntro)) return;

            isPaused = !isPaused;

            if (isPaused) {
                // Rysujemy pauzę na obecnym kadrze
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset kamery

                // 1. Ciemne tło (0.95 opacity jak w CSS)
                ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

                // 2. TYTUŁ "PAUZA" (Styl Game Over)
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                ctx.shadowColor = 'rgba(139, 0, 0, 0.8)'; // Czerwona poświata
                ctx.shadowBlur = 50; // Duże rozmycie
                
                ctx.fillStyle = '#8b0000'; // Ciemna czerwień
                // Symulacja letter-spacing w Canvasie jest trudna, więc używamy spacji w stringu
                // Font size 72px
                ctx.font = '900 72px Georgia, serif'; 
                
                const cx = gameCanvas.width / 2;
                const cy = gameCanvas.height / 2;
                
                ctx.fillText("P A U Z A", cx, cy - 20);

                // 3. HINT (Mniejszy, szary)
                ctx.shadowBlur = 0; // Wyłącz cień dla małego tekstu
                ctx.fillStyle = '#7a6a5a';
                ctx.font = '24px Georgia, serif';
                ctx.fillText("[P] lub [ESC] aby wznowić", cx, cy + 40);

                ctx.restore();
            } else {
                // Wznów
                lastTime = performance.now();
                requestAnimationFrame(gameLoop);
            }
        }
    </script>
</body>
</html>